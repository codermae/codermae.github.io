<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My first blog</title>
    <url>/2021/05/01/My-first-blog/</url>
    <content><![CDATA[<h2 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h2><p>蛤蛤蛤蛤 终于搞定了 赶紧先来占个位 纪念一下五一还在学习的自己.</p>
<p>这是第二次搭建博客，但并不是我的第二个博客，因为第一次半途而废，因为当时感觉看的文章比较乱，<br>当然更重要的是 自 己 太 菜 ！    为了表达对参考文献作者的感激之情，就做个推广吧<a href="https://mp.weixin.qq.com/s/rIOoX2MMl0qEsJ4pnwJoqQ">原文</a>。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>个人感觉上面的文章已经写的很细了 就记录一下自己在搭建过程中遇到的两个问题吧顺便练习写博客哈哈~~~</p>
<span id="more"></span>

<h5 id="1-仓库创建"><a href="#1-仓库创建" class="headerlink" title="1.仓库创建"></a>1.仓库创建</h5><p><img src="https://i.loli.net/2021/05/01/DMTzOxP1csfaSNZ.png" alt="err"></p>
<p>Repository name: 固定格式self_uesername.github.io</p>
<p>还有就是要选Public！否则github page页面是看不见相关设置的</p>
<h5 id="2-部署网站"><a href="#2-部署网站" class="headerlink" title="2.部署网站"></a>2.部署网站</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>此时进度条已到底，激动的心，颤抖的手，直接输入地址却——</p>
<p><img src="https://i.loli.net/2021/05/01/Dnv9RmXGHjxpzqh.png" alt="err"></p>
<p>啪！快乐没了（表情包请自行脑补）</p>
<p>二话不说直接百度，有人说在电脑上不可以在手机上却可以，于是我也try了一下</p>
<p>果然可以进！！！但是与我想象的好像不大一样，网站内容仅显示了两行文本，</p>
<p>看了一眼应该是main里READEME.md的内容</p>
<p>思考(发呆)一会儿之后…找到了GitHub Pages设置发现</p>
<p><img src="https://i.loli.net/2021/05/01/MGwgK5XRPYC4foL.png" alt="err"></p>
<p><code>Your GitHub Pages site is currently being built from the 【main】 branch</code></p>
<p>于是将Branch改为master 刷新手机页面，啪！快乐回来了</p>
<p>但是电脑还是不能访问，可能是要修改host，一会儿继续改..</p>
<p>已经搞定，首先查询网站的ip地址可以在<a href="https://www.ipip.net/">这里查询</a> ，</p>
<p>然后在C:\Windows\System32\drivers\etc下找到并修改hosts，写入以下内容</p>
<p><code>ip self_username.github.io</code></p>
<p>再打开powershell 输入以下内容清理DNS缓存，网站应该就可以正常访问啦。</p>
<p><code>clear -dnsclientcache</code></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Githubpage+hexo博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>First Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0001</title>
    <url>/2021/05/04/%E6%89%93%E5%8D%A10001/</url>
    <content><![CDATA[<p><font color=red><strong>青春不息，奋斗不止</strong></font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="1-null-amp-amp-undefined-amp-amp-boolean"><a href="#1-null-amp-amp-undefined-amp-amp-boolean" class="headerlink" title="1.null &amp;&amp; undefined &amp;&amp; boolean"></a>1.null &amp;&amp; undefined &amp;&amp; boolean</h3><p><code>null</code>与<code>undefined</code>都可以表示“没有”，在if语句中都会自动转为<code>false</code><br>区别是<code>null</code>表示一个“空”的对象，转为数值是为<code>0</code><br>      <code>undefined</code>表示“此处无定义”的原始值，转为数值时为<code>NaN</code><br>      <span id="more"></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;undefined is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;null is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>undefined</code>表示“未定义”，以下场景都会返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 变量声明了，但没有赋值</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>布尔值代表<code>true</code>和<code>false</code>两个状态，下列运算符都会返回布尔值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前置逻辑运算符： ! (Not)</span><br><span class="line">相等运算符：&#x3D;&#x3D;&#x3D;，!&#x3D;&#x3D;，&#x3D;&#x3D;，!&#x3D;</span><br><span class="line">比较运算符：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;</span><br></pre></td></tr></table></figure>
<p>如果JS预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，只有以下六个<br>值被转为<code>false</code>，其它都被转为<code>true</code>，空数组和空对象对应的布尔值也为<code>true</code></p>
<p><code>undefined</code> <code>null</code> <code>false</code> <code>0</code> <code>NaN</code> <code>&quot;&quot;或&#39;&#39;(空字符串)</code></p>
<h3 id="2-数值"><a href="#2-数值" class="headerlink" title="2.数值"></a>2.数值</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><h5 id="2-1-1整数和浮点数"><a href="#2-1-1整数和浮点数" class="headerlink" title="2.1.1整数和浮点数"></a>2.1.1整数和浮点数</h5><p>JS内部，所有数字都是以64位浮点数形式储存，所以1与1.0是相同的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也就是说JS的底层根本没有证书，所有数字都是小数（64位浮点数），但是某些运算只有整数才能完成，<br>此时JS会把64位浮点数转成32位整数，然后在进行运算<br>由于浮点数是不确定的值，所以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-2数值精度"><a href="#2-1-2数值精度" class="headerlink" title="2.1.2数值精度"></a>2.1.2数值精度</h5><p>JS浮点数的64个二进制位，从最左边开始是这样构成的：<br><code>第1位：符号位，0表示正数，1表示负数，决定数的正负</code><br><code>第2-12位：指数部分，决定数值大小</code><br><code>第13-64位：小数部分，即有效数字，决定数值精度</code></p>
<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2的53次方到2的53次方，都可以精确表示超出之后运算结果会出现错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-3数值范围"><a href="#2-1-3数值范围" class="headerlink" title="2.1.3数值范围"></a>2.1.3数值范围</h5><p>指数部分的长度是11个二进制位，所以指数部分最大值是2047（2的11次方-1），分出一半表示负数，则JS能够表示的数值范围位<code>2的1024次方</code>到<code>2的负1023次方（开区间）</code>，超出这个范围的数则无法表示<br>如果一个数大于<code>2的1024次方</code>则会发生‘正向溢出’返回<code>Infinity</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>如果一个数小于<code>2的负1075次方（-1023再加上小数部分的52位）</code>，则会发生‘负向溢出’返回0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1075</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JavaScript 提供Number对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-数值的表示法"><a href="#2-2-数值的表示法" class="headerlink" title="2.2.数值的表示法"></a>2.2.数值的表示法</h4><p>JS的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）<br>数值也可以采用科学计数法表示,例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123e3</span> <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span> <span class="comment">// 0.123</span></span><br><span class="line">-<span class="number">3.1E+12</span> <span class="comment">// -3100000000000</span></span><br><span class="line"><span class="number">.1e-23</span> <span class="comment">// 1e-24</span></span><br></pre></td></tr></table></figure>
<p>若数值’小数点前的数字多于21位‘或‘小数点后的零多于5个’JavaScript 会自动将数值转为科学计数法表示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890123456789012</span></span><br><span class="line"><span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789012345678901</span></span><br><span class="line"><span class="comment">// 123456789012345680000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，</span></span><br><span class="line"><span class="comment">// 就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span> <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span> <span class="comment">// 0.000003</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-数值的进制"><a href="#2-3-数值的进制" class="headerlink" title="2.3.数值的进制"></a>2.3.数值的进制</h4><p>使用字面量（literal）直接表示一个数值时，JS对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制<br>默认情况下，JS内部会自动将八进制、十六进制、二进制转为十进制</p>
<h4 id="2-4-特殊数值"><a href="#2-4-特殊数值" class="headerlink" title="2.4.特殊数值"></a>2.4.特殊数值</h4><h4 id="2-4-1正零和负零"><a href="#2-4-1正零和负零" class="headerlink" title="2.4.1正零和负零"></a>2.4.1正零和负零</h4><p>第一个二进制位是符号位，这意味着所有数字都有负值，包括0<br>几乎所有场合，正零和负零都被当做为<code>0</code>，唯一有区别的场合是0作为分母时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">+<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">-<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">(-<span class="number">0</span>).toString() <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line">(+<span class="number">0</span>).toString() <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line">  --------------------</span><br><span class="line">  --------------------</span><br><span class="line">(<span class="number">1</span> / +<span class="number">0</span>) === (<span class="number">1</span> / -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"> <span class="comment">// 除以正零得到+Infinity，除以负零得到-Infinity</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-2-NaN"><a href="#2-4-2-NaN" class="headerlink" title="2.4.2 NaN"></a>2.4.2 NaN</h5><p><code>NaN</code>是一个特殊数值，属于<code>number</code>类型，表示“非数字”（not a number），主要出现在字符串解<br>析成数字出错的场合，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="number">5</span> - <span class="string">&#x27;x&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>另外，一些数学函数的运算结果也会出现<code>NaN</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span>除以<span class="number">0</span>也会得到<span class="literal">NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>   <span class="comment">// NaN </span></span><br></pre></td></tr></table></figure>
<p>运算规则：<br>NaN不等于任何值，包括本身,并且与任何数（包括它自己）的运算，得到的都是NaN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">// false   </span></span><br><span class="line"><span class="literal">NaN</span> + <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> - <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> / <span class="number">32</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对NaN不成立</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NaN在布尔运算时被当作false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-Infinity"><a href="#2-4-3-Infinity" class="headerlink" title="2.4.3 Infinity"></a>2.4.3 Infinity</h5><p><code>infinity</code> 表示”无穷“，有正负之分，出现在无穷和非0除以0的场景中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nfinity === -<span class="literal">Infinity</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>)   <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span>   <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">1</span> / -<span class="number">0</span> <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="number">1</span> / -<span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p><code>infinity</code>大于一切数值，<code>-infinity</code>小于一切数值，但与<code>NaN</code>比较会返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> &gt; <span class="number">1000</span> <span class="comment">// true</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; -<span class="number">1000</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>运算规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="literal">Infinity</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">5</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">null</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> + <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> - <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-与数值有关的全局方法"><a href="#2-5-与数值有关的全局方法" class="headerlink" title="2.5.与数值有关的全局方法"></a>2.5.与数值有关的全局方法</h4><h6 id="2-5-1-1-parseInt"><a href="#2-5-1-1-parseInt" class="headerlink" title="2.5.1.1 parseInt()"></a>2.5.1.1 parseInt()</h6><p><code>parseInt()</code>用于将字符串转为整数,若参数不是字符串，则先转换为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;   81&#x27;</span>) <span class="comment">// 81</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1.23&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>字符串转换的时候是一个个字符依次转换，如果遇到不能转为数字的字符就停止并返回已经转好的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8a&#x27;</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12**&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15e2&#x27;</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15px&#x27;</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;.3&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+1&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以parseint的返回值只有两个，要么是一个十进制数，要么是NaN<br>如果字符串以0或0x（X）开头，会按照10进制和16进制进行解析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;011&#x27;</span>) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0x10&#x27;</span>) <span class="comment">// 16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若存在自动转为科学计数法的数字，则视为科学计数法表示的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1e+21&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8e-7&#x27;</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h6 id="2-5-1-2进制转换"><a href="#2-5-1-2进制转换" class="headerlink" title="2.5.1.2进制转换"></a>2.5.1.2进制转换</h6><p>parseInt()还支持第二个参数（2-36），表示被解析的进制，默认为10</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>) <span class="comment">// 1000</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">10</span>) <span class="comment">// 1000</span></span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">2</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">6</span>) <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<p>若第二个参数不属于2-36则返回<code>NaN</code>,若是0、NaN、undefined则忽略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">0</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">null</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">undefined</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>若字符串包含对于制定进制无意义的字符，则从最高位开始，只返回可以转换的值，如果最高位无法转换则返回<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1546&#x27;</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;546&#x27;</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>当第一个参数不是字符串时,下面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制<br>或二进制解读字符串17，最后返回结果43和1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>) <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>当第一个参数是八进制0开头的非字符串时，下面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，<br>所以返回NaN。如果直接计算parseInt(‘011’, 2)，011则是会被当作二进制处理，返回3。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">011</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">011</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">9</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<h5 id="2-5-2-parseFloat"><a href="#2-5-2-parseFloat" class="headerlink" title="2.5.2 parseFloat()"></a>2.5.2 parseFloat()</h5><p>parseFloat()用于将字符串转为浮点数，如果字符串符合科学计数法，则会进行相应的转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;314e-2&#x27;</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;0.0314E+2&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<p>会自动过滤字符串前导的空格,如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="comment">// 12.34</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14aaaaaa&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;FF2&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>parseFloat()与number()的区别</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-isNaN"><a href="#2-5-3-isNaN" class="headerlink" title="2.5.3 isNaN()"></a>2.5.3 isNaN()</h5><p><code>isNaN</code>用来判断一个值是否为NaN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>若果传入非数值，会被先转为数值，比如传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回true，<br>所以<code>isNaN</code>为<code>true</code>的值不一定是<code>NaN</code>还可能是一个字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="string">&#x27;Hello&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对于对象和数组<code>isNaN</code>也返回<code>true</code>，但是对于空数组和只有一个数值成员的数组<code>isNaN</code>返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;xzy&#x27;</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>([<span class="string">&#x27;xzy&#x27;</span>])) <span class="comment">// true</span></span><br><span class="line">=========================</span><br><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;123&#x27;</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值,<br>因此，使用<code>isNaN</code>之前，最好判断一下数据类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-4-isFinite"><a href="#2-5-4-isFinite" class="headerlink" title="2.5.4 isFinite()"></a>2.5.4 isFinite()</h5><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code></p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-数值</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0002</title>
    <url>/2021/05/05/%E6%89%93%E5%8D%A10002/</url>
    <content><![CDATA[<p><font color=#daa520><strong>孟夏之日，万物并秀，愿你也如这热情初夏，昂扬向上，自强不息</strong></font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h3><h5 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h5><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中，单引号字符串的内部，可以使用<br>双引号。双引号字符串的内部，可以使用单引号，推荐HTML语言使用双引号，JS语言使用单引号</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;key = &quot;value&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;It&#x27;s a long journey&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双<br>引号字符串内部使用双引号，也是如此</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Did she say \&#x27;Hello\&#x27;?&#x27;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &#x27;Hello&#x27;?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Did she say \&quot;Hello\&quot;?&quot;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &quot;Hello&quot;?&quot;</span></span><br></pre></td></tr></table></figure>
<p>字符串默认只能写在一行内，如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠,<br>或者用<code>+</code>拼接多个单行字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">string&#x27;</span>;</span><br><span class="line"><span class="comment">// &quot;Long long long string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="comment">// &quot;Long long long string&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想输出多行字符串，有一种利用多行注释的变通方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/*s</span></span><br><span class="line"><span class="comment">line 1</span></span><br><span class="line"><span class="comment">line 2</span></span><br><span class="line"><span class="comment">line 3</span></span><br><span class="line"><span class="comment">*/</span>&#125;).toString().split(<span class="string">&#x27;\n&#x27;</span>).slice(<span class="number">1</span>, -<span class="number">1</span>).join(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;line 1</span></span><br><span class="line"><span class="comment">// line 2</span></span><br><span class="line"><span class="comment">// line 3&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-转义"><a href="#3-1-2-转义" class="headerlink" title="3.1.2 转义"></a>3.1.2 转义</h5><ul>
<li><code>\0</code> ：null（<code>\u0000</code>）</li>
<li><code>\b</code> ：后退键（<code>\u0008</code>）</li>
<li><code>\f</code>：换页符（<code>\u000C</code>）</li>
<li><code>\n</code> ：换行符（<code>\u000A</code>）</li>
<li><code>\r</code> ：回车键（<code>\u000D</code>）</li>
<li><code>\t</code> ：制表符（<code>\u0009</code>）</li>
<li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li>
<li><code>\&#39;</code> ：单引号（<code>\u0027</code>）</li>
<li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li>
<li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li>
</ul>
<p>反斜杠还有三种特殊的用法</p>
<ol>
<li><code>/HHH</code>: 反斜杠后面紧跟三个八进制数（000到377），代表一个字符</li>
<li><code>\xHH</code>: \x后面紧跟两个十六进制数（00到FF），代表一个字符</li>
<li><code>\uXXXX</code>:\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\251&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\xA9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\u00A9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\a&#x27;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-1-3-字符串与数组"><a href="#3-1-3-字符串与数组" class="headerlink" title="3.1.3 字符串与数组"></a>3.1.3 字符串与数组</h5><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符,但不能<br>对字符串进行增删操作如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则<br>返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// &quot;h&quot;</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">---------------------------</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">3</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[-<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-length属性"><a href="#3-1-4-length属性" class="headerlink" title="3.1.4 length属性"></a>3.1.4 length属性</h5><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">3</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">7</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-字符集"><a href="#3-2-字符集" class="headerlink" title="3.2 字符集"></a>3.2 字符集</h4><p>JavaScript 引擎内部，所有字符都用 Unicode 表示，JavaScript不仅以 Unicode 储存字符，还允许直接在程序中使用<code>Unicode</code>码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;\u00A9&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;©&quot;</span></span><br></pre></td></tr></table></figure>
<p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是Unicode形式表示。输出给用户的时候，所有字符都会转成字面形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006F = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">foo <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节,但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;𝌆&#x27;</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>总结一下，<strong>对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的</strong>。</p>
<h4 id="3-3-base64转码"><a href="#3-3-base64转码" class="headerlink" title="3.3 base64转码"></a>3.3 base64转码</h4><p>有时，文本里面包含一些不可打印的符号，比如ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码</p>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理</p>
<p>JavaScript 原生提供两个 Base64 相关的方法</p>
<ul>
<li><code>btoa()</code>:任意值转为 Base64 编码</li>
<li><code>atob()</code>:Base64 编码转为原来的值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">btoa(string) <span class="comment">// &quot;SGVsbG8gV29ybGQh&quot;</span></span><br><span class="line">atob(<span class="string">&#x27;SGVsbG8gV29ybGQh&#x27;</span>) <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
这两个方法不适合非 ASCII 码的字符，会报错,要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btoa(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line">b64Decode(<span class="string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0003</title>
    <url>/2021/05/05/%E6%89%93%E5%8D%A10003/</url>
    <content><![CDATA[<p><font color=skyblue><strong>愿我们都能接受生活最真实的日子，在经过了岁月的洗礼之后，仍能坚定地迈向自己向往的生活</strong></font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h3><h5 id="4-1-1-生成方法"><a href="#4-1-1-生成方法" class="headerlink" title="4.1.1 生成方法"></a>4.1.1 生成方法</h5><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  bar: <span class="string">&#x27;World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: ‘Hello’，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: ‘World’，bar是键名，World是键值。两个键值对之间用逗号分隔</p>
<h5 id="4-1-2-键名"><a href="#4-1-2-键名" class="headerlink" title="4.1.2 键名"></a>4.1.2 键名</h5><p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以，如果键名是数值，会被自动转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">3.2</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">1e2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">1e-2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">.234</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">0xFF</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   1: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   3.2: &quot;b&quot;,</span></span><br><span class="line"><span class="comment">//   100: true,</span></span><br><span class="line"><span class="comment">//   0.01: true,</span></span><br><span class="line"><span class="comment">//   0.234: true,</span></span><br><span class="line"><span class="comment">//   255: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;100&#x27;</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  1p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;1p&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;h w&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p+q&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用，下面代码中，对象obj的属性p，就指向一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>如果属性的值还是一个对象，就形成了链式引用，属性可以动态创建，不必在对象声明时就指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.foo = o2;</span><br><span class="line">o1.foo.bar <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性</p>
<h5 id="4-1-3-对象的引用"><a href="#4-1-3-对象的引用" class="headerlink" title="4.1.3 对象的引用"></a>4.1.3 对象的引用</h5><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.b = <span class="number">2</span>;</span><br><span class="line">o1.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量，下面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-表达式还是语句？"><a href="#4-1-4-表达式还是语句？" class="headerlink" title="4.1.4 表达式还是语句？"></a>4.1.4 表达式还是语句？</h5><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。</p>
<p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;) <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>这种差异在eval语句（作用是对字符串求值）中反映得最明显</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="comment">// &#123;foo: 123&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象</p>
<h4 id="4-2-属性的操作"><a href="#4-2-属性的操作" class="headerlink" title="4.2 属性的操作"></a>4.2 属性的操作</h4><h5 id="4-2-1-属性的读取"><a href="#4-2-1-属性的读取" class="headerlink" title="4.2.1 属性的读取"></a>4.2.1 属性的读取</h5><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;p&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  <span class="comment">// 1</span></span><br><span class="line">obj[foo]  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>方括号运算符内部还可以使用表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27; world&#x27;</span>]</span><br><span class="line">obj[<span class="number">3</span> + <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>数字键可以不加引号，因为会自动转成字符串,数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0.7</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;0.7&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="number">0.7</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">--------------------------</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">123</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj<span class="number">.123</span> <span class="comment">// 报错</span></span><br><span class="line">obj[<span class="number">123</span>] <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-属性的赋值"><a href="#4-2-2-属性的赋值" class="headerlink" title="4.2.2 属性的赋值"></a>4.2.2 属性的赋值</h5><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值,JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[<span class="string">&#x27;bar&#x27;</span>] = <span class="string">&#x27;World&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-属性的查看"><a href="#4-2-3-属性的查看" class="headerlink" title="4.2.3 属性的查看"></a>4.2.3 属性的查看</h5><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  key1: <span class="number">1</span>,</span><br><span class="line">  key2: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-属性的删除"><a href="#4-2-4-属性的删除" class="headerlink" title="4.2.4 属性的删除"></a>4.2.4 属性的删除</h5><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>,如果删除一个不存在的属性，delete不报错，而且返回<code>true</code>,因此，不能根据delete命令的结果，认定某个属性是存在的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// [&quot;p&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值</p>
<h5 id="4-2-5-判断属性是否存在"><a href="#4-2-5-判断属性是否存在" class="headerlink" title="4.2.5 判断属性是否存在"></a>4.2.5 判断属性是否存在</h5><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>它不能识别哪些属性是对象自身的,这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-6-对象的遍历"><a href="#4-2-6-对象的遍历" class="headerlink" title="4.2.6 对象的遍历"></a>4.2.6 对象的遍历</h5><p><code>for...in</code>循环用来遍历一个对象的全部属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;键名：&#x27;</span>, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;键值：&#x27;</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名： a</span></span><br><span class="line"><span class="comment">// 键值： 1</span></span><br><span class="line"><span class="comment">// 键名： b</span></span><br><span class="line"><span class="comment">// 键值： 2</span></span><br><span class="line"><span class="comment">// 键名： c</span></span><br><span class="line"><span class="comment">// 键值： 3</span></span><br></pre></td></tr></table></figure>
<p><code>for...in</code>循环有两个使用注意点</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性</li>
</ul>
<p>举例来说，对象都继承了toString属性，但是for…in循环不会遍历到这个属性,因为它默认是“不可遍历”的<br>一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;老张&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure>


<h4 id="4-3-with语句"><a href="#4-3-with语句" class="headerlink" title="4.3 with语句"></a>4.3 with语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">1</span>,</span><br><span class="line">  p2: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj.p1 = <span class="number">4</span>;</span><br><span class="line">obj.p2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>.links[<span class="number">0</span>])&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(href);</span><br><span class="line">  <span class="built_in">console</span>.log(title);</span><br><span class="line">  <span class="built_in">console</span>.log(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].href);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].title);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].style);</span><br></pre></td></tr></table></figure>

<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p1 <span class="comment">// undefined</span></span><br><span class="line">p1 <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">obj1.obj2.obj3</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3;</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure>


<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-对象</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0005</title>
    <url>/2021/05/07/%E6%89%93%E5%8D%A10005/</url>
    <content><![CDATA[<p><font color=#7bbfea>瞥扭的心态，得靠自个儿去调适~~~</font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>数组（array）是按次序排列的一组值，每个值都有编号（从0开始），整个数组用方括号表示</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>a</code>、<code>b</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置</p>
<p>除了在定义时赋值，数组也可以先定义后赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>任何类型的数据，都可以放入数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// Object &#123;a: 1&#125;</span></span><br><span class="line">arr[<span class="number">1</span>] <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// function ()&#123;return true;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果数组的元素还是数组，就形成了多维数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] <span class="comment">// 2</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-数组的本质"><a href="#6-2-数组的本质" class="headerlink" title="6.2 数组的本质"></a>6.2 数组的本质</h4><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(arr)</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2</p>
<p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="string">&#x27;0&#x27;</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串</p>
<p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1.00</span>] = <span class="number">6</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值</p>
<p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr<span class="number">.0</span> <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（<code>identifier</code>）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）</p>
<h4 id="6-3-length属性"><a href="#6-3-length属性" class="headerlink" title="6.3 length属性"></a>6.3 length属性</h4><p>数组的length属性，返回数组的成员数量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295</p>
<p>只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">arr.length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">9</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">1000</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 1001</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员</p>
<p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，当数组的<code>length</code>属性设为<code>2</code>（即最大的整数键只能是<code>1</code>）那么整数键<code>2</code>（值为<code>c</code>）就已经不在数组中了，被自动删除了</p>
<p>清空数组的一个有效方法，就是将length属性设为0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.length = <span class="number">3</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code></p>
<p>如果人为设置<code>length</code>为不合法的值，JavaScript 会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置负值</span></span><br><span class="line">[].length = -<span class="number">1</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素个数大于等于2的32次方</span></span><br><span class="line">[].length = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符串</span></span><br><span class="line">[].length = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;p&#x27;</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2.1</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加<code>1</code>，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code></p>
<p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">arr.length <span class="comment">// 0</span></span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// &quot;a&quot;</span></span><br><span class="line">arr[<span class="number">4294967296</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串</p>
<h4 id="6-4-in运算符"><a href="#6-4-in运算符" class="headerlink" title="6.4 in运算符"></a>6.4 in运算符</h4><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">100</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code></p>
<h4 id="6-5-for…in循环和数组的遍历"><a href="#6-5-for…in循环和数组的遍历" class="headerlink" title="6.5 for…in循环和数组的遍历"></a>6.5 for…in循环和数组的遍历</h4><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组<br>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; a.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = a.length;</span><br><span class="line"><span class="keyword">while</span> (l--) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历</p>
<p>数组的<code>forEach</code>方法，也可以用来遍历数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line">colors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h4 id="6-6-数组的空位"><a href="#6-6-数组的空位" class="headerlink" title="6.6 数组的空位"></a>6.6 数组的空位</h4><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, , <span class="number">1</span>];</span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，数组的空位不影响<code>length</code>属性</p>
<p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,];</span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 3</span></span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>数组的空位是可以读取的，返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响length属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0. undefined</span></span><br><span class="line"><span class="comment">// 1. undefined</span></span><br><span class="line"><span class="comment">// 2. undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a)</span><br><span class="line"><span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过</p>
<h4 id="6-7-类似数组的对象"><a href="#6-7-类似数组的对象" class="headerlink" title="6.7 类似数组的对象"></a>6.7 类似数组的对象</h4><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">obj[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">obj.length <span class="comment">// 3</span></span><br><span class="line">obj.push(<span class="string">&#x27;d&#x27;</span>) <span class="comment">// TypeError: obj.push is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错</p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">obj.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组</p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span> &#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = args(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arrayLike[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arrayLike.length <span class="comment">// 2</span></span><br><span class="line">arrayLike <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM元素集</span></span><br><span class="line"><span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h3&#x27;</span>);</span><br><span class="line">elts.length <span class="comment">// 3</span></span><br><span class="line">elts <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.length <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组</p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>
<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">elem, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="string">&#x27;abc&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b.</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>


<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0006</title>
    <url>/2021/05/08/%E6%89%93%E5%8D%A10006/</url>
    <content><![CDATA[<p><font color=#cd8c95>你要离开我吗？别走好吗？跑起来。</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>JavaScript 共提供10个算术运算符，用来完成基本的算术运算</p>
<ul>
<li>加法运算符：<code>x + y</code></li>
<li>减法运算符： <code>x - y</code></li>
<li>乘法运算符： <code>x * y</code></li>
<li>除法运算符：<code>x / y</code></li>
<li>指数运算符：<code>x ** y</code></li>
<li>余数运算符：<code>x % y</code></li>
<li>自增运算符：<code>++x</code> 或者 <code>x++</code></li>
<li>自减运算符：<code>--x</code> 或者 <code>x--</code></li>
<li>数值运算符： <code>+x</code></li>
<li>负数值运算符：<code>-x</code><span id="more"></span>
<h4 id="1-2-加法运算符"><a href="#1-2-加法运算符" class="headerlink" title="1.2 加法运算符"></a>1.2 加法运算符</h4></li>
</ul>
<h5 id="1-2-1-基本规则"><a href="#1-2-1-基本规则" class="headerlink" title="1.2.1 基本规则"></a>1.2.1 基本规则</h5><p>加法运算符<code>+</code>是最常见的运算符，用来求两个数值的和<br>1 + 1 //2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript 允许非数值的相加</span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">true + true &#x2F;&#x2F; 2</span><br><span class="line">1 + true &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加</p>
<p>比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span> <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;a&#x27;</span> <span class="comment">// &quot;1a&quot;</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">&#x27;a&#x27;</span> <span class="comment">// &quot;falsea&quot;</span></span><br></pre></td></tr></table></figure>
<p>加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;3&#x27;</span> + <span class="number">4</span> + <span class="number">5</span> <span class="comment">// &quot;345&quot;</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> + <span class="string">&#x27;5&#x27;</span> <span class="comment">// &quot;75&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果</p>
<p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">1</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> / <span class="string">&#x27;2&#x27;</span> <span class="comment">// 0.5</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-对象的相加"><a href="#1-2-2-对象的相加" class="headerlink" title="1.2.2 对象的相加"></a>1.2.2 对象的相加</h5><p>如果运算子是对象，必须先转成原始类型的值，然后再相加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;[object Object]2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>转成原始类型的值是<code>[object Object]</code>，再加<code>2</code>就得到了上面的结果<br>对象转成原始类型的值，规则如下:<br>首先，自动调用对象的<code>valueOf</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.valueOf() <span class="comment">// &#123; p: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<p>般来说，对象的<code>valueOf</code>方法总是返回对象自身，这时再自动调用对象的<code>toString</code>方法，将其转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.valueOf().toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>对象的<code>toString</code>方法默认返回<code>[object Object]</code>，所以就得到了最前面那个例子的结果</p>
<p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们定义<code>obj</code>对象的<code>valueOf</code>方法返回<code>1</code>，于是<code>obj + 2</code>就得到了<code>3</code>。这个例子中，由于<code>valueOf</code>方法直接返回一个原始类型的值，所以不再调用<code>toString</code>方法</p>
<p>下面是自定义toString方法的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;hello2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的<code>toString</code>方法返回字符串<code>hello</code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串</p>
<p>这里有一个特例，如果运算子是一个<code>Date</code>对象的实例，那么会优先执行<code>toString</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">obj.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;;</span><br><span class="line">obj.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;hello2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>是一个<code>Date</code>对象的实例，并且自定义了<code>valueOf</code>方法和<code>toString</code>方法，结果<code>toString</code>方法优先执行</p>
<h4 id="1-3-余数运算符"><a href="#1-3-余数运算符" class="headerlink" title="1.3 余数运算符"></a>1.3 余数运算符</h4><p>余数运算符（<code>%</code>）返回前一个运算子被后一个运算子除，所得的余数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> % <span class="number">5</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span> % <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">1</span> % -<span class="number">2</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以，为了得到负数的正确余数值，可以先使用绝对值函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">isOdd(-<span class="number">5</span>) <span class="comment">// false</span></span><br><span class="line">isOdd(-<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(n % <span class="number">2</span>) === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">isOdd(-<span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">isOdd(-<span class="number">4</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">6.5</span> % <span class="number">2.1</span></span><br><span class="line"><span class="comment">// 0.19999999999999973</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-自增和自减运算符"><a href="#1-4-自增和自减运算符" class="headerlink" title="1.4 自增和自减运算符"></a>1.4 自增和自减运算符</h4><p>自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">++x <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">--x <span class="comment">// 1</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码的变量<code>x</code>自增后，返回<code>2</code>，再进行自减，返回<code>1</code>。这两种情况都会使得，原始变量<code>x</code>的值发生改变<br>运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值<br>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x++ <span class="comment">// 1</span></span><br><span class="line">++y <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>x</code>是先返回当前值，然后自增，所以得到<code>1</code>；<code>y</code>是先自增，然后返回新的值，所以得到<code>2</code></p>
<h4 id="1-5-数值运算符，负数值运算符"><a href="#1-5-数值运算符，负数值运算符" class="headerlink" title="1.5 数值运算符，负数值运算符"></a>1.5 数值运算符，负数值运算符</h4><p>数值运算符（<code>+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">+[] <span class="comment">// 0</span></span><br><span class="line">+&#123;&#125; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行NaN也是数值）<br>负数值运算符（<code>-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">-x <span class="comment">// -1</span></span><br><span class="line">-(-x) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码最后一行的圆括号不可少，否则会变成自减运算符。</p>
<p>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值</p>
<h4 id="1-6-指数运算符"><a href="#1-6-指数运算符" class="headerlink" title="1.6 指数运算符"></a>1.6 指数运算符</h4><p>指数运算符（<code>**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">4</span> <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个</p>
<h4 id="1-7-赋值运算符"><a href="#1-7-赋值运算符" class="headerlink" title="1.7 赋值运算符"></a>1.7 赋值运算符</h4><p>赋值运算符（Assignment Operators）用于给变量赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 1 赋值给变量 x</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变量 y 的值赋值给变量 x</span></span><br><span class="line"><span class="keyword">var</span> x = y;</span><br></pre></td></tr></table></figure>
<p>赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 x = x + y</span></span><br><span class="line">x += y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x - y</span></span><br><span class="line">x -= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x * y</span></span><br><span class="line">x *= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x / y</span></span><br><span class="line">x /= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x % y</span></span><br><span class="line">x %= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x ** y</span></span><br><span class="line">x **= y</span><br></pre></td></tr></table></figure>
<p>下面是与位运算符的结合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 x = x &gt;&gt; y</span></span><br><span class="line">x &gt;&gt;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x &lt;&lt; y</span></span><br><span class="line">x &lt;&lt;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x &gt;&gt;&gt; y</span></span><br><span class="line">x &gt;&gt;&gt;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x &amp; y</span></span><br><span class="line">x &amp;= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x | y</span></span><br><span class="line">x |= y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 x = x ^ y</span></span><br><span class="line">x ^= y</span><br></pre></td></tr></table></figure>
<p>这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-算术运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0007</title>
    <url>/2021/05/08/%E6%89%93%E5%8D%A10007/</url>
    <content><![CDATA[<p><font color=aed2e5>无论眼下你正过着怎样的生活，欢喜也好，烦恼也罢，饿了就吃，困了就睡，明天又是崭新的一天。</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><h4 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h4><p>比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>注意，比较运算符可以比较各种类型的值，不仅仅是数值</code><br>JavaScript 一共提供了8个比较运算符</p>
<ul>
<li><code>&gt;</code> 大于运算符</li>
<li><code>&lt;</code> 小于运算符</li>
<li><code>&lt;=</code> 小于或等于运算符</li>
<li><code>&gt;=</code> 大于或等于运算符</li>
<li><code>==</code> 相等运算符</li>
<li><code>===</code> 严格相等运算符</li>
<li><code>!=</code> 不相等运算符</li>
<li><code>!==</code> 严格不相等运算符<br>这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小</li>
</ul>
<h4 id="2-2-非相等运算符：字符串的比较"><a href="#2-2-非相等运算符：字符串的比较" class="headerlink" title="2.2 非相等运算符：字符串的比较"></a>2.2 非相等运算符：字符串的比较</h4><p>字符串按照字典顺序进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;dog&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;catalog&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;Cat&#x27;</span> <span class="comment">// true&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，小写的<code>c</code>的 Unicode 码点（<code>99</code>）大于大写的C的 Unicode 码点（<code>67</code>），所以返回<code>true</code><br>由于所有字符都有 Unicode 码点，因此汉字也可以比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;大&#x27;</span> &gt; <span class="string">&#x27;小&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回<code>false</code></p>
<h4 id="2-3-非相运算符：非字符串的比较"><a href="#2-3-非相运算符：非字符串的比较" class="headerlink" title="2.3 非相运算符：非字符串的比较"></a>2.3 非相运算符：非字符串的比较</h4><p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况</p>
<h5 id="2-3-1-原始类型值"><a href="#2-3-1-原始类型值" class="headerlink" title="2.3.1 原始类型值"></a>2.3.1 原始类型值</h5><p>如果两个运算子都是原始类型的值，则是先转成数值再比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> &gt; <span class="string">&#x27;4&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 5 &gt; Number(&#x27;4&#x27;)</span></span><br><span class="line"><span class="comment">// 即 5 &gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> &gt; <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(true) &gt; Number(false)</span></span><br><span class="line"><span class="comment">// 即 1 &gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &gt; <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 2 &gt; Number(true)</span></span><br><span class="line"><span class="comment">// 即 2 &gt; 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串和布尔值都会先转成数值，再进行比较</p>
<p>这里需要注意与<code>NaN</code>的比较。任何值（包括<code>NaN</code>本身）与<code>NaN</code>使用非相等运算符进行比较，返回的都是<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> &lt;= <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> &lt;= <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> &lt;= <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-对象"><a href="#2-3-2-对象" class="headerlink" title="2.3.2 对象"></a>2.3.2 对象</h5><p>如果运算子是对象，会转为原始类型的值，再进行比较。</p>
<p>对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">2</span>];</span><br><span class="line">x &gt; <span class="string">&#x27;11&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; &#x27;11&#x27;</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line">x.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> &#125;;</span><br><span class="line">x &gt; <span class="string">&#x27;11&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf() &gt; &#x27;11&#x27;</span></span><br><span class="line"><span class="comment">// 即 &#x27;1&#x27; &gt; &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>
<p>两个对象之间的比较也是如此</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>] &gt; [<span class="number">1</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>] &gt; [<span class="number">11</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">2</span> &#125; &gt;= &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 &#123; x: 2 &#125;.valueOf().toString() &gt;= &#123; x: 1 &#125;.valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;[object Object]&#x27; &gt;= &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-严格相当运算符"><a href="#2-4-严格相当运算符" class="headerlink" title="2.4 严格相当运算符"></a>2.4 严格相当运算符</h4><p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p>
<p>简单说，它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较</p>
<h5 id="2-4-1-不同类型的值"><a href="#2-4-1-不同类型的值" class="headerlink" title="2.4.1 不同类型的值"></a>2.4.1 不同类型的值</h5><p>如果两个值的类型不同，直接返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="string">&quot;1&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> === <span class="string">&quot;true&quot;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码比较数值的<code>1</code>与字符串的“<code>1</code>”、布尔值的<code>true</code>与字符串”<code>true</code>“，因为类型不同，结果都是<code>false</code></p>
<h5 id="2-4-2-同一类型的原始类型值"><a href="#2-4-2-同一类型的原始类型值" class="headerlink" title="2.4.2 同一类型的原始类型值"></a>2.4.2 同一类型的原始类型值</h5><p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code>true</code>，值不同就返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">0x1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码比较十进制的<code>1</code>与十六进制的<code>1</code>，因为类型和值都相同，返回<code>true</code>。</p>
<p>需要注意的是，<code>NaN</code>与任何值都不相等（包括自身）。另外，正<code>0</code>等于负<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="2-4-3-复合类型值"><a href="#2-4-3-复合类型值" class="headerlink" title="2.4.3 复合类型值"></a>2.4.3 复合类型值</h5><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; === &#123;&#125; <span class="comment">// false</span></span><br><span class="line">[] === [] <span class="comment">// false</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; === <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code>false</code><br>如果两个变量引用同一个对象，则它们相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> v2 = v1;</span><br><span class="line">v1 === v2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1 &gt; obj2 <span class="comment">// false</span></span><br><span class="line">obj1 &lt; obj2 <span class="comment">// false</span></span><br><span class="line">obj1 === obj2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回<code>false</code></p>
<h5 id="2-4-4-undefined和null"><a href="#2-4-4-undefined和null" class="headerlink" title="2.4.4 undefined和null"></a>2.4.4 undefined和null</h5><p><code>undefined</code>和<code>null</code>与自身严格相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>由于变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1;</span><br><span class="line"><span class="keyword">var</span> v2;</span><br><span class="line">v1 === v2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-严格不相等运算符"><a href="#2-5-严格不相等运算符" class="headerlink" title="2.5 严格不相等运算符"></a>2.5 严格不相等运算符</h4><p>严格相等运算符有一个对应的“严格不相等运算符”（<code>!==</code>），它的算法就是先求严格相等运算符的结果，然后返回相反值…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> !== <span class="string">&#x27;1&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">!(<span class="number">1</span> === <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-6-相等运算符"><a href="#2-6-相等运算符" class="headerlink" title="2.6 相等运算符"></a>2.6 相等运算符</h4><p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1.0</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">1</span> === <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成几种情况，讨论不同类型的值互相比较的规则</p>
<h5 id="2-6-1-原始类型值"><a href="#2-6-1-原始类型值" class="headerlink" title="2.6.1 原始类型值"></a>2.6.1 原始类型值</h5><p>原始类型的值会转换成数值再进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 1 === Number(true)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 0 === Number(false)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 2 === Number(true)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 2 === Number(false)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;true&#x27;</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;true&#x27;) === Number(true)</span></span><br><span class="line"><span class="comment">// 等同于 NaN === 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === 0</span></span><br><span class="line"><span class="comment">// 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === Number(false)</span></span><br><span class="line"><span class="comment">// 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;1&#x27;) === Number(true)</span></span><br><span class="line"><span class="comment">// 等同于 1 === 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\n  123  \t&#x27;</span> == <span class="number">123</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 因为字符串转为数字时，省略前置和后置的空格</span></span><br></pre></td></tr></table></figure>
<h5 id="2-6-2-对象与原始类型值比较"><a href="#2-6-2-对象与原始类型值比较" class="headerlink" title="2.6.2 对象与原始类型值比较"></a>2.6.2 对象与原始类型值比较</h5><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较<br>具体来说，先调用对象的<code>valueOf()</code>方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用<code>toString()</code>方法，得到字符串形式，再进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组与数值的比较</span></span><br><span class="line">[<span class="number">1</span>] == <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组与字符串的比较</span></span><br><span class="line">[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] == <span class="string">&#x27;1,2&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象与布尔值的比较</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">2</span>] == <span class="literal">true</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，JavaScript 引擎会先对数组<code>[1]</code>调用数组的<code>valueOf()</code>方法，由于返回的还是一个数组，所以会接着调用数组的<code>toString()</code>方法，得到字符串形式，再按照上一小节的规则进行比较<br>下面是一个更直接的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行 valueOf()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行 toString()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj == <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="comment">// 执行 valueOf()</span></span><br><span class="line"><span class="comment">// 执行 toString()</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>obj</code>是一个自定义了<code>valueOf()</code>和<code>toString()</code>方法的对象。这个对象与字符串<code>&#39;foo&#39;</code>进行比较时，会依次调用<code>valueOf()</code>和<code>toString()</code>方法，最后返回<code>&#39;foo&#39;</code>，所以比较结果是<code>true</code></p>
<h5 id="2-6-3-undefined和null"><a href="#2-6-3-undefined和null" class="headerlink" title="2.6.3 undefined和null"></a>2.6.3 undefined和null</h5><p><code>undefined</code>和<code>null</code>只有与自身比较，或者互相比较时，才会返回<code>true</code>；与其他类型的值比较时，结果都为<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="2-6-4-相等运算符的缺点"><a href="#2-6-4-相等运算符的缺点" class="headerlink" title="2.6.4 相等运算符的缺点"></a>2.6.4 相等运算符的缺点</h5><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>             <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span>            <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">false</span>          <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span>    <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span>        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; \t\r\n &#x27;</span> == <span class="number">0</span>     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（<code>==</code>），最好只使用严格相等运算符（<code>===</code>）</p>
<h4 id="2-7-不相等运算符"><a href="#2-7-不相等运算符" class="headerlink" title="2.7 不相等运算符"></a>2.7 不相等运算符</h4><p>相等运算符有一个对应的“不相等运算符”（<code>!=</code>），它的算法就是先求相等运算符的结果，然后返回相反值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> != <span class="string">&#x27;1&#x27;</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">!(<span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-比较运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0008</title>
    <url>/2021/05/09/%E6%89%93%E5%8D%A10008/</url>
    <content><![CDATA[<p><font color=red>宇宙洪荒，生命浩瀚，但是只有你和我，真正分享过心跳，时光流转，爱你不变。</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="3-布尔运算符"><a href="#3-布尔运算符" class="headerlink" title="3. 布尔运算符"></a>3. 布尔运算符</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符</p>
<ul>
<li>取反运算符：<code>!</code></li>
<li>且运算符：<code>&amp;&amp;</code></li>
<li>或运算符：<code>||</code></li>
<li>三元运算符：<code>?:</code><span id="more"></span>
<h4 id="3-2-取反运算符"><a href="#3-2-取反运算符" class="headerlink" title="3.2 取反运算符"></a>3.2 取反运算符</h4>取反运算符是一个感叹号，用于将布尔值变为相反值，即<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line">!<span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code>true</code>，其他值都为<code>false</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line">!<span class="string">&quot;&quot;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">54</span> <span class="comment">// false</span></span><br><span class="line">!<span class="string">&#x27;hello&#x27;</span> <span class="comment">// false</span></span><br><span class="line">![] <span class="comment">// false</span></span><br><span class="line">!&#123;&#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值</li>
</ul>
<p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同。这是一种常用的类型转换的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!x</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Boolean</span>(x)</span><br></pre></td></tr></table></figure>
<p>上面代码中，不管<code>x</code>是什么类型的值，经过两次取反运算后，变成了与<code>Boolean</code>函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法</p>
<h4 id="3-3-且运算符"><a href="#3-3-且运算符" class="headerlink" title="3.3 且运算符"></a>3.3 且运算符</h4><p>且运算符（<code>&amp;&amp;</code>）往往用于多个表达式的求值<br>它的运算规则是：如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; (<span class="number">1</span> + <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">(<span class="number">1</span> - <span class="number">1</span>) &amp;&amp; ( x += <span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code>false</code>，则直接返回它的值<code>0</code>，而不再对第二个运算子求值，所以变量x的值没变</p>
<p>这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段<code>if</code>结构的代码，就可以用且运算符改写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line">i &amp;&amp; doSomething();</span><br></pre></td></tr></table></figure>
<p>上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用</p>
<p>且运算符可以多个连用，这时返回第一个布尔值为<code>false</code>的表达式的值。如果所有表达式的布尔值都为<code>true</code>，则返回最后一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="literal">true</span></span><br><span class="line"><span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，例一里面，第一个布尔值为<code>false</code>的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是<code>true</code>，所以返回最后一个表达式的值<code>3</code></p>
<h4 id="3-4-或运算符"><a href="#3-4-或运算符" class="headerlink" title="3.4 或运算符"></a>3.4 或运算符</h4><p>或运算符（<code>||</code>）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为<code>true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code>false</code>，则返回第二个运算子的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t&#x27;</span> || <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;t&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> || <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;t&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>短路规则对这个运算符也适用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="literal">true</span> || (x = <span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，或运算符的第一个运算子为<code>true</code>，所以直接返回<code>true</code>，不再运行第二个运算子。所以，<code>x</code>的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）</p>
<p>或运算符可以多个连用，这时返回第一个布尔值为<code>true</code>的表达式的值。如果所有表达式都为<code>false</code>，则返回最后一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span> || <span class="number">0</span> || <span class="string">&#x27;&#x27;</span> || <span class="number">4</span> || <span class="string">&#x27;foo&#x27;</span> || <span class="literal">true</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> || <span class="number">0</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>或运算符常用于为一个变量设置默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  text = text || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line">saveText(<span class="built_in">this</span>.text || <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串</p>
<h4 id="3-5-三元条件运算符"><a href="#3-5-三元条件运算符" class="headerlink" title="3.5 三元条件运算符"></a>3.5 三元条件运算符</h4><p>三元条件运算符由问号（<code>?</code>）和冒号（<code>:</code>）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为<code>true</code>，则返回第二个表达式的值，否则返回第三个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t&#x27;</span> ? <span class="string">&#x27;hello&#x27;</span> : <span class="string">&#x27;world&#x27;</span> <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="number">0</span> ? <span class="string">&#x27;hello&#x27;</span> : <span class="string">&#x27;world&#x27;</span> <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>通常来说，三元条件表达式与<code>if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code>if..else</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> ? <span class="string">&#x27;T&#x27;</span> : <span class="string">&#x27;F&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>console.log</code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用<code>if...else</code>语句，就必须改变整个代码写法了</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-布尔运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0009</title>
    <url>/2021/05/09/%E6%89%93%E5%8D%A10009/</url>
    <content><![CDATA[<p><font color=#b2d235>人生越是艰难处，越要往前多走几步</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="4-二进制位运算符"><a href="#4-二进制位运算符" class="headerlink" title="4. 二进制位运算符"></a>4. 二进制位运算符</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>二进制位运算符用于直接对二进制位进行计算，一共有7个</p>
<ul>
<li>二进制或运算符（or）：符号为<code>|</code>，表示若两个二进制位都为<code>0</code>，则结果为<code>0</code>，否则为<code>1</code>。</li>
<li>二进制与运算符（and）：符号为<code>&amp;</code>，表示若两个二进制位都为<code>1</code>，则结果为<code>1</code>，否则为<code>0</code>。</li>
<li>二进制否运算符（not）：符号为<code>~</code>，表示对一个二进制位取反。</li>
<li>异或运算符（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为<code>1</code>，否则为<code>0</code>。</li>
<li>左移运算符（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。</li>
<li>右移运算符（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。</li>
<li>头部补零的右移运算符（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。<span id="more"></span></li>
</ul>
<p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错</p>
<p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">i = i | <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>上面这行代码的意思，就是将<code>i</code>（不管是整数或小数）转为32位整数<br>利用这个特性，可以写出一个函数，将任意数值转为32位整数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toInt32</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x | <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数将任意值与0进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">toInt32(<span class="number">1.001</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(<span class="number">1.999</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(-<span class="number">1</span>) <span class="comment">// -1</span></span><br><span class="line">toInt32(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) + <span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">toInt32(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toInt32</code>可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去</p>
<h4 id="4-2-二进制或运算符"><a href="#4-2-二进制或运算符" class="headerlink" title="4.2 二进制或运算符"></a>4.2 二进制或运算符</h4><p>二进制或运算符（<code>|</code>）逐位比较两个运算子，两个二进制位之中只要有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>和<code>3</code>的二进制形式分别是<code>00</code>和<code>11</code>，所以进行二进制或运算会得到<code>11</code>（即<code>3</code>）</p>
<p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与<code>0</code>进行二进制或运算，等同于对该数去除小数部分，即取整数位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2.9</span> | <span class="number">0</span> <span class="comment">// 2</span></span><br><span class="line">-<span class="number">2.9</span> | <span class="number">0</span> <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，这种取整方法不适用超过32位整数最大值<code>2147483647</code>的数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2147483649.4</span> | <span class="number">0</span>;</span><br><span class="line"><span class="comment">// -2147483647</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-二进制与运算符"><a href="#4-3-二进制与运算符" class="headerlink" title="4.3 二进制与运算符"></a>4.3 二进制与运算符</h4><p>二进制与运算符（<code>&amp;</code>）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为<code>0</code>，就返回<code>0</code>，否则返回<code>1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">3</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>（二进制<code>00</code>）和<code>3</code>（二进制<code>11</code>）进行二进制与运算会得到<code>00</code>（即<code>0</code>）</p>
<h4 id="4-4-二进制否运算符"><a href="#4-4-二进制否运算符" class="headerlink" title="4.4 二进制否运算符"></a>4.4 二进制否运算符</h4><p>二进制否运算符（<code>~</code>）将每个二进制位都变为相反值（<code>0</code>变为<code>1</code>，<code>1</code>变为<code>0</code>）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~ <span class="number">3</span> <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>
<p>上面表达式对<code>3</code>进行二进制否运算，得到<code>-4</code>。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算<br><code>3</code>的32位整数形式是<code>00000000000000000000000000000011</code>，二进制否运算以后得到<code>11111111111111111111111111111100</code>。由于第一位（符号位）是<code>1</code>，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去<code>1</code>，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去<code>1</code>等于<code>11111111111111111111111111111011</code>，再取一次反得到<code>00000000000000000000000000000100</code>，再加上负号就是<code>-4</code>。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~ -<span class="number">3</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面表达式可以这样算，<code>-3</code>的取反值等于<code>-1</code>减去<code>-3</code>，结果为<code>2</code><br>对一个整数连续两次二进制否运算，得到它自身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~<span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~<span class="number">2.9</span> <span class="comment">// 2</span></span><br><span class="line">~~<span class="number">47.11</span> <span class="comment">// 47</span></span><br><span class="line">~~<span class="number">1.9999</span> <span class="comment">// 1</span></span><br><span class="line">~~<span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>使用二进制否运算取整，是所有取整方法中最快的一种</p>
<p>对字符串进行二进制否运算，JavaScript 引擎会先调用<code>Number</code>函数，将字符串转为数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于~Number(&#x27;011&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;011&#x27;</span>  <span class="comment">// -12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于~Number(&#x27;42 cats&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;42 cats&#x27;</span> <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于~Number(&#x27;0xcafebabe&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;0xcafebabe&#x27;</span> <span class="comment">// 889275713</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于~Number(&#x27;deadbeef&#x27;)</span></span><br><span class="line">~<span class="string">&#x27;deadbeef&#x27;</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>对于其他类型的值，二进制否运算也是先用<code>Number</code>转为数值，然后再进行处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 ~Number([])</span></span><br><span class="line">~[] <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 ~Number(NaN)</span></span><br><span class="line">~<span class="literal">NaN</span> <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 ~Number(null)</span></span><br><span class="line">~<span class="literal">null</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-异或运算符"><a href="#4-5-异或运算符" class="headerlink" title="4.5 异或运算符"></a>4.5 异或运算符</h4><p>异或运算（<code>^</code>）在两个二进制位不同时返回<code>1</code>，相同时返回<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面表达式中，<code>0</code>（二进制<code>00</code>）与<code>3</code>（二进制<code>11</code>）进行异或运算，它们每一个二进制位都不同，所以得到<code>11</code>（即<code>3</code>）</p>
<p>“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，<code>a^=b; b^=a; a^=b;</code>，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">a ^= b, b ^= a, a ^= b;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 99</span></span><br><span class="line">b <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>这是互换两个变量的值的最快方法<br>异或运算也可以用来取整</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">12.9</span> ^ <span class="number">0</span> <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h4 id="4-6-左移运算符"><a href="#4-6-左移运算符" class="headerlink" title="4.6 左移运算符"></a>4.6 左移运算符</h4><p>左移运算符（<code>&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补<code>0</code>，即乘以<code>2</code>的指定次方。向左移动的时候，最高位的符号位是一起移动的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4 的二进制形式为100，</span></span><br><span class="line"><span class="comment">// 左移一位为1000（即十进制的8）</span></span><br><span class="line"><span class="comment">// 相当于乘以2的1次方</span></span><br><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">-<span class="number">4</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">// -8</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>-4</code>左移一位得到<code>-8</code>，是因为<code>-4</code>的二进制形式是<code>11111111111111111111111111111100</code>，左移一位后得到<code>11111111111111111111111111111000</code>，该数转为十进制（减去<code>1</code>后取反，再加上负号）即为<code>-8</code><br>如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">13.5</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">-<span class="number">13.5</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="comment">// -13</span></span><br></pre></td></tr></table></figure>
<p>左移运算符用于二进制数值非常方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = &#123;<span class="attr">r</span>: <span class="number">186</span>, <span class="attr">g</span>: <span class="number">218</span>, <span class="attr">b</span>: <span class="number">85</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RGB to HEX</span></span><br><span class="line"><span class="comment">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span></span><br><span class="line"><span class="keyword">var</span> rgb2hex = <span class="function"><span class="keyword">function</span>(<span class="params">r, g, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + ((<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + (r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b)</span><br><span class="line">    .toString(<span class="number">16</span>) <span class="comment">// 先转成十六进制，然后返回字符串</span></span><br><span class="line">    .substr(<span class="number">1</span>);   <span class="comment">// 去除字符串的最高位，返回后面六个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rgb2hex(color.r, color.g, color.b)</span><br><span class="line"><span class="comment">// &quot;#bada55&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值</p>
<h4 id="4-7-右移运算符"><a href="#4-7-右移运算符" class="headerlink" title="4.7 右移运算符"></a>4.7 右移运算符</h4><p>右移运算符（<code>&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补<code>0</code>；如果是负数，头部全部补<code>1</code>。右移运算符基本上相当于除以<code>2</code>的指定次方（最高位即符号位参与移动）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 因为4的二进制形式为 00000000000000000000000000000100，</span></span><br><span class="line"><span class="comment">// 右移一位得到 00000000000000000000000000000010，</span></span><br><span class="line"><span class="comment">// 即为十进制的2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">-<span class="number">4</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// -2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 因为-4的二进制形式为 11111111111111111111111111111100，</span></span><br><span class="line"><span class="comment">// 右移一位，头部补1，得到 11111111111111111111111111111110,</span></span><br><span class="line"><span class="comment">// 即为十进制的-2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>右移运算可以模拟 <code>2</code> 的整除运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 相当于 5 / 2 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 相当于 21 / 4 = 5</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &gt;&gt; <span class="number">3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 相当于 21 / 8 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &gt;&gt; <span class="number">4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 相当于 21 / 16 = 1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-8-头部补零的右移运算符"><a href="#4-8-头部补零的右移运算符" class="headerlink" title="4.8 头部补零的右移运算符"></a>4.8 头部补零的右移运算符</h4><p>头部补零的右移运算符（<code>&gt;&gt;&gt;</code>）与右移运算符（<code>&gt;&gt;</code>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（<code>&gt;&gt;</code>）完全一致，区别主要在于负数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">-<span class="number">4</span> &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 2147483646</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 因为-4的二进制形式为11111111111111111111111111111100，</span></span><br><span class="line"><span class="comment">// 带符号位的右移一位，得到01111111111111111111111111111110，</span></span><br><span class="line"><span class="comment">// 即为十进制的2147483646。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这个运算实际上将一个值转为32位无符号整数<br>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span> &gt;&gt;&gt; <span class="number">0</span> <span class="comment">// 4294967295</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>-1</code>作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 <code>4294967295</code>（即<code>(2^32)-1</code>，等于<code>11111111111111111111111111111111</code>）</p>
<h4 id="4-9-开关作用"><a href="#4-9-开关作用" class="headerlink" title="4.9 开关作用"></a>4.9 开关作用</h4><p>位运算符可以用作设置对象属性的开关</p>
<p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FLAG_A = <span class="number">1</span>; <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">var</span> FLAG_B = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">var</span> FLAG_C = <span class="number">4</span>; <span class="comment">// 0100</span></span><br><span class="line"><span class="keyword">var</span> FLAG_D = <span class="number">8</span>; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位<br>然后，就可以用二进制与运算，检查当前设置是否打开了指定开关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flags = <span class="number">5</span>; <span class="comment">// 二进制的0101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FLAG_C) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>上面代码检验是否打开了开关<code>C</code>。如果打开，会返回<code>true</code>，否则返回<code>false</code><br>现在假设需要打开<code>A</code>、<code>B</code>、<code>D</code>三个开关，我们可以构造一个掩码变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D;</span><br><span class="line"><span class="comment">// 0001 | 0010 | 1000 =&gt; 1011</span></span><br></pre></td></tr></table></figure>
<p>上面代码对<code>A</code>、<code>B</code>、<code>D</code>三个变量进行二进制或运算，得到掩码值为二进制的<code>1011</code><br>有了掩码，二进制或运算可以确保打开指定的开关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags | mask;</span><br></pre></td></tr></table></figure>
<p>上面代码中，计算后得到的<code>flags</code>变量，代表三个开关的二进制位都打开了<br>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags &amp; mask;</span><br></pre></td></tr></table></figure>
<p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags ^ mask;</span><br></pre></td></tr></table></figure>
<p>二进制否运算可以翻转当前设置，即原设置为<code>0</code>，运算后变为<code>1</code>；原设置为<code>1</code>，运算后变为<code>0</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = ~flags;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-二进制位运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0010</title>
    <url>/2021/05/09/%E6%89%93%E5%8D%A10010/</url>
    <content><![CDATA[<p><font color=#33a3dc>风吹又日晒，自由又自在</font></p>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h3 id="5-其它运算符，运算顺序"><a href="#5-其它运算符，运算顺序" class="headerlink" title="5. 其它运算符，运算顺序"></a>5. 其它运算符，运算顺序</h3><h4 id="5-1-void运算符"><a href="#5-1-void运算符" class="headerlink" title="5.1 void运算符"></a>5.1 void运算符</h4><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span>(<span class="number">0</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面是<code>void</code>运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为<code>void</code>运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，<code>void 4 + 7</code>实际上等同于<code>(void 4) + 7</code></p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">void</span> (x = <span class="number">5</span>) <span class="comment">//undefined</span></span><br><span class="line">x <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;http://example.com&quot;</span> onclick=<span class="string">&quot;f(); return false;&quot;</span>&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 example.com<br>void运算符可以取代上面的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(f())&quot;</span>&gt;文字&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(document.form.submit())&quot;</span>&gt;</span><br><span class="line">  提交</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-逗号运算符"><a href="#5-2-逗号运算符" class="headerlink" title="5.2 逗号运算符"></a>5.2 逗号运算符</h4><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> <span class="comment">// &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = (x++, <span class="number">10</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = (<span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"></span><br><span class="line">value <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值</p>
<h4 id="5-3-运算顺序"><a href="#5-3-运算顺序" class="headerlink" title="5.3 运算顺序"></a>5.3 运算顺序</h4><h5 id="5-3-1-优先级"><a href="#5-3-1-优先级" class="headerlink" title="5.3.1 优先级"></a>5.3.1 优先级</h5><p>JavaScript 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> + <span class="number">5</span> * <span class="number">6</span> <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，乘法运算符（<code>*</code>）的优先性高于加法运算符（<code>+</code>），所以先执行乘法，再执行加法，相当于下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> + (<span class="number">5</span> * <span class="number">6</span>) <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>
<p>如果多个运算符混写在一起，常常会导致令人困惑的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = arr.length &lt;= <span class="number">0</span> || arr[<span class="number">0</span>] === <span class="literal">undefined</span> ? x : arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>y</code>的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住</p>
<p>根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（<code>&lt;=</code>)、严格相等（<code>===</code>）、或（<code>||</code>）、三元（<code>?:</code>）、等号（<code>=</code>）。因此上面的表达式，实际的运算顺序如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = ((arr.length &lt;= <span class="number">0</span>) || (arr[<span class="number">0</span>] === <span class="literal">undefined</span>)) ? x : arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>记住所有运算符的优先级，是非常难的，也是没有必要的</p>
<h5 id="5-3-2-圆括号的作用"><a href="#5-3-2-圆括号的作用" class="headerlink" title="5.3.2 圆括号的作用"></a>5.3.2 圆括号的作用</h5><p>圆括号<code>（）</code>可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span> + <span class="number">5</span>) * <span class="number">6</span> <span class="comment">// 54</span></span><br></pre></td></tr></table></figure>
<p>圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数<br>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">(x) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成<code>1 = 2</code>，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值<br>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(expression)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">expression</span><br></pre></td></tr></table></figure>

<p>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(f) <span class="comment">// function f()&#123;return 1;&#125;</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">var</span> a = <span class="number">1</span>)</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-左结合与右结合"><a href="#5-3-3-左结合与右结合" class="headerlink" title="5.3.3 左结合与右结合"></a>5.3.3 左结合与右结合</h5><p>JavaScript 语言的大多数运算符是“左结合”，请看下面加法运算符的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x + y + z</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引擎解释如下</span></span><br><span class="line">(x + y) + z</span><br></pre></td></tr></table></figure>

<p>少数运算符是“右结合”，其中最主要的是赋值运算符（<code>=</code>）和三元条件运算符（<code>?:</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w = x = y = z;</span><br><span class="line">q = a ? b : c ? d : e ? f : g;</span><br></pre></td></tr></table></figure>
<p>上面代码的解释方式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w = (x = (y = z));</span><br><span class="line">q = a ? b : (c ? d : (e ? f : g));</span><br></pre></td></tr></table></figure>
<p>上面的两行代码，都是右侧的运算数结合在一起。</p>
<p>另外，指数运算符（<code>**</code>）也是右结合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>


<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS运算符-其它运算符，运算顺序</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0011</title>
    <url>/2021/05/10/%E6%89%93%E5%8D%A10011/</url>
    <content><![CDATA[<p><font color=#BDB76B>花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草。</p>
<p>墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。</font></p>
<h2 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h2><h3 id="1-数据类型的转换"><a href="#1-数据类型的转换" class="headerlink" title="1. 数据类型的转换"></a>1. 数据类型的转换</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = y ? <span class="number">1</span> : <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中，变量x到底是数值还是字符串，取决于另一个变量<code>y</code>的值。<code>y</code>为<code>true</code>时，<code>x</code>是一个数值；<code>y</code>为<code>false</code>时，<code>x</code>是一个字符串。这意味着，<code>x</code>的类型没法在编译阶段就知道，必须等到运行时才能知道<br>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;4&#x27;</span> - <span class="string">&#x27;3&#x27;</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，虽然是两个字符串相减，但是依然会得到结果数值<code>1</code>，原因就在于 JavaScript 将运算子自动转为了数值</p>
<h4 id="1-2-强制转换"><a href="#1-2-强制转换" class="headerlink" title="1.2 强制转换"></a>1.2 强制转换</h4><p>强制转换主要指使用<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值</p>
<h5 id="1-2-1-Number"><a href="#1-2-1-Number" class="headerlink" title="1.2.1 Number()"></a>1.2.1 Number()</h5><p>使用<code>Number</code>函数，可以将任意类型的值转化成数值。<br>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象</p>
<h6 id="1-原始值类型"><a href="#1-原始值类型" class="headerlink" title="(1)原始值类型"></a>(1)原始值类型</h6><p>原始类型值的转换规则如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数值：转换后还是原来的值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;42 cats&#x27;</span>) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;42 cats&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型<br>另外，<code>parseInt</code>和<code>Number</code>函数都会自动过滤一个字符串前导和后缀的空格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure>
<h6 id="2-对象"><a href="#2-对象" class="headerlink" title="(2)对象"></a>(2)对象</h6><p>简单的规则是，<code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>之所以会这样，是因为<code>Number</code>背后的转换规则比较复杂<br>第一步，调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤<br>第二步，如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用<code>Number</code>函数，不再进行后续步骤<br>第三步，如果<code>toString</code>方法返回的是对象，就报错<br>请看下面的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Number</span>(obj) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj.valueOf() === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">Number</span>(obj.toString());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">Number</span>(obj.valueOf());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Number</code>函数将<code>obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code>obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code>obj.toString</code>方法，这时返回字符串<code>[object Object]</code>，对这个字符串使用<code>Number</code>函数，得到<code>NaN</code><br>默认情况下，对象的<code>valueOf</code>方法返回对象本身，所以一般总是会调用<code>toString</code>方法，而<code>toString</code>方法返回对象的类型字符串（比如<code>[object Object]</code>）。所以，会有下面的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>如果<code>toString</code>方法返回的不是原始类型的值，结果就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(obj)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>valueOf</code>和<code>toString</code>方法，返回的都是对象，所以转成数值时会报错<br>从上例还可以看到，<code>valueOf</code>和<code>toString</code>方法，都是可以自定义的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码对三个对象使用<code>Number</code>函数。第一个对象返回<code>valueOf</code>方法的值，第二个对象返回<code>toString</code>方法的值，第三个对象表示<code>valueOf</code>方法先于<code>toString</code>方法执行</p>
<h5 id="1-2-2-String"><a href="#1-2-2-String" class="headerlink" title="1.2.2 String()"></a>1.2.2 String()</h5><p><code>String</code>函数可以将任意类型的值转化成字符串，转换规则如下</p>
<h6 id="1-原始类型值"><a href="#1-原始类型值" class="headerlink" title="(1)原始类型值"></a>(1)原始类型值</h6><ul>
<li>数值：转为相应的字符串。</li>
<li>字符串：转换后还是原来的值。</li>
<li>布尔值：<code>true</code>转为字符串<code>&quot;true&quot;</code>，<code>false</code>转为字符串<code>&quot;false&quot;</code>。</li>
<li>undefined：转为字符串<code>&quot;undefined&quot;</code>。</li>
<li>null：转为字符串<code>&quot;null&quot;</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="2-对象-1"><a href="#2-对象-1" class="headerlink" title="(2)对象"></a>(2)对象</h6><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>
<code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序</li>
</ul>
<ol>
<li>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>valueOf</code>方法返回的是对象，就报错。<br>下面是一个列子:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;.toString())</span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
上面代码先调用对象的<code>toString</code>方法，发现返回的是字符串<code>[object Object]</code>，就不再调用<code>valueOf</code>方法了<br>如果<code>toString</code>法和<code>valueOf</code>方法，返回的都是对象，就会报错<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(obj)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
下面是通过自定义<code>toString</code>方法，改变返回值的例子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>
上面代码对三个对象使用<code>String</code>函数。第一个对象返回<code>toString</code>方法的值（数值<code>3</code>），第二个对象返回的还是<code>toString</code>方法的值（<code>[object Object]</code>），第三个对象表示<code>toString</code>方法先于<code>valueOf</code>方法执行</li>
</ol>
<h5 id="1-2-3-Boolean"><a href="#1-2-3-Boolean" class="headerlink" title="1.2.3 Boolean()"></a>1.2.3 Boolean()</h5><p><code>Boolean()</code>函数可以将任意类型的值转为布尔值<br>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code></p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0（包含-0和+0）</li>
<li>NaN</li>
<li>‘’（空字符串）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
当然，<code>true</code>和<code>false</code>这两个布尔值不会发生变化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">false</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
注意，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>（详见《原始类型值的包装对象》一章）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
所有对象的布尔值都是<code>true</code>，这是因为 JavaScript语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于<code>obj1 &amp;&amp; obj2</code>这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为<code>true</code></li>
</ul>
<h4 id="1-3-自动转换"><a href="#1-3-自动转换" class="headerlink" title="1.3 自动转换"></a>1.3 自动转换</h4><p>自动转换，它是以强制转换为基础的。<br>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。<br>第一种情况，不同类型的数据互相运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">&#x27;abc&#x27;</span> <span class="comment">// &quot;123abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>第二种情况，对非布尔值类型的数据求布尔值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;  <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>第三种情况，对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125; <span class="comment">// NaN</span></span><br><span class="line">- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用<code>String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值<br>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>函数进行显式转换</p>
<h5 id="1-3-1-自动转换为布尔值"><a href="#1-3-1-自动转换为布尔值" class="headerlink" title="1.3.1 自动转换为布尔值"></a>1.3.1 自动转换为布尔值</h5><p>JavaScript遇到预期为布尔值的地方（比如<code>if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code>Boolean()</code>函数<br>因此除了以下五个值，其他都是自动转为<code>true</code></p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>+0</code>或<code>-0</code></li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）<br>下面这个例子中，条件部分的每个值都相当于<code>false</code>，使用否定运算符后，就变成了<code>true</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="literal">undefined</span></span><br><span class="line">  &amp;&amp; !<span class="literal">null</span></span><br><span class="line">  &amp;&amp; !<span class="number">0</span></span><br><span class="line">  &amp;&amp; !<span class="literal">NaN</span></span><br><span class="line">  &amp;&amp; !<span class="string">&#x27;&#x27;</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是<code>Boolean()</code>函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">expression ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">!! expression</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-自动转换为字符串"><a href="#1-3-2-自动转换为字符串" class="headerlink" title="1.3.2 自动转换为字符串"></a>1.3.2 自动转换为字符串</h5>JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串<br>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure>
这种自动转换很容易出错，例如<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  width: <span class="string">&#x27;100&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.width + <span class="number">20</span> <span class="comment">// &quot;10020&quot;</span></span><br></pre></td></tr></table></figure>
上面代码中，开发者可能期望返回<code>120</code>，但是由于自动转换，实际上返回了一个字符<code>10020</code></li>
</ul>
<h5 id="1-3-3-自动转换为数值"><a href="#1-3-3-自动转换为数值" class="headerlink" title="1.3.3 自动转换为数值"></a>1.3.3 自动转换为数值</h5><p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code>Number()</code>函数<br>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，运算符两侧的运算子，都被转成了数值<br><code>注意：`null`转为数值时为`0`，而`undefined`转为数值时为`NaN`</code><br>一元运算符也会把运算子转成数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS语法-数据类型的转换</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡0004</title>
    <url>/2021/05/06/%E6%89%93%E5%8D%A10004/</url>
    <content><![CDATA[<p><font color=#45b97c>愿每个人都能收获相处舒服的关系，既能保持分寸，又不会疏离；既能守住底线，又不至于单薄；可以各自忙碌，又彼此牵挂、惦记，简单又纯粹。</font></p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><h5 id="5-1-1-函数的声明"><a href="#5-1-1-函数的声明" class="headerlink" title="5.1.1 函数的声明"></a>5.1.1 函数的声明</h5><p>JavaScript 有三种声明函数的方法</p>
<span id="more"></span>
<ol>
<li><p>function命令<br><code>function</code>命令声明的代码区块，就是一个函数。<code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式<br>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式<br>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的</p>
</li>
<li><p>Function 构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;return x + y&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数,Function构造函数可以不使用new命令，返回结果完全一样。</p>
</li>
</ol>
<p>总的来说，这种声明函数的方式非常不直观，几乎无人使用</p>
<h5 id="5-1-2-函数的重复声明"><a href="#5-1-2-函数的重复声明" class="headerlink" title="5.1.2 函数的重复声明"></a>5.1.2 函数的重复声明</h5><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升，第一次声明在任何时候都是无效的</p>
<h5 id="5-1-3-圆括号运算符，return语句和递归"><a href="#5-1-3-圆括号运算符，return语句和递归" class="headerlink" title="5.1.3 圆括号运算符，return语句和递归"></a>5.1.3 圆括号运算符，return语句和递归</h5><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行<br>也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code></p>
<p>函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fib(num - <span class="number">2</span>) + fib(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(<span class="number">6</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h5 id="5-1-4-第一等公民"><a href="#5-1-4-第一等公民" class="headerlink" title="5.1.4 第一等公民"></a>5.1.4 第一等公民</h5><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数<br>比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处<br>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> operator = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数作为参数和返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">op</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line">a(add)(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h5 id="5-1-5函数名的提升"><a href="#5-1-5函数名的提升" class="headerlink" title="5.1.5函数名的提升"></a>5.1.5函数名的提升</h5><p>avaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了<br>但是，如果采用赋值语句定义函数，JavaScript 就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">var</span> f;</span><br><span class="line">f();</span><br><span class="line">f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错</p>
<p>如果像下面例子这样，采用function命令和var赋值语句声明同一个函数，由于存在函数提升，最后会采用var赋值语句的定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，表面上后面声明的函数f，应该覆盖前面的var赋值语句，但是由于存在函数提升，实际上正好反过来</p>
<h4 id="5-2函数的属性和方法"><a href="#5-2函数的属性和方法" class="headerlink" title="5.2函数的属性和方法"></a>5.2函数的属性和方法</h4><h5 id="5-2-1-name属性"><a href="#5-2-1-name属性" class="headerlink" title="5.2.1 name属性"></a>5.2.1 name属性</h5><p>函数的name属性返回函数的名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f1.name <span class="comment">// &quot;f1&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果是通过变量赋值定义的函数，那么name属性返回变量名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f2.name <span class="comment">// &quot;f2&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f3.name <span class="comment">// &#x27;myName&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是f3，而<code>myName</code>这个名字只在函数体内部可用</p>
<p><code>name</code>属性的一个用处，就是获取参数函数的名字，下面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) <span class="comment">// myFunc</span></span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-length属性"><a href="#5-2-2-length属性" class="headerlink" title="5.2.2 length属性"></a>5.2.2 length属性</h5><p>函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line">f.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）</p>
<h5 id="5-2-3-toString"><a href="#5-2-3-toString" class="headerlink" title="5.2.3 toString()"></a>5.2.3 toString()</h5><p>函数的toString()方法返回一个字符串，内容是函数的源码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt.toString()</span><br><span class="line"><span class="comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数内部的注释也可以返回，利用这一点，可以变相实现多行字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = fn.toString().split(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr.slice(<span class="number">1</span>, arr.length - <span class="number">1</span>).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">multiline(f);</span><br><span class="line"><span class="comment">// &quot; 这是一个</span></span><br><span class="line"><span class="comment">//   多行注释&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面示例中，函数f内部有一个多行注释，toString()方法拿到f的源码后，去掉首尾两行，就得到了一个多行字符串</p>
<h4 id="5-3函数的作用域"><a href="#5-3函数的作用域" class="headerlink" title="5.3函数的作用域"></a>5.3函数的作用域</h4><h5 id="5-3-1定义"><a href="#5-3-1定义" class="headerlink" title="5.3.1定义"></a>5.3.1定义</h5><p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，后面再写<br>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v <span class="comment">// ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure>

<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line">v <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取</p>
<h5 id="5-3-2-函数内部的变量提升"><a href="#5-3-2-函数内部的变量提升" class="headerlink" title="5.3.2 函数内部的变量提升"></a>5.3.2 函数内部的变量提升</h5><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-函数本身的作用域"><a href="#5-3-3-函数本身的作用域" class="headerlink" title="5.3.3 函数本身的作用域"></a>5.3.3 函数本身的作用域</h5><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code><br>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域<br>很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y(x)</span><br><span class="line"><span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错<br>同样的，函数体内部声明的函数，作用域绑定函数体内部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了“闭包”现象</p>
<h4 id="5-4-参数"><a href="#5-4-参数" class="headerlink" title="5.4 参数"></a>5.4 参数</h4><h5 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h5><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">square(<span class="number">3</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果</p>
<h5 id="5-4-2-参数的省略"><a href="#5-4-2-参数的省略" class="headerlink" title="5.4.2 参数的省略"></a>5.4.2 参数的省略</h5><p>函数参数不是必需的，JavaScript 允许省略参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 1</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">f.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数,如果省略第一个参数，就会报错。如果一定要省略靠前的参数，只有显式传入<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f( , <span class="number">1</span>) <span class="comment">// SyntaxError: Unexpected token ,(…)</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-传递方式"><a href="#5-4-3-传递方式" class="headerlink" title="5.4.3 传递方式"></a>5.4.3 传递方式</h5><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line">p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.p = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址。因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，在函数<code>f()</code>内部，参数对象<code>obj</code>被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响</p>
<h5 id="5-4-4-同名参数"><a href="#5-4-4-同名参数" class="headerlink" title="5.4.4 同名参数"></a>5.4.4 同名参数</h5><p>如果有同名的参数，则取最后出现的那个值，即使后面的<code>a</code>没有值或被省略，也是以其为准</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>如果要获得第一个a的值，可以使用arguments对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h5 id="5-4-5-arguments对象"><a href="#5-4-5-arguments对象" class="headerlink" title="5.4.5 arguments对象"></a>5.4.5 arguments对象</h5><h6 id="5-4-5-1-定义"><a href="#5-4-5-1-定义" class="headerlink" title="5.4.5.1 定义"></a>5.4.5.1 定义</h6><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来<br><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">one</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>正常模式下，<code>arguments</code>对象可以在运行时修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>; <span class="comment">// 开启严格模式</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h6 id="5-4-5-2-与数组的关系"><a href="#5-4-5-2-与数组的关系" class="headerlink" title="5.4.5.2 与数组的关系"></a>5.4.5.2 与数组的关系</h6><p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5-4-5-3-callee属性"><a href="#5-4-5-3-callee属性" class="headerlink" title="5.4.5.3 callee属性"></a>5.4.5.3 callee属性</h6><p>arguments对象带有一个callee属性，返回它所对应的原函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用</p>
<h4 id="5-5-函数的其它知识点"><a href="#5-5-函数的其它知识点" class="headerlink" title="5.5 函数的其它知识点"></a>5.5 函数的其它知识点</h4><h5 id="5-5-1-闭包"><a href="#5-5-1-闭包" class="headerlink" title="5.5.1 闭包"></a>5.5.1 闭包</h5><p>闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现<br>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。<br>函数内部可以直接读取全局变量，但是，正常情况下，函数外部无法读取函数内部声明的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined(</span></span><br></pre></td></tr></table></figure>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立<br>既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了</p>
<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口</p>
<p>为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge和setAge</code>，变成了返回对象<code>p1</code>的私有变量<br>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题</p>
<h5 id="5-5-2-立即调用的函数表达式（IIFE）"><a href="#5-5-2-立即调用的函数表达式（IIFE）" class="headerlink" title="5.5.2 立即调用的函数表达式（IIFE）"></a>5.5.2 立即调用的函数表达式（IIFE）</h5><p>根据 JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print</code>函数<br>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure>
<p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当作表达式时，函数可以定义后直接加圆括号调用，原因就是<code>function</code>作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>&#125;();</span><br><span class="line">f <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了</p>
<p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个<code>IIFE</code>，可能就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br></pre></td></tr></table></figure>
<p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数</p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>甚至像下面这样写，也是可以的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量</p>
<h4 id="5-6-eval命令"><a href="#5-6-eval命令" class="headerlink" title="5.6 eval命令"></a>5.6 eval命令</h4><h5 id="5-6-1-基本用法"><a href="#5-6-1-基本用法" class="headerlink" title="5.6.1 基本用法"></a>5.6.1 基本用法</h5><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var a = 1;&#x27;</span>);</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果参数字符串无法当作语句运行，那么就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3x&#x27;</span>) <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;return;&#x27;</span>); <span class="comment">// Uncaught SyntaxError: Illegal return statement</span></span><br></pre></td></tr></table></figure>
<p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用</p>
<p>如果<code>eval</code>的参数不是字符串，那么会原样返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a = 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>为了防止这种风险，JavaScript规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;var foo = 123&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(foo);  <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部</p>
<p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;foo = 2&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(foo);  <span class="comment">// 2</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在</p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 <code>JSON</code> 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法</p>
<h5 id="5-6-2-eval的别名调用"><a href="#5-6-2-eval的别名调用" class="headerlink" title="5.6.2 eval的别名调用"></a>5.6.2 eval的别名调用</h5><p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">eval</span>;</span><br><span class="line">m(<span class="string">&#x27;var x = 1&#x27;</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令</p>
<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="built_in">eval</span>;</span><br><span class="line">  e(<span class="string">&#x27;console.log(a)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉</p>
<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>.call(<span class="literal">null</span>, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"><span class="built_in">window</span>.eval(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="built_in">eval</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面这些形式都是eval的别名调用，作用域都是全局作用域</p>
<p><code>well,that&#39;s all for today.</code></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS数据类型-函数</tag>
      </tags>
  </entry>
</search>
