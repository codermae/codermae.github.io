<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maeBlog</title>
  
  
  <link href="https://codermae.github.io/atom.xml" rel="self"/>
  
  <link href="https://codermae.github.io/"/>
  <updated>2021-06-01T03:04:13.186Z</updated>
  <id>https://codermae.github.io/</id>
  
  <author>
    <name>Ye Ma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>打卡0060</title>
    <link href="https://codermae.github.io/2021/06/01/%E6%89%93%E5%8D%A10060/"/>
    <id>https://codermae.github.io/2021/06/01/%E6%89%93%E5%8D%A10060/</id>
    <published>2021-06-01T02:19:57.000Z</published>
    <updated>2021-06-01T03:04:13.186Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#009ad6&gt;每个人的一生都是上帝手写的童话。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-浏览器模型&quot;&gt;&lt;a href=&quot;#JS-浏览器模型&quot; class=&quot;headerlink&quot; title=&quot;JS 浏览器模型&quot;&gt;&lt;/a&gt;JS 浏览器模型&lt;/h2&gt;&lt;h3 id=&quot;6-同源限制&quot;&gt;&lt;a href=&quot;#6-同源限制&quot; class=&quot;headerlink&quot; title=&quot;6.同源限制&quot;&gt;&lt;/a&gt;6.同源限制&lt;/h3&gt;&lt;p&gt;浏览器安全的基石是“同源政策”（&lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt; ）。很多开发者都知道这一点，但了解得不全面。&lt;/p&gt;
&lt;h4 id=&quot;6-1-概述&quot;&gt;&lt;a href=&quot;#6-1-概述&quot; class=&quot;headerlink&quot; title=&quot;6.1 概述&quot;&gt;&lt;/a&gt;6.1 概述&lt;/h4&gt;&lt;h5 id=&quot;6-1-1-含义&quot;&gt;&lt;a href=&quot;#6-1-1-含义&quot; class=&quot;headerlink&quot; title=&quot;6.1.1 含义&quot;&gt;&lt;/a&gt;6.1.1 含义&lt;/h5&gt;&lt;p&gt;1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。&lt;/p&gt;
&lt;p&gt;最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。&lt;br&gt;`&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议相同&lt;/li&gt;
&lt;li&gt;域名相同&lt;/li&gt;
&lt;li&gt;端口相同（这点可以忽略，详见下文）&lt;br&gt;`&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例来说，&lt;code&gt;http://www.example.com/dir/page.html&lt;/code&gt;这个网址，协议是&lt;code&gt;http://&lt;/code&gt;，域名是&lt;code&gt;www.example.com&lt;/code&gt;，端口是&lt;code&gt;80&lt;/code&gt;（默认端口可以省略），它的同源情况如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://www.example.com/dir2/other.html&lt;/code&gt;：同源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://example.com/dir/other.html&lt;/code&gt;：不同源（域名不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://v2.www.example.com/dir/other.html&lt;/code&gt;：不同源（域名不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://www.example.com:81/dir/other.html&lt;/code&gt;：不同源（端口不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;https://www.example.com/dir/page.html&lt;/code&gt;：不同源（协议不同）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，标准规定端口不同的网址不是同源（比如&lt;code&gt;8000&lt;/code&gt;端口和&lt;code&gt;8001&lt;/code&gt;端口不是同源），但是浏览器没有遵守这条规定。实际上，同一个网域的不同端口，是可以互相读取 Cookie 的。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 浏览器模型-同源限制" scheme="https://codermae.github.io/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B-%E5%90%8C%E6%BA%90%E9%99%90%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0059</title>
    <link href="https://codermae.github.io/2021/06/01/%E6%89%93%E5%8D%A10059/"/>
    <id>https://codermae.github.io/2021/06/01/%E6%89%93%E5%8D%A10059/</id>
    <published>2021-06-01T00:58:43.000Z</published>
    <updated>2021-06-01T03:04:05.786Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffd400&gt;童心童趣，无关年龄，愿我们都能永葆一份童真。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-浏览器模型&quot;&gt;&lt;a href=&quot;#JS-浏览器模型&quot; class=&quot;headerlink&quot; title=&quot;JS 浏览器模型&quot;&gt;&lt;/a&gt;JS 浏览器模型&lt;/h2&gt;&lt;h3 id=&quot;5-XMLHttpRequest-对象&quot;&gt;&lt;a href=&quot;#5-XMLHttpRequest-对象&quot; class=&quot;headerlink&quot; title=&quot;5. XMLHttpRequest 对象&quot;&gt;&lt;/a&gt;5. XMLHttpRequest 对象&lt;/h3&gt;&lt;h4 id=&quot;5-1-简介&quot;&gt;&lt;a href=&quot;#5-1-简介&quot; class=&quot;headerlink&quot; title=&quot;5.1 简介&quot;&gt;&lt;/a&gt;5.1 简介&lt;/h4&gt;&lt;p&gt;浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。&lt;/p&gt;
&lt;p&gt;1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到2004年 Gmail 发布和2005年 Google Map 发布，才引起广泛重视。2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。W3C 也在2006年发布了它的国际标准。&lt;/p&gt;
&lt;p&gt;具体来说，AJAX 包括以下几个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 XMLHttpRequest 实例&lt;/li&gt;
&lt;li&gt;发出 HTTP 请求&lt;/li&gt;
&lt;li&gt;接收服务器传回的数据&lt;/li&gt;
&lt;li&gt;更新网页数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;概括起来，就是一句话，AJAX 通过原生的&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有&lt;code&gt;XML&lt;/code&gt;和&lt;code&gt;Http&lt;/code&gt;，它实际上可以使用多种协议（比如&lt;code&gt;file&lt;/code&gt;或&lt;code&gt;ftp&lt;/code&gt;），发送任何格式的数据（包括字符串和二进制）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;本身是一个构造函数，可以使用&lt;code&gt;new&lt;/code&gt;命令生成实例。它没有任何参数。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 浏览器模型-XMLHttpRequest 对象" scheme="https://codermae.github.io/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B-XMLHttpRequest-%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>打卡0058</title>
    <link href="https://codermae.github.io/2021/05/31/%E6%89%93%E5%8D%A10058/"/>
    <id>https://codermae.github.io/2021/05/31/%E6%89%93%E5%8D%A10058/</id>
    <published>2021-05-31T01:26:09.000Z</published>
    <updated>2021-05-31T02:12:17.822Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#6a6da9&gt;“我拥向宇宙吹来的风 与夏夜相逢 是八月盛景 是清寂长生”&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-浏览器模型&quot;&gt;&lt;a href=&quot;#JS-浏览器模型&quot; class=&quot;headerlink&quot; title=&quot;JS 浏览器模型&quot;&gt;&lt;/a&gt;JS 浏览器模型&lt;/h2&gt;&lt;h3 id=&quot;4-Cookie&quot;&gt;&lt;a href=&quot;#4-Cookie&quot; class=&quot;headerlink&quot; title=&quot;4. Cookie&quot;&gt;&lt;/a&gt;4. Cookie&lt;/h3&gt;&lt;h4 id=&quot;4-1-概述&quot;&gt;&lt;a href=&quot;#4-1-概述&quot; class=&quot;headerlink&quot; title=&quot;4.1 概述&quot;&gt;&lt;/a&gt;4.1 概述&lt;/h4&gt;&lt;p&gt;Cookie 是服务器保存在浏览器的一小段文本信息，一般大小不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。&lt;/p&gt;
&lt;p&gt;Cookie 主要保存状态信息，以下是一些主要用途。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对话（session）管理：保存登录、购物车等需要记录的信息。&lt;/li&gt;
&lt;li&gt;个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。&lt;/li&gt;
&lt;li&gt;追踪用户：记录和分析用户行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cookie 不是一种理想的客户端储存机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端储存应该使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。&lt;/p&gt;
&lt;p&gt;每个 Cookie 都有以下几方面的元数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cookie 的名字&lt;/li&gt;
&lt;li&gt;Cookie 的值（真正的数据写在这里面）&lt;/li&gt;
&lt;li&gt;到期时间（超过这个时间会失效）&lt;/li&gt;
&lt;li&gt;所属域名（默认为当前域名）&lt;/li&gt;
&lt;li&gt;生效的路径（默认为当前网址）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 浏览器模型-Cookie" scheme="https://codermae.github.io/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B-Cookie/"/>
    
  </entry>
  
  <entry>
    <title>打卡0057</title>
    <link href="https://codermae.github.io/2021/05/31/%E6%89%93%E5%8D%A10057/"/>
    <id>https://codermae.github.io/2021/05/31/%E6%89%93%E5%8D%A10057/</id>
    <published>2021-05-31T00:59:48.000Z</published>
    <updated>2021-05-31T02:12:11.178Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#a3cf62&gt;跟这个世界交手的许多年来，你是否，光彩依旧，兴趣盎然。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-浏览器模型&quot;&gt;&lt;a href=&quot;#JS-浏览器模型&quot; class=&quot;headerlink&quot; title=&quot;JS 浏览器模型&quot;&gt;&lt;/a&gt;JS 浏览器模型&lt;/h2&gt;&lt;h3 id=&quot;3-Navigator-对象，Screen-对象&quot;&gt;&lt;a href=&quot;#3-Navigator-对象，Screen-对象&quot; class=&quot;headerlink&quot; title=&quot;3. Navigator 对象，Screen 对象&quot;&gt;&lt;/a&gt;3. Navigator 对象，Screen 对象&lt;/h3&gt;&lt;p&gt;&lt;code&gt;window.navigator&lt;/code&gt;属性指向一个包含浏览器和系统信息的 Navigator 对象。脚本通过这个属性了解用户的环境信息。&lt;/p&gt;
&lt;h4 id=&quot;3-1-Navigator-对象的属性&quot;&gt;&lt;a href=&quot;#3-1-Navigator-对象的属性&quot; class=&quot;headerlink&quot; title=&quot;3.1 Navigator 对象的属性&quot;&gt;&lt;/a&gt;3.1 Navigator 对象的属性&lt;/h4&gt;&lt;h5 id=&quot;3-1-1-Navigator-userAgent&quot;&gt;&lt;a href=&quot;#3-1-1-Navigator-userAgent&quot; class=&quot;headerlink&quot; title=&quot;3.1.1 Navigator.userAgent&quot;&gt;&lt;/a&gt;3.1.1 Navigator.userAgent&lt;/h5&gt;&lt;p&gt;&lt;code&gt;navigator.userAgent&lt;/code&gt;属性返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。&lt;/p&gt;
&lt;p&gt;下面是 Chrome 浏览器的&lt;code&gt;userAgent&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;navigator.userAgent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &amp;quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过&lt;code&gt;userAgent&lt;/code&gt;属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器了，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。&lt;/p&gt;
&lt;p&gt;不过，通过&lt;code&gt;userAgent&lt;/code&gt;可以大致准确地识别手机浏览器，方法就是测试是否包含&lt;code&gt;mobi&lt;/code&gt;字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ua = navigator.userAgent.toLowerCase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;regexp&quot;&gt;/mobi/i&lt;/span&gt;.test(ua)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 手机浏览器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 非手机浏览器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 浏览器模型-Navigator 对象，Screen 对象" scheme="https://codermae.github.io/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B-Navigator-%E5%AF%B9%E8%B1%A1%EF%BC%8CScreen-%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>打卡0056</title>
    <link href="https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10056/"/>
    <id>https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10056/</id>
    <published>2021-05-30T06:39:04.000Z</published>
    <updated>2021-05-30T08:39:56.392Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#c77eb5&gt;最好的时光在路上，一路向阳。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-浏览器模型&quot;&gt;&lt;a href=&quot;#JS-浏览器模型&quot; class=&quot;headerlink&quot; title=&quot;JS 浏览器模型&quot;&gt;&lt;/a&gt;JS 浏览器模型&lt;/h2&gt;&lt;h3 id=&quot;2-window-对象&quot;&gt;&lt;a href=&quot;#2-window-对象&quot; class=&quot;headerlink&quot; title=&quot;2. window 对象&quot;&gt;&lt;/a&gt;2. window 对象&lt;/h3&gt;&lt;h4 id=&quot;2-1-概述&quot;&gt;&lt;a href=&quot;#2-1-概述&quot; class=&quot;headerlink&quot; title=&quot;2.1 概述&quot;&gt;&lt;/a&gt;2.1 概述&lt;/h4&gt;&lt;p&gt;浏览器里面，&lt;code&gt;window&lt;/code&gt;对象（注意，&lt;code&gt;w&lt;/code&gt;为小写）指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.a &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，&lt;code&gt;a&lt;/code&gt;是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;window&lt;/code&gt;有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把&lt;code&gt;window&lt;/code&gt;对象当作顶层对象，所有未声明就赋值的变量都自动变成&lt;code&gt;window&lt;/code&gt;对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 浏览器模型-window 对象" scheme="https://codermae.github.io/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B-window-%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>打卡0055</title>
    <link href="https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10055/"/>
    <id>https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10055/</id>
    <published>2021-05-30T05:53:33.000Z</published>
    <updated>2021-05-30T08:39:48.476Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#7a1723&gt;我与春风皆过客，你携秋水揽星河。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-浏览器模型&quot;&gt;&lt;a href=&quot;#JS-浏览器模型&quot; class=&quot;headerlink&quot; title=&quot;JS 浏览器模型&quot;&gt;&lt;/a&gt;JS 浏览器模型&lt;/h2&gt;&lt;h3 id=&quot;1-浏览器环境概述&quot;&gt;&lt;a href=&quot;#1-浏览器环境概述&quot; class=&quot;headerlink&quot; title=&quot;1. 浏览器环境概述&quot;&gt;&lt;/a&gt;1. 浏览器环境概述&lt;/h3&gt;&lt;p&gt;JavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。&lt;/p&gt;
&lt;p&gt;本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。&lt;/p&gt;
&lt;h4 id=&quot;1-1-代码嵌入网页的方法&quot;&gt;&lt;a href=&quot;#1-1-代码嵌入网页的方法&quot; class=&quot;headerlink&quot; title=&quot;1.1 代码嵌入网页的方法&quot;&gt;&lt;/a&gt;1.1 代码嵌入网页的方法&lt;/h4&gt;&lt;p&gt;网页中嵌入 JavaScript 代码，主要有四种方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素直接嵌入代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签加载外部脚本&lt;/li&gt;
&lt;li&gt;事件属性&lt;/li&gt;
&lt;li&gt;URL 协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 浏览器模型-浏览器环境概述" scheme="https://codermae.github.io/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>打卡0054</title>
    <link href="https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10054/"/>
    <id>https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10054/</id>
    <published>2021-05-30T05:39:22.000Z</published>
    <updated>2021-05-30T08:39:35.237Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#65c294&gt;生活就是这样，别人只看结果，自我独撑过程。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;11-GlobalEventHandlers-接口&quot;&gt;&lt;a href=&quot;#11-GlobalEventHandlers-接口&quot; class=&quot;headerlink&quot; title=&quot;11. GlobalEventHandlers 接口&quot;&gt;&lt;/a&gt;11. GlobalEventHandlers 接口&lt;/h3&gt;&lt;p&gt;指定事件的回调函数，推荐使用的方法是元素的&lt;code&gt;addEventListener&lt;/code&gt;方法。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;div.addEventListener(&lt;span class=&quot;string&quot;&gt;&amp;#x27;click&amp;#x27;&lt;/span&gt;, clickHandler, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了之外，还有一种方法可以直接指定事件的回调函数。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;div.onclick = clickHandler;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个接口是由&lt;code&gt;GlobalEventHandlers&lt;/code&gt;接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTMLElement&lt;/code&gt;、&lt;code&gt;Document&lt;/code&gt;和&lt;code&gt;Window&lt;/code&gt;都继承了这个接口，也就是说，各种 HTML 元素、&lt;code&gt;document&lt;/code&gt;对象、&lt;code&gt;window&lt;/code&gt;对象上面都可以使用&lt;code&gt;GlobalEventHandlers&lt;/code&gt;接口提供的属性。下面就列出这个接口提供的主要的事件属性。&lt;/p&gt;
&lt;h4 id=&quot;11-1-GlobalEventHandlers-onabort&quot;&gt;&lt;a href=&quot;#11-1-GlobalEventHandlers-onabort&quot; class=&quot;headerlink&quot; title=&quot;11.1 GlobalEventHandlers.onabort&quot;&gt;&lt;/a&gt;11.1 GlobalEventHandlers.onabort&lt;/h4&gt;&lt;p&gt; 某个对象的&lt;code&gt;abort&lt;/code&gt;事件（停止加载）发生时，就会调用&lt;code&gt;onabort&lt;/code&gt;属性指定的回调函数。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-GlobalEventHandlers 接口" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-GlobalEventHandlers-%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>打卡0053</title>
    <link href="https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10053/"/>
    <id>https://codermae.github.io/2021/05/30/%E6%89%93%E5%8D%A10053/</id>
    <published>2021-05-30T04:50:15.000Z</published>
    <updated>2021-05-30T08:39:25.641Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#c37e00&gt;你未必万丈光芒，但你温暖有光。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;10-其他常见事件&quot;&gt;&lt;a href=&quot;#10-其他常见事件&quot; class=&quot;headerlink&quot; title=&quot;10. 其他常见事件&quot;&gt;&lt;/a&gt;10. 其他常见事件&lt;/h3&gt;&lt;h4 id=&quot;10-1-资源事件&quot;&gt;&lt;a href=&quot;#10-1-资源事件&quot; class=&quot;headerlink&quot; title=&quot;10.1 资源事件&quot;&gt;&lt;/a&gt;10.1 资源事件&lt;/h4&gt;&lt;h5 id=&quot;10-1-1-beforeunload-事件&quot;&gt;&lt;a href=&quot;#10-1-1-beforeunload-事件&quot; class=&quot;headerlink&quot; title=&quot;10.1.1 beforeunload 事件&quot;&gt;&lt;/a&gt;10.1.1 beforeunload 事件&lt;/h5&gt;&lt;p&gt;&lt;code&gt;beforeunload&lt;/code&gt;事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。&lt;/p&gt;
&lt;p&gt;如果该事件对象的&lt;code&gt;returnValue&lt;/code&gt;属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;span class=&quot;string&quot;&gt;&amp;#x27;beforeunload&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  event.returnValue = &lt;span class=&quot;string&quot;&gt;&amp;#x27;你确定离开吗？&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，用户如果关闭窗口，浏览器会弹出一个窗口，要求用户确认。&lt;/p&gt;
&lt;p&gt;浏览器对这个事件的行为很不一致，有的浏览器调用&lt;code&gt;event.preventDefault()&lt;/code&gt;，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。因此，可以采用下面的写法，取得最大的兼容性。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;span class=&quot;string&quot;&gt;&amp;#x27;beforeunload&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; confirmationMessage = &lt;span class=&quot;string&quot;&gt;&amp;#x27;确认关闭窗口？&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  e.returnValue = confirmationMessage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; confirmationMessage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-其他常见事件" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0052</title>
    <link href="https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10052/"/>
    <id>https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10052/</id>
    <published>2021-05-29T05:08:24.000Z</published>
    <updated>2021-05-29T05:48:27.034Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#f47920&gt;劝君更尽一杯酒，西出阳关无故人。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;9-拖拉事件&quot;&gt;&lt;a href=&quot;#9-拖拉事件&quot; class=&quot;headerlink&quot; title=&quot;9. 拖拉事件&quot;&gt;&lt;/a&gt;9. 拖拉事件&lt;/h3&gt;&lt;h4 id=&quot;9-1-拖拉事件的种类&quot;&gt;&lt;a href=&quot;#9-1-拖拉事件的种类&quot; class=&quot;headerlink&quot; title=&quot;9.1 拖拉事件的种类&quot;&gt;&lt;/a&gt;9.1 拖拉事件的种类&lt;/h4&gt;&lt;p&gt;拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。&lt;/p&gt;
&lt;p&gt;拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都可以直接拖拉。为了让元素节点可拖拉，可以将该节点的&lt;code&gt;draggable&lt;/code&gt;属性设为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div draggable=&lt;span class=&quot;string&quot;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  此区域可拖拉&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码的&lt;code&gt;div&lt;/code&gt;区块，在网页中可以直接用鼠标拖动。松开鼠标键时，拖动效果就会消失，该区块依然在原来的位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;draggable&lt;/code&gt;属性可用于任何元素节点，但是图片（&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;）和链接（&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为&lt;code&gt;false&lt;/code&gt;，防止拖拉这两种元素。&lt;/p&gt;
&lt;p&gt;注意，一旦某个元素节点的&lt;code&gt;draggable&lt;/code&gt;属性设为&lt;code&gt;true&lt;/code&gt;，就无法再用鼠标选中该节点内部的文字或子节点了。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-拖拉事件" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0051</title>
    <link href="https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10051/"/>
    <id>https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10051/</id>
    <published>2021-05-29T04:45:38.000Z</published>
    <updated>2021-05-29T05:48:15.338Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#444693&gt;今夜不知何处宿，平沙万里绝人烟。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;8-触摸事件&quot;&gt;&lt;a href=&quot;#8-触摸事件&quot; class=&quot;headerlink&quot; title=&quot;8. 触摸事件&quot;&gt;&lt;/a&gt;8. 触摸事件&lt;/h3&gt;&lt;h4 id=&quot;8-1-触摸操作概述&quot;&gt;&lt;a href=&quot;#8-1-触摸操作概述&quot; class=&quot;headerlink&quot; title=&quot;8.1 触摸操作概述&quot;&gt;&lt;/a&gt;8.1 触摸操作概述&lt;/h4&gt;&lt;p&gt;浏览器的触摸 API 由三个部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Touch：一个触摸点&lt;/li&gt;
&lt;li&gt;TouchList：多个触摸点的集合&lt;/li&gt;
&lt;li&gt;TouchEvent：触摸引发的事件实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Touch&lt;/code&gt;接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由&lt;code&gt;TouchList&lt;/code&gt;接口的实例对象表示。&lt;code&gt;TouchEvent&lt;/code&gt;接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。&lt;/p&gt;
&lt;p&gt;很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用&lt;code&gt;event.preventDefault&lt;/code&gt;方法阻止发出鼠标事件。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-触摸事件" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0050</title>
    <link href="https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10050/"/>
    <id>https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10050/</id>
    <published>2021-05-29T04:27:52.000Z</published>
    <updated>2021-05-29T05:48:08.150Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#817936&gt;每个人都在自己的生命中频繁地抛弃着自己的过去。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;7-表单事件&quot;&gt;&lt;a href=&quot;#7-表单事件&quot; class=&quot;headerlink&quot; title=&quot;7. 表单事件&quot;&gt;&lt;/a&gt;7. 表单事件&lt;/h3&gt;&lt;h4 id=&quot;7-1-表单事件的种类&quot;&gt;&lt;a href=&quot;#7-1-表单事件的种类&quot; class=&quot;headerlink&quot; title=&quot;7.1 表单事件的种类&quot;&gt;&lt;/a&gt;7.1 表单事件的种类&lt;/h4&gt;&lt;h5 id=&quot;7-1-1-input-事件&quot;&gt;&lt;a href=&quot;#7-1-1-input-事件&quot; class=&quot;headerlink&quot; title=&quot;7.1.1 input 事件&quot;&gt;&lt;/a&gt;7.1.1 input 事件&lt;/h5&gt;&lt;p&gt;&lt;code&gt;input&lt;/code&gt;事件当&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;的值发生变化时触发。对于复选框（&lt;code&gt;&amp;lt;input type=checkbox&amp;gt;&lt;/code&gt;）或单选框（&lt;code&gt;&amp;lt;input type=radio&amp;gt;&lt;/code&gt;），用户改变选项时，也会触发这个事件。另外，对于打开&lt;code&gt;contenteditable&lt;/code&gt;属性的元素，只要值发生变化，也会触发&lt;code&gt;input&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;input&lt;/code&gt;事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次&lt;code&gt;input&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;input&lt;/code&gt;事件对象继承了&lt;code&gt;InputEvent&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;该事件跟&lt;code&gt;change&lt;/code&gt;事件很像，不同之处在于&lt;code&gt;input&lt;/code&gt;事件在元素的值发生变化后立即发生，而&lt;code&gt;change&lt;/code&gt;在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，&lt;code&gt;input&lt;/code&gt;事件会触发多次，而&lt;code&gt;change&lt;/code&gt;事件只在失去焦点时触发一次。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-表单事件" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0049</title>
    <link href="https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10049/"/>
    <id>https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10049/</id>
    <published>2021-05-29T04:12:46.000Z</published>
    <updated>2021-05-29T05:47:59.850Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#deab8a&gt;相逢尽道休官好，林下何曾见一人。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;6-进度事件&quot;&gt;&lt;a href=&quot;#6-进度事件&quot; class=&quot;headerlink&quot; title=&quot;6. 进度事件&quot;&gt;&lt;/a&gt;6. 进度事件&lt;/h3&gt;&lt;h4 id=&quot;6-1-进度事件的种类&quot;&gt;&lt;a href=&quot;#6-1-进度事件的种类&quot; class=&quot;headerlink&quot; title=&quot;6.1 进度事件的种类&quot;&gt;&lt;/a&gt;6.1 进度事件的种类&lt;/h4&gt;&lt;p&gt;进度事件用来描述资源加载的进度，主要由 AJAX 请求、&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;等外部资源的加载触发，继承了&lt;code&gt;ProgressEvent&lt;/code&gt;接口。它主要包含以下几种事件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;abort&lt;/code&gt;:外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;error&lt;/code&gt;:由于错误导致外部资源无法加载时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load&lt;/code&gt;:外部资源加载成功时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadstart&lt;/code&gt;:外部资源开始加载时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadend&lt;/code&gt;:外部资源停止加载时触发，发生顺序排在&lt;code&gt;error&lt;/code&gt;、&lt;code&gt;abort&lt;/code&gt;、&lt;code&gt;load&lt;/code&gt;等事件的后面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;progress&lt;/code&gt;:外部资源加载过程中不断触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeout&lt;/code&gt;:加载超时时触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，除了资源下载，文件上传也存在这些事件。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-进度事件" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0048</title>
    <link href="https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10048/"/>
    <id>https://codermae.github.io/2021/05/29/%E6%89%93%E5%8D%A10048/</id>
    <published>2021-05-29T03:58:59.000Z</published>
    <updated>2021-05-29T05:47:43.675Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ef5b9c&gt;在自称善意的之时，即存恶意。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;5-键盘事件&quot;&gt;&lt;a href=&quot;#5-键盘事件&quot; class=&quot;headerlink&quot; title=&quot;5. 键盘事件&quot;&gt;&lt;/a&gt;5. 键盘事件&lt;/h3&gt;&lt;h4 id=&quot;5-1-键盘事件的种类&quot;&gt;&lt;a href=&quot;#5-1-键盘事件的种类&quot; class=&quot;headerlink&quot; title=&quot;5.1 键盘事件的种类&quot;&gt;&lt;/a&gt;5.1 键盘事件的种类&lt;/h4&gt;&lt;p&gt;键盘事件由用户击打键盘触发，主要有&lt;code&gt;keydown&lt;/code&gt;、&lt;code&gt;keypress&lt;/code&gt;、&lt;code&gt;keyup&lt;/code&gt;三个事件，它们都继承了&lt;code&gt;KeyboardEvent&lt;/code&gt;接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;keydown&lt;/code&gt;：按下键盘时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keypress&lt;/code&gt;：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发keydown事件，再触发这个事件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keyup&lt;/code&gt;：松开键盘时触发该事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;keydown&lt;/li&gt;
&lt;li&gt;keypress&lt;/li&gt;
&lt;li&gt;keydown&lt;/li&gt;
&lt;li&gt;keypress&lt;/li&gt;
&lt;li&gt;…（重复以上过程）&lt;/li&gt;
&lt;li&gt;keyup&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-键盘事件" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0047</title>
    <link href="https://codermae.github.io/2021/05/28/%E6%89%93%E5%8D%A10047/"/>
    <id>https://codermae.github.io/2021/05/28/%E6%89%93%E5%8D%A10047/</id>
    <published>2021-05-28T02:04:34.000Z</published>
    <updated>2021-05-28T02:40:52.699Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffc20e&gt; “Let there be light.”&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;4-鼠标事件&quot;&gt;&lt;a href=&quot;#4-鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;4. 鼠标事件&quot;&gt;&lt;/a&gt;4. 鼠标事件&lt;/h3&gt;&lt;h4 id=&quot;4-1-鼠标事件的种类&quot;&gt;&lt;a href=&quot;#4-1-鼠标事件的种类&quot; class=&quot;headerlink&quot; title=&quot;4.1 鼠标事件的种类&quot;&gt;&lt;/a&gt;4.1 鼠标事件的种类&lt;/h4&gt;&lt;p&gt;鼠标事件指与鼠标相关的事件，继承了&lt;code&gt;MouseEvent&lt;/code&gt;接口。具体的事件主要有以下一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;click&lt;/code&gt;:按下鼠标（通常是按下主按钮）时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dblclick&lt;/code&gt;:在同一个元素上双击鼠标时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mousedown&lt;/code&gt;:按下鼠标键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mouseup&lt;/code&gt;:释放按下的鼠标键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mousemove&lt;/code&gt;:当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mouseenter&lt;/code&gt;:鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mouseover&lt;/code&gt;:鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mouseout&lt;/code&gt;:鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mouseleave&lt;/code&gt;:鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contextmenu&lt;/code&gt;:按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wheel&lt;/code&gt;:滚动鼠标的滚轮时触发，该事件继承的是&lt;code&gt;WheelEvent&lt;/code&gt;接口。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-鼠标事件" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>打卡0046</title>
    <link href="https://codermae.github.io/2021/05/28/%E6%89%93%E5%8D%A10046/"/>
    <id>https://codermae.github.io/2021/05/28/%E6%89%93%E5%8D%A10046/</id>
    <published>2021-05-28T01:04:21.000Z</published>
    <updated>2021-05-28T02:41:05.149Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#90d7ec&gt;一个人做再大的承诺，都不及踏踏实实、认认真真做事更让人放心。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;3-Event-对象&quot;&gt;&lt;a href=&quot;#3-Event-对象&quot; class=&quot;headerlink&quot; title=&quot;3. Event 对象&quot;&gt;&lt;/a&gt;3. Event 对象&lt;/h3&gt;&lt;h4 id=&quot;3-1-概述&quot;&gt;&lt;a href=&quot;#3-1-概述&quot; class=&quot;headerlink&quot; title=&quot;3.1 概述&quot;&gt;&lt;/a&gt;3.1 概述&lt;/h4&gt;&lt;p&gt;事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个&lt;code&gt;Event&lt;/code&gt;对象，所有的事件都是这个对象的实例，或者说继承了&lt;code&gt;Event.prototype&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Event&lt;/code&gt;对象本身就是一个构造函数，可以用来生成新的实例。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;event = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Event(type, options);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Event&lt;/code&gt;构造函数接受两个参数。第一个参数&lt;code&gt;type&lt;/code&gt;是字符串，表示事件的名称；第二个参数&lt;code&gt;options&lt;/code&gt;是一个对象，表示事件对象的配置。该对象主要有下面两个属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bubbles&lt;/code&gt;：布尔值，可选，默认为&lt;code&gt;false&lt;/code&gt;，表示事件对象是否冒泡。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cancelable&lt;/code&gt;：布尔值，可选，默认为&lt;code&gt;false&lt;/code&gt;，表示事件是否可以被取消，即能否用&lt;code&gt;Event.preventDefault()&lt;/code&gt;取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ev = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Event(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;look&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;#x27;bubbles&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;#x27;cancelable&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.dispatchEvent(ev);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码新建一个&lt;code&gt;look&lt;/code&gt;事件实例，然后使用&lt;code&gt;dispatchEvent&lt;/code&gt;方法触发该事件。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-Event 对象" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-Event-%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>打卡0045</title>
    <link href="https://codermae.github.io/2021/05/27/%E6%89%93%E5%8D%A10045/"/>
    <id>https://codermae.github.io/2021/05/27/%E6%89%93%E5%8D%A10045/</id>
    <published>2021-05-27T02:23:26.000Z</published>
    <updated>2021-05-27T01:57:07.648Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#f47a55&gt;只想着相见时春风细雨甜，哪管他相思夜星前月下苦。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;2-事件模型&quot;&gt;&lt;a href=&quot;#2-事件模型&quot; class=&quot;headerlink&quot; title=&quot;2. 事件模型&quot;&gt;&lt;/a&gt;2. 事件模型&lt;/h3&gt;&lt;h4 id=&quot;2-1-监听函数&quot;&gt;&lt;a href=&quot;#2-1-监听函数&quot; class=&quot;headerlink&quot; title=&quot;2.1 监听函数&quot;&gt;&lt;/a&gt;2.1 监听函数&lt;/h4&gt;&lt;p&gt;浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。&lt;/p&gt;
&lt;p&gt;JavaScript 有三种方法，可以为事件绑定监听函数。&lt;/p&gt;
&lt;h5 id=&quot;2-1-1-HTML-的-on-属性&quot;&gt;&lt;a href=&quot;#2-1-1-HTML-的-on-属性&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 HTML 的 on- 属性&quot;&gt;&lt;/a&gt;2.1.1 HTML 的 on- 属性&lt;/h5&gt;&lt;p&gt;HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;body onload=&lt;span class=&quot;string&quot;&gt;&amp;quot;doSomething()&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div onclick=&lt;span class=&quot;string&quot;&gt;&amp;quot;console.log(&amp;#x27;触发事件&amp;#x27;)&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码为&lt;code&gt;body&lt;/code&gt;节点的&lt;code&gt;load&lt;/code&gt;事件、&lt;code&gt;div&lt;/code&gt;节点的&lt;code&gt;click&lt;/code&gt;事件，指定了监听代码。一旦事件发生，就会执行这段代码。&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-事件模型" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>打卡0044</title>
    <link href="https://codermae.github.io/2021/05/27/%E6%89%93%E5%8D%A10044/"/>
    <id>https://codermae.github.io/2021/05/27/%E6%89%93%E5%8D%A10044/</id>
    <published>2021-05-27T01:34:39.000Z</published>
    <updated>2021-05-27T01:56:54.303Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#853f04&gt;最孤独的人最亲切，受过伤的人总是笑的最灿烂。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-事件&quot;&gt;&lt;a href=&quot;#JS-事件&quot; class=&quot;headerlink&quot; title=&quot;JS 事件&quot;&gt;&lt;/a&gt;JS 事件&lt;/h2&gt;&lt;h3 id=&quot;1-EventTarget-接口&quot;&gt;&lt;a href=&quot;#1-EventTarget-接口&quot; class=&quot;headerlink&quot; title=&quot;1. EventTarget 接口&quot;&gt;&lt;/a&gt;1. EventTarget 接口&lt;/h3&gt;&lt;p&gt;事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。&lt;/p&gt;
&lt;h4 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概述&quot;&gt;&lt;/a&gt;1.1 概述&lt;/h4&gt;&lt;p&gt;DOM 的事件操作（监听和触发），都定义在&lt;code&gt;EventTarget&lt;/code&gt;接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，&lt;code&gt;XMLHttpRequest&lt;/code&gt;、&lt;code&gt;AudioNode&lt;/code&gt;、&lt;code&gt;AudioContext&lt;/code&gt;）也部署了这个接口。&lt;/p&gt;
&lt;p&gt;该接口主要提供三个实例方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addEventListener&lt;/code&gt;：绑定事件的监听函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;removeEventListener&lt;/code&gt;：移除事件的监听函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatchEvent&lt;/code&gt;：触发事件&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS 事件-EventTarget 接口" scheme="https://codermae.github.io/tags/JS-%E4%BA%8B%E4%BB%B6-EventTarget-%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>打卡0043</title>
    <link href="https://codermae.github.io/2021/05/26/%E6%89%93%E5%8D%A10043/"/>
    <id>https://codermae.github.io/2021/05/26/%E6%89%93%E5%8D%A10043/</id>
    <published>2021-05-26T02:08:37.000Z</published>
    <updated>2021-05-26T02:27:49.614Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#fedcbd&gt;别让纠结怨怼，耽误了你对美好风景的体验。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-DOM&quot;&gt;&lt;a href=&quot;#JS-DOM&quot; class=&quot;headerlink&quot; title=&quot;JS DOM&quot;&gt;&lt;/a&gt;JS DOM&lt;/h2&gt;&lt;h3 id=&quot;10-Mutation-Observer-API&quot;&gt;&lt;a href=&quot;#10-Mutation-Observer-API&quot; class=&quot;headerlink&quot; title=&quot;10. Mutation Observer API&quot;&gt;&lt;/a&gt;10. Mutation Observer API&lt;/h3&gt;&lt;h4 id=&quot;10-1-概述&quot;&gt;&lt;a href=&quot;#10-1-概述&quot; class=&quot;headerlink&quot; title=&quot;10.1 概述&quot;&gt;&lt;/a&gt;10.1 概述&lt;/h4&gt;&lt;p&gt;Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。&lt;/p&gt;
&lt;p&gt;概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。&lt;/p&gt;
&lt;p&gt;这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。&lt;/p&gt;
&lt;p&gt;Mutation Observer 有以下特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它等待所有脚本任务完成后，才会运行（即异步触发方式）。&lt;/li&gt;
&lt;li&gt;它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。&lt;/li&gt;
&lt;li&gt;它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS DOM-Mutation Observer API" scheme="https://codermae.github.io/tags/JS-DOM-Mutation-Observer-API/"/>
    
  </entry>
  
  <entry>
    <title>打卡0042</title>
    <link href="https://codermae.github.io/2021/05/26/%E6%89%93%E5%8D%A10042/"/>
    <id>https://codermae.github.io/2021/05/26/%E6%89%93%E5%8D%A10042/</id>
    <published>2021-05-26T01:16:08.000Z</published>
    <updated>2021-05-26T02:27:30.446Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#2a5caa&gt;谁不曾仰望过繁星呢，但你也可以拥有自己的可爱光芒。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-DOM&quot;&gt;&lt;a href=&quot;#JS-DOM&quot; class=&quot;headerlink&quot; title=&quot;JS DOM&quot;&gt;&lt;/a&gt;JS DOM&lt;/h2&gt;&lt;h3 id=&quot;9-CSS-操作&quot;&gt;&lt;a href=&quot;#9-CSS-操作&quot; class=&quot;headerlink&quot; title=&quot;9. CSS 操作&quot;&gt;&lt;/a&gt;9. CSS 操作&lt;/h3&gt;&lt;p&gt;CSS 与 JavaScript 是两个有着明确分工的领域，前者负责页面的视觉效果，后者负责与用户的行为互动。但是，它们毕竟同属网页开发的前端，因此不可避免有着交叉和互相配合。本章介绍如何通过 JavaScript 操作 CSS。&lt;/p&gt;
&lt;h4 id=&quot;9-1-HTML-元素的-style-属性&quot;&gt;&lt;a href=&quot;#9-1-HTML-元素的-style-属性&quot; class=&quot;headerlink&quot; title=&quot;9.1 HTML 元素的 style 属性&quot;&gt;&lt;/a&gt;9.1 HTML 元素的 style 属性&lt;/h4&gt;&lt;p&gt;操作 CSS 样式最简单的方法，就是使用网页元素节点的&lt;code&gt;getAttribute()&lt;/code&gt;方法、&lt;code&gt;setAttribute()&lt;/code&gt;方法和&lt;code&gt;removeAttribute()&lt;/code&gt;方法，直接读写或删除网页元素的&lt;code&gt;style&lt;/code&gt;属性。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;div.setAttribute(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;style&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;background-color:red;&amp;#x27;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&amp;#x27;border:1px solid black;&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码相当于下面的 HTML 代码。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div style=&lt;span class=&quot;string&quot;&gt;&amp;quot;background-color:red; border:1px solid black;&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;style&lt;/code&gt;不仅可以使用字符串读写，它本身还是一个对象，部署了 CSSStyleDeclaration 接口（详见下面的介绍），可以直接读写个别属性。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;e.style.fontSize = &lt;span class=&quot;string&quot;&gt;&amp;#x27;18px&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e.style.color = &lt;span class=&quot;string&quot;&gt;&amp;#x27;black&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS DOM-CSS 操作" scheme="https://codermae.github.io/tags/JS-DOM-CSS-%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>打卡0041</title>
    <link href="https://codermae.github.io/2021/05/26/%E6%89%93%E5%8D%A10041/"/>
    <id>https://codermae.github.io/2021/05/26/%E6%89%93%E5%8D%A10041/</id>
    <published>2021-05-26T00:48:38.000Z</published>
    <updated>2021-05-26T02:27:01.435Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#cde6c7&gt;生活可以迷茫，但不应虚度。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;JS-DOM&quot;&gt;&lt;a href=&quot;#JS-DOM&quot; class=&quot;headerlink&quot; title=&quot;JS DOM&quot;&gt;&lt;/a&gt;JS DOM&lt;/h2&gt;&lt;h3 id=&quot;8-Text-节点和-DocumentFragment-节点&quot;&gt;&lt;a href=&quot;#8-Text-节点和-DocumentFragment-节点&quot; class=&quot;headerlink&quot; title=&quot;8. Text 节点和 DocumentFragment 节点&quot;&gt;&lt;/a&gt;8. Text 节点和 DocumentFragment 节点&lt;/h3&gt;&lt;h4 id=&quot;8-1-Text-节点的概念&quot;&gt;&lt;a href=&quot;#8-1-Text-节点的概念&quot; class=&quot;headerlink&quot; title=&quot;8.1 Text 节点的概念&quot;&gt;&lt;/a&gt;8.1 Text 节点的概念&lt;/h4&gt;&lt;p&gt;文本节点（&lt;code&gt;Text&lt;/code&gt;）代表元素节点（&lt;code&gt;Element&lt;/code&gt;）和属性节点（&lt;code&gt;Attribute&lt;/code&gt;）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。&lt;/p&gt;
&lt;p&gt;通常我们使用父节点的&lt;code&gt;firstChild&lt;/code&gt;、&lt;code&gt;nextSibling&lt;/code&gt;等属性获取文本节点，或者使用&lt;code&gt;Document&lt;/code&gt;节点的&lt;code&gt;createTextNode&lt;/code&gt;方法创造一个文本节点。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取文本节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; textNode = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;string&quot;&gt;&amp;#x27;p&amp;#x27;&lt;/span&gt;).firstChild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创造文本节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; textNode = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.createTextNode(&lt;span class=&quot;string&quot;&gt;&amp;#x27;Hi&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;string&quot;&gt;&amp;#x27;div&amp;#x27;&lt;/span&gt;).appendChild(textNode);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;浏览器原生提供一个&lt;code&gt;Text&lt;/code&gt;构造函数。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 空字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; text1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Text();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 非空字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; text2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Text(&lt;span class=&quot;string&quot;&gt;&amp;#x27;This is a text node&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JS" scheme="https://codermae.github.io/categories/JS/"/>
    
    
    <category term="JS DOM-Text 节点和 DocumentFragment 节点" scheme="https://codermae.github.io/tags/JS-DOM-Text-%E8%8A%82%E7%82%B9%E5%92%8C-DocumentFragment-%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
</feed>
