<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maeBlog</title>
  
  
  <link href="https://codermae.github.io/atom.xml" rel="self"/>
  
  <link href="https://codermae.github.io/"/>
  <updated>2021-11-16T02:14:52.856Z</updated>
  <id>https://codermae.github.io/</id>
  
  <author>
    <name>Ye Ma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>尝试写脚本</title>
    <link href="https://codermae.github.io/2021/11/15/%E6%89%93%E5%8D%A10107/"/>
    <id>https://codermae.github.io/2021/11/15/%E6%89%93%E5%8D%A10107/</id>
    <published>2021-11-15T07:02:04.000Z</published>
    <updated>2021-11-16T02:14:52.856Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#cde6c7&gt;不负光阴就是最好的努力，而努力就是最好的自己。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;又是做loser的一天- -！，上次自动签到没有实现，心有不甘，这次尝试用curl试一下，虽然最后还是没成功，但也要记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="积累" scheme="https://codermae.github.io/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Linux" scheme="https://codermae.github.io/tags/Linux/"/>
    
    <category term="curl" scheme="https://codermae.github.io/tags/curl/"/>
    
    <category term="脚本" scheme="https://codermae.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>实用JS姿势</title>
    <link href="https://codermae.github.io/2021/11/12/%E6%89%93%E5%8D%A10106/"/>
    <id>https://codermae.github.io/2021/11/12/%E6%89%93%E5%8D%A10106/</id>
    <published>2021-11-12T02:39:33.000Z</published>
    <updated>2021-11-12T03:27:00.448Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#9b95c9&gt;你要相信，所有的事与愿违，都是惊喜的铺垫；所有的坚持不懈，终将得到岁月的奖赏。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-解构技巧&quot;&gt;&lt;a href=&quot;#1-解构技巧&quot; class=&quot;headerlink&quot; title=&quot;1. 解构技巧&quot;&gt;&lt;/a&gt;1. 解构技巧&lt;/h3&gt;&lt;p&gt;平常我们需要用到一个嵌套多层的对象中某些属性，会将其解构出来使用&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  part1: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&amp;#x27;零一&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age: &lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 解构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;part1&lt;/span&gt;: &amp;#123; name, age &amp;#125; &amp;#125; = obj&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(name, age)  &lt;span class=&quot;comment&quot;&gt;// 零一  23&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种情况下，我们把&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;从&lt;code&gt;part1&lt;/code&gt;里解构出来了以后，你就无法使用变量&lt;code&gt;obj&lt;/code&gt;中的&lt;code&gt;part1&lt;/code&gt;属性了，如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;part1&lt;/span&gt;: &amp;#123; name, age &amp;#125; &amp;#125; = obj&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(part1)   &lt;span class=&quot;comment&quot;&gt;// Uncaught ReferenceError: part1 is not defined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实我们可以多次解构，如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;part1&lt;/span&gt;: &amp;#123; name, age &amp;#125;, part1 &amp;#125; = obj&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(part1)   &lt;span class=&quot;comment&quot;&gt;// &amp;#123;name: &amp;quot;零一&amp;quot;, age: 23&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="积累" scheme="https://codermae.github.io/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="JS" scheme="https://codermae.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>linux+python3自动签到</title>
    <link href="https://codermae.github.io/2021/11/05/%E6%89%93%E5%8D%A10105/"/>
    <id>https://codermae.github.io/2021/11/05/%E6%89%93%E5%8D%A10105/</id>
    <published>2021-11-05T06:15:57.000Z</published>
    <updated>2021-11-12T02:37:03.839Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#1d953f&gt;有些人光是遇到就已经赚到了。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-安装anaconda3搭建python环境&quot;&gt;&lt;a href=&quot;#1-安装anaconda3搭建python环境&quot; class=&quot;headerlink&quot; title=&quot;1. 安装anaconda3搭建python环境&quot;&gt;&lt;/a&gt;1. 安装anaconda3搭建python环境&lt;/h3&gt;&lt;p&gt;访问(Anaconda)[&lt;a href=&quot;https://repo.anaconda.com]官网下载页面，右键点击你想要安装的版本，复制链接地址&quot;&gt;https://repo.anaconda.com]官网下载页面，右键点击你想要安装的版本，复制链接地址&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https:&amp;#x2F;&amp;#x2F;repo.anaconda.com&amp;#x2F;archive&amp;#x2F;Anaconda3-2021.05-Linux-x86_64.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash Anaconda3-2021.05-Linux-x86_64.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;直接回车&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Welcome to Anaconda3 5.3.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In order to continue the installation process, please review the license&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;agreement.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Please, press ENTER to continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="积累" scheme="https://codermae.github.io/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="linux+python3自动签到" scheme="https://codermae.github.io/tags/linux-python3%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/"/>
    
  </entry>
  
  <entry>
    <title>云服务器部署</title>
    <link href="https://codermae.github.io/2021/11/01/%E6%89%93%E5%8D%A10104/"/>
    <id>https://codermae.github.io/2021/11/01/%E6%89%93%E5%8D%A10104/</id>
    <published>2021-11-01T06:19:58.000Z</published>
    <updated>2021-11-17T11:47:57.466Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#0c212b&gt;万圣节已到，尽情扮鬼笑。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;hexo博客部署到云服务器&quot;&gt;&lt;a href=&quot;#hexo博客部署到云服务器&quot; class=&quot;headerlink&quot; title=&quot;hexo博客部署到云服务器&quot;&gt;&lt;/a&gt;hexo博客部署到云服务器&lt;/h2&gt;&lt;h3 id=&quot;1-本地（win10）hexo博客配置&quot;&gt;&lt;a href=&quot;#1-本地（win10）hexo博客配置&quot; class=&quot;headerlink&quot; title=&quot;1. 本地（win10）hexo博客配置&quot;&gt;&lt;/a&gt;1. 本地（win10）hexo博客配置&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://codermae.github.io/2021/05/01/My-first-blog/&quot;&gt;本地博客配置&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-云服务器配置&quot;&gt;&lt;a href=&quot;#2-云服务器配置&quot; class=&quot;headerlink&quot; title=&quot;2. 云服务器配置&quot;&gt;&lt;/a&gt;2. 云服务器配置&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;centos 8.2&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-添加git新用户&quot;&gt;&lt;a href=&quot;#2-添加git新用户&quot; class=&quot;headerlink&quot; title=&quot;2. 添加git新用户&quot;&gt;&lt;/a&gt;2. 添加git新用户&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;useradd git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;passwd git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;3-切换用户&quot;&gt;&lt;a href=&quot;#3-切换用户&quot; class=&quot;headerlink&quot; title=&quot;3. 切换用户&quot;&gt;&lt;/a&gt;3. 切换用户&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;su - git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;4-操作&quot;&gt;&lt;a href=&quot;#4-操作&quot; class=&quot;headerlink&quot; title=&quot;4. 操作&quot;&gt;&lt;/a&gt;4. 操作&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;进入git用户主目录:&lt;code&gt;cd&lt;/code&gt;或&lt;code&gt;cd~&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建.ssh目录：&lt;code&gt;mkdir .ssh &amp;amp;&amp;amp; chmod 700 .ssh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建authorized_keys公钥保存文件：&lt;code&gt;touch .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将公钥文件导入~/.ssh/authorized_keys&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://codermae.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="hexo博客云服务器部署" scheme="https://codermae.github.io/categories/%E6%8A%80%E6%9C%AF/hexo%E5%8D%9A%E5%AE%A2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="云服务器部署" scheme="https://codermae.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>打卡0103</title>
    <link href="https://codermae.github.io/2021/10/28/%E6%89%93%E5%8D%A10103/"/>
    <id>https://codermae.github.io/2021/10/28/%E6%89%93%E5%8D%A10103/</id>
    <published>2021-10-28T06:51:48.000Z</published>
    <updated>2021-11-01T06:55:40.882Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#faa755&gt;就算没有意义，偶尔也会有好事发生。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;vue-css中使用data变量&quot;&gt;&lt;a href=&quot;#vue-css中使用data变量&quot; class=&quot;headerlink&quot; title=&quot;vue-css中使用data变量&quot;&gt;&lt;/a&gt;vue-css中使用data变量&lt;/h2&gt;&lt;p&gt;这样就在vue中实现了在样式里使用js变量的方法，及通过css定义变量的方式，将变量在行内注入，然后在style中使用var()获取我们在行内设置的数据即可。以后，在封装一些需要动态传入样式参数的ui组件是不是简便了不少。&lt;/p&gt;</summary>
    
    
    
    <category term="积累" scheme="https://codermae.github.io/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="vue-css中使用data变量" scheme="https://codermae.github.io/tags/vue-css%E4%B8%AD%E4%BD%BF%E7%94%A8data%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>打卡0102</title>
    <link href="https://codermae.github.io/2021/10/10/%E6%89%93%E5%8D%A10102/"/>
    <id>https://codermae.github.io/2021/10/10/%E6%89%93%E5%8D%A10102/</id>
    <published>2021-10-10T02:05:30.000Z</published>
    <updated>2021-11-01T06:56:25.504Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;font color=#c76968&gt;吾志所向，一往无前，愈挫愈奋，再接再厉。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="TypeScript" scheme="https://codermae.github.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="https://codermae.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>打卡0101</title>
    <link href="https://codermae.github.io/2021/10/01/%E6%89%93%E5%8D%A10101/"/>
    <id>https://codermae.github.io/2021/10/01/%E6%89%93%E5%8D%A10101/</id>
    <published>2021-10-01T03:12:19.000Z</published>
    <updated>2021-10-01T05:53:05.231Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a  style=&quot;link:text-decoration: underline; color: red;&quot; href=&quot;https://mp.weixin.qq.com/s/Z4KBqEgmBS9LQL3-hmjqbg&quot;&gt;他们做到的，我们应该知道。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Http&quot;&gt;&lt;a href=&quot;#Http&quot; class=&quot;headerlink&quot; title=&quot;Http&quot;&gt;&lt;/a&gt;Http&lt;/h2&gt;&lt;h3 id=&quot;1-引入&quot;&gt;&lt;a href=&quot;#1-引入&quot; class=&quot;headerlink&quot; title=&quot;1. 引入&quot;&gt;&lt;/a&gt;1. 引入&lt;/h3&gt;&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。&lt;/p&gt;
&lt;h3 id=&quot;2-http协议的作用及特点&quot;&gt;&lt;a href=&quot;#2-http协议的作用及特点&quot; class=&quot;headerlink&quot; title=&quot;2. http协议的作用及特点&quot;&gt;&lt;/a&gt;2. http协议的作用及特点&lt;/h3&gt;&lt;p&gt;HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。&lt;/p&gt;
&lt;p&gt;通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。&lt;/p&gt;
&lt;p&gt;通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。&lt;/p&gt;</summary>
    
    
    
    <category term="Http" scheme="https://codermae.github.io/categories/Http/"/>
    
    
    <category term="Http" scheme="https://codermae.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://codermae.github.io/2021/09/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://codermae.github.io/2021/09/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-09-30T01:36:19.000Z</published>
    <updated>2021-11-01T06:55:37.637Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#122e29&gt;不要低估别人的贪婪。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-使用测试方法&quot;&gt;&lt;a href=&quot;#1-使用测试方法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用测试方法&quot;&gt;&lt;/a&gt;1. 使用测试方法&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;.test()&lt;/code&gt; 方法，检测字符串 myString 是否符合正则表达式 myRegex 定义的规则。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; myString = &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; myRegex = &lt;span class=&quot;regexp&quot;&gt;/Hello/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = myRegex.test(myString); &lt;span class=&quot;comment&quot;&gt;// 修改这一行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-匹配文字字符串&quot;&gt;&lt;a href=&quot;#2-匹配文字字符串&quot; class=&quot;headerlink&quot; title=&quot;2. 匹配文字字符串&quot;&gt;&lt;/a&gt;2. 匹配文字字符串&lt;/h3&gt;&lt;p&gt;完成正则表达式 waldoRegex，在字符串 waldoIsHiding 中匹配到文本 “Waldo”。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; waldoIsHiding = &lt;span class=&quot;string&quot;&gt;&amp;quot;Somewhere Waldo is hiding in this text.&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; waldoRegex = &lt;span class=&quot;regexp&quot;&gt;/Waldo/&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 修改这一行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = waldoRegex.test(waldoIsHiding);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3-同时用多种模式匹配文字字符串&quot;&gt;&lt;a href=&quot;#3-同时用多种模式匹配文字字符串&quot; class=&quot;headerlink&quot; title=&quot;3. 同时用多种模式匹配文字字符串&quot;&gt;&lt;/a&gt;3. 同时用多种模式匹配文字字符串&lt;/h3&gt;&lt;p&gt;完成正则表达式 petRegex 以匹配 dog、cat、bird 或者 fish。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; petString = &lt;span class=&quot;string&quot;&gt;&amp;quot;James has a pet cat.&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; petRegex = &lt;span class=&quot;regexp&quot;&gt;/cat|dog|bird|fish/&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 修改这一行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = petRegex.test(petString);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="积累" scheme="https://codermae.github.io/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="JavaScript" scheme="https://codermae.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>打卡0100</title>
    <link href="https://codermae.github.io/2021/09/30/%E6%89%93%E5%8D%A10100/"/>
    <id>https://codermae.github.io/2021/09/30/%E6%89%93%E5%8D%A10100/</id>
    <published>2021-09-30T00:14:51.000Z</published>
    <updated>2021-09-29T01:25:13.532Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#426ab3&gt;世界上总有一半人不理解另一半人的快乐。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;30-最新提案&quot;&gt;&lt;a href=&quot;#30-最新提案&quot; class=&quot;headerlink&quot; title=&quot;30. 最新提案&quot;&gt;&lt;/a&gt;30. 最新提案&lt;/h3&gt;&lt;p&gt;本章介绍一些尚未进入标准、但很有希望的最新提案。&lt;/p&gt;
&lt;h4 id=&quot;30-1-do-表达式&quot;&gt;&lt;a href=&quot;#30-1-do-表达式&quot; class=&quot;headerlink&quot; title=&quot;30.1 do 表达式&quot;&gt;&lt;/a&gt;30.1 do 表达式&lt;/h4&gt;&lt;p&gt;本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; t = f();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t = t * t + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到&lt;code&gt;t&lt;/code&gt;的值，因为块级作用域不返回值，除非&lt;code&gt;t&lt;/code&gt;是全局变量。&lt;/p&gt;
&lt;p&gt;现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上&lt;code&gt;do&lt;/code&gt;，使它变为&lt;code&gt;do&lt;/code&gt;表达式，然后就会返回内部最后执行的表达式的值。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; t = f();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t * t + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，变量&lt;code&gt;x&lt;/code&gt;会得到整个块级作用域的返回值（&lt;code&gt;t * t + 1&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;do&lt;/code&gt;表达式的逻辑非常简单：封装的是什么，就会返回什么。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="最新提案" scheme="https://codermae.github.io/tags/%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>打卡0099</title>
    <link href="https://codermae.github.io/2021/09/29/%E6%89%93%E5%8D%A10099/"/>
    <id>https://codermae.github.io/2021/09/29/%E6%89%93%E5%8D%A10099/</id>
    <published>2021-09-29T02:01:00.000Z</published>
    <updated>2021-09-28T07:20:32.516Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#d64f44&gt;暖风十里丽人天，花压鬓云偏。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;29-ArrayBuffer&quot;&gt;&lt;a href=&quot;#29-ArrayBuffer&quot; class=&quot;headerlink&quot; title=&quot;29. ArrayBuffer&quot;&gt;&lt;/a&gt;29. ArrayBuffer&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;对象、&lt;code&gt;TypedArray&lt;/code&gt;视图和&lt;code&gt;DataView&lt;/code&gt;视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。&lt;/p&gt;
&lt;p&gt;这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 C 语言那样，直接操作字节，将 4 个字节的 32 位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。&lt;/p&gt;
&lt;p&gt;二进制数组就是在这种背景下诞生的。它很像 C 语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了 JavaScript 处理二进制数据的能力，使得开发者有可能通过 JavaScript 与操作系统的原生接口进行二进制通信。&lt;/p&gt;
&lt;p&gt;二进制数组由三类对象组成。&lt;/p&gt;
&lt;p&gt;（1）&lt;code&gt;ArrayBuffer&lt;/code&gt;对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。&lt;/p&gt;
&lt;p&gt;（2）&lt;code&gt;TypedArray&lt;/code&gt;视图：共包括 9 种类型的视图，比如&lt;code&gt;Uint8Array&lt;/code&gt;（无符号 8 位整数）数组视图, &lt;code&gt;Int16Array&lt;/code&gt;（16 位整数）数组视图,&lt;code&gt;Float32Array&lt;/code&gt;（32 位浮点数）数组视图等等。&lt;/p&gt;
&lt;p&gt;（3）&lt;code&gt;DataView&lt;/code&gt;视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。&lt;/p&gt;
&lt;p&gt;简单说，&lt;code&gt;ArrayBuffer&lt;/code&gt;对象代表原始的二进制数据，&lt;code&gt;TypedArray&lt;/code&gt;视图用来读写简单类型的二进制数据，&lt;code&gt;DataView&lt;/code&gt;视图用来读写复杂类型的二进制数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TypedArray&lt;/code&gt;视图支持的数据类型一共有 9 种（&lt;code&gt;DataView&lt;/code&gt;视图支持除&lt;code&gt;Uint8C&lt;/code&gt;以外的其他 8 种）。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="ArrayBuffer" scheme="https://codermae.github.io/tags/ArrayBuffer/"/>
    
  </entry>
  
  <entry>
    <title>打卡0098</title>
    <link href="https://codermae.github.io/2021/09/28/%E6%89%93%E5%8D%A10098/"/>
    <id>https://codermae.github.io/2021/09/28/%E6%89%93%E5%8D%A10098/</id>
    <published>2021-09-28T01:17:34.000Z</published>
    <updated>2021-09-28T01:59:03.791Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#616130&gt;无论将来会遇到谁，生活都是先从遇到自己开始的。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;28-异步遍历器&quot;&gt;&lt;a href=&quot;#28-异步遍历器&quot; class=&quot;headerlink&quot; title=&quot;28. 异步遍历器&quot;&gt;&lt;/a&gt;28. 异步遍历器&lt;/h3&gt;&lt;h4 id=&quot;28-1-同步遍历器的问题&quot;&gt;&lt;a href=&quot;#28-1-同步遍历器的问题&quot; class=&quot;headerlink&quot; title=&quot;28.1 同步遍历器的问题&quot;&gt;&lt;/a&gt;28.1 同步遍历器的问题&lt;/h4&gt;&lt;p&gt;《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的&lt;code&gt;next&lt;/code&gt;方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。&lt;code&gt;next&lt;/code&gt;方法返回的对象的结构是&lt;code&gt;&amp;#123;value, done&amp;#125;&lt;/code&gt;，其中&lt;code&gt;value&lt;/code&gt;表示当前的数据的值，&lt;code&gt;done&lt;/code&gt;是一个布尔值，表示遍历是否结束。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;idMaker&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: index++, done: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; it = idMaker();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.next().value &lt;span class=&quot;comment&quot;&gt;// 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.next().value &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.next().value &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，变量&lt;code&gt;it&lt;/code&gt;是一个遍历器（iterator）。每次调用&lt;code&gt;it.next()&lt;/code&gt;方法，就返回一个对象，表示当前遍历位置的信息。&lt;/p&gt;
&lt;p&gt;这里隐含着一个规定，&lt;code&gt;it.next()&lt;/code&gt;方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行&lt;code&gt;it.next()&lt;/code&gt;方法，就必须同步地得到&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="异步遍历器" scheme="https://codermae.github.io/tags/%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>打卡0097</title>
    <link href="https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10097/"/>
    <id>https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10097/</id>
    <published>2021-09-27T02:04:36.000Z</published>
    <updated>2021-09-27T05:22:58.024Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#84bf96&gt;每个优秀的人，都有一段沉默的时光。 那段时光，是付出了很多努力，却得不到结果的日子，我们把它叫作扎根。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;27-读懂-ECMAScript-规格&quot;&gt;&lt;a href=&quot;#27-读懂-ECMAScript-规格&quot; class=&quot;headerlink&quot; title=&quot;27. 读懂 ECMAScript 规格&quot;&gt;&lt;/a&gt;27. 读懂 ECMAScript 规格&lt;/h3&gt;&lt;h4 id=&quot;27-1-概述&quot;&gt;&lt;a href=&quot;#27-1-概述&quot; class=&quot;headerlink&quot; title=&quot;27.1 概述&quot;&gt;&lt;/a&gt;27.1 概述&lt;/h4&gt;&lt;p&gt;规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。&lt;/p&gt;
&lt;p&gt;一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。&lt;/p&gt;
&lt;p&gt;这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。&lt;/p&gt;
&lt;p&gt;本章介绍如何读懂 ECMAScript 6 的规格文件。&lt;/p&gt;
&lt;p&gt;ECMAScript 6 的规格，可以在 ECMA 国际标准组织的官方网站（&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/%EF%BC%89%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%9C%A8%E7%BA%BF%E9%98%85%E8%AF%BB%E3%80%82&quot;&gt;www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个规格文件相当庞大，一共有 26 章，A4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 ES6 实现都有一致的行为。&lt;/p&gt;
&lt;p&gt;ECMAScript 6 规格的 26 章之中，第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，第 6 章介绍数据类型，第 7 章介绍语言内部用到的抽象操作，第 8 章介绍代码如何运行。第 9 章到第 26 章介绍具体的语法。&lt;/p&gt;
&lt;p&gt;对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。&lt;/p&gt;
&lt;h4 id=&quot;27-2-术语&quot;&gt;&lt;a href=&quot;#27-2-术语&quot; class=&quot;headerlink&quot; title=&quot;27.2 术语&quot;&gt;&lt;/a&gt;27.2 术语&lt;/h4&gt;&lt;p&gt;ES6 规格使用了一些专门的术语，了解这些术语，可以帮助你读懂规格。本节介绍其中的几个。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="读懂 ECMAScript 规格" scheme="https://codermae.github.io/tags/%E8%AF%BB%E6%87%82-ECMAScript-%E8%A7%84%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>打卡0096</title>
    <link href="https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10096/"/>
    <id>https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10096/</id>
    <published>2021-09-27T01:11:31.000Z</published>
    <updated>2021-09-27T05:22:48.992Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#df9464&gt;没有什么比时间更有说服力了，因为时间无需通知我们就可以改变一切。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;26-编程风格&quot;&gt;&lt;a href=&quot;#26-编程风格&quot; class=&quot;headerlink&quot; title=&quot;26. 编程风格&quot;&gt;&lt;/a&gt;26. 编程风格&lt;/h3&gt;&lt;h4 id=&quot;26-1-块级作用域&quot;&gt;&lt;a href=&quot;#26-1-块级作用域&quot; class=&quot;headerlink&quot; title=&quot;26.1 块级作用域&quot;&gt;&lt;/a&gt;26.1 块级作用域&lt;/h4&gt;&lt;p&gt;（1）let 取代 var&lt;/p&gt;
&lt;p&gt;ES6 提出了两个新的声明变量的命令：&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;。其中，&lt;code&gt;let&lt;/code&gt;完全可以取代&lt;code&gt;var&lt;/code&gt;，因为两者语义相同，而且&lt;code&gt;let&lt;/code&gt;没有副作用。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;#x27;use strict&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码如果用&lt;code&gt;var&lt;/code&gt;替代&lt;code&gt;let&lt;/code&gt;，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，&lt;code&gt;var&lt;/code&gt;命令做不到这一点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt;命令存在变量提升效用，&lt;code&gt;let&lt;/code&gt;命令没有这个问题。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;#x27;use strict&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x); &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码如果使用&lt;code&gt;var&lt;/code&gt;替代&lt;code&gt;let&lt;/code&gt;，&lt;code&gt;console.log&lt;/code&gt;那一行就不会报错，而是会输出&lt;code&gt;undefined&lt;/code&gt;，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。&lt;/p&gt;
&lt;p&gt;所以，建议不再使用&lt;code&gt;var&lt;/code&gt;命令，而是使用&lt;code&gt;let&lt;/code&gt;命令取代。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="编程风格" scheme="https://codermae.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>打卡0095</title>
    <link href="https://codermae.github.io/2021/09/26/%E6%89%93%E5%8D%A10095/"/>
    <id>https://codermae.github.io/2021/09/26/%E6%89%93%E5%8D%A10095/</id>
    <published>2021-09-26T06:35:40.000Z</published>
    <updated>2021-09-27T05:22:44.546Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#90d7ec&gt;愿你我既可以朝九晚五、又可以浪迹天涯&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;25-Module-的加载实现&quot;&gt;&lt;a href=&quot;#25-Module-的加载实现&quot; class=&quot;headerlink&quot; title=&quot;25. Module 的加载实现&quot;&gt;&lt;/a&gt;25. Module 的加载实现&lt;/h3&gt;&lt;h4 id=&quot;25-1-浏览器加载&quot;&gt;&lt;a href=&quot;#25-1-浏览器加载&quot; class=&quot;headerlink&quot; title=&quot;25.1 浏览器加载&quot;&gt;&lt;/a&gt;25.1 浏览器加载&lt;/h4&gt;&lt;h5 id=&quot;25-1-1-传统方法&quot;&gt;&lt;a href=&quot;#25-1-1-传统方法&quot; class=&quot;headerlink&quot; title=&quot;25.1.1 传统方法&quot;&gt;&lt;/a&gt;25.1.1 传统方法&lt;/h5&gt;&lt;p&gt;HTML 网页中，浏览器通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签加载 JavaScript 脚本。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 页面内嵌的脚本 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&amp;quot;application/javascript&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// module code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 外部脚本 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&amp;quot;application/javascript&amp;quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&amp;quot;path/to/myModule.js&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此&lt;code&gt;type=&amp;quot;application/javascript&amp;quot;&lt;/code&gt;可以省略。&lt;/p&gt;
&lt;p&gt;默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。&lt;/p&gt;
&lt;p&gt;如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&amp;quot;path/to/myModule.js&amp;quot;&lt;/span&gt; defer&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&amp;quot;path/to/myModule.js&amp;quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签打开&lt;code&gt;defer&lt;/code&gt;或&lt;code&gt;async&lt;/code&gt;属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;与&lt;code&gt;async&lt;/code&gt;的区别是：&lt;code&gt;defer&lt;/code&gt;要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；&lt;code&gt;async&lt;/code&gt;一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，&lt;code&gt;defer&lt;/code&gt;是“渲染完再执行”，&lt;code&gt;async&lt;/code&gt;是“下载完就执行”。另外，如果有多个&lt;code&gt;defer&lt;/code&gt;脚本，会按照它们在页面出现的顺序加载，而多个&lt;code&gt;async&lt;/code&gt;脚本是不能保证加载顺序的。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Module 的加载实现" scheme="https://codermae.github.io/tags/Module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>打卡0094</title>
    <link href="https://codermae.github.io/2021/09/25/%E6%89%93%E5%8D%A10094/"/>
    <id>https://codermae.github.io/2021/09/25/%E6%89%93%E5%8D%A10094/</id>
    <published>2021-09-25T00:50:34.000Z</published>
    <updated>2021-09-27T05:22:40.820Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#121a2a&gt;勤奋的人总是按时起床，乐观的人总是那么阳光，努力的人总能超越梦想，正能量的人总是自带光芒。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;24-Module-的语法&quot;&gt;&lt;a href=&quot;#24-Module-的语法&quot; class=&quot;headerlink&quot; title=&quot;24. Module 的语法&quot;&gt;&lt;/a&gt;24. Module 的语法&lt;/h3&gt;&lt;h4 id=&quot;24-1-概述&quot;&gt;&lt;a href=&quot;#24-1-概述&quot; class=&quot;headerlink&quot; title=&quot;24.1 概述&quot;&gt;&lt;/a&gt;24.1 概述&lt;/h4&gt;&lt;p&gt;历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p&gt;
&lt;p&gt;在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。&lt;/p&gt;
&lt;p&gt;ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// CommonJS模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &amp;#123; stat, exists, readfile &amp;#125; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;fs&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; _fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;fs&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; stat = _fs.stat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; exists = _fs.exists;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; readfile = _fs.readfile;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码的实质是整体加载&lt;code&gt;fs&lt;/code&gt;模块（即加载&lt;code&gt;fs&lt;/code&gt;的所有方法），生成一个对象（&lt;code&gt;_fs&lt;/code&gt;），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p&gt;
&lt;p&gt;ES6 模块不是对象，而是通过&lt;code&gt;export&lt;/code&gt;命令显式指定输出的代码，再通过&lt;code&gt;import&lt;/code&gt;命令输入。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Module 的语法" scheme="https://codermae.github.io/tags/Module-%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>打卡0093</title>
    <link href="https://codermae.github.io/2021/09/24/%E6%89%93%E5%8D%A10093/"/>
    <id>https://codermae.github.io/2021/09/24/%E6%89%93%E5%8D%A10093/</id>
    <published>2021-09-24T01:02:43.000Z</published>
    <updated>2021-09-27T05:22:36.450Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#f15a22&gt;岁月因青春慨然以赴而更加美好，世间因少年挺身向前而更加瑰丽。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;23-Class-的继承&quot;&gt;&lt;a href=&quot;#23-Class-的继承&quot; class=&quot;headerlink&quot; title=&quot;23. Class 的继承&quot;&gt;&lt;/a&gt;23. Class 的继承&lt;/h3&gt;&lt;h4 id=&quot;23-1-简介&quot;&gt;&lt;a href=&quot;#23-1-简介&quot; class=&quot;headerlink&quot; title=&quot;23.1 简介&quot;&gt;&lt;/a&gt;23.1 简介&lt;/h4&gt;&lt;p&gt;Class 可以通过&lt;code&gt;extends&lt;/code&gt;关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ColorPoint&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码定义了一个&lt;code&gt;ColorPoint&lt;/code&gt;类，该类通过&lt;code&gt;extends&lt;/code&gt;关键字，继承了&lt;code&gt;Point&lt;/code&gt;类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个&lt;code&gt;Point&lt;/code&gt;类。下面，我们在&lt;code&gt;ColorPoint&lt;/code&gt;内部加上代码。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ColorPoint&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y, color&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;super&lt;/span&gt;(x, y); &lt;span class=&quot;comment&quot;&gt;// 调用父类的constructor(x, y)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.color = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;toString&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.color + &lt;span class=&quot;string&quot;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;super&lt;/span&gt;.toString(); &lt;span class=&quot;comment&quot;&gt;// 调用父类的toString()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，&lt;code&gt;constructor&lt;/code&gt;方法和&lt;code&gt;toString&lt;/code&gt;方法之中，都出现了&lt;code&gt;super&lt;/code&gt;关键字，它在这里表示父类的构造函数，用来新建父类的&lt;code&gt;this&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;子类必须在&lt;code&gt;constructor&lt;/code&gt;方法中调用&lt;code&gt;super&lt;/code&gt;方法，否则新建实例时会报错。这是因为子类自己的&lt;code&gt;this&lt;/code&gt;对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用&lt;code&gt;super&lt;/code&gt;方法，子类就得不到&lt;code&gt;this&lt;/code&gt;对象。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Class 的继承" scheme="https://codermae.github.io/tags/Class-%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>打卡0092</title>
    <link href="https://codermae.github.io/2021/09/22/%E6%89%93%E5%8D%A10092/"/>
    <id>https://codermae.github.io/2021/09/22/%E6%89%93%E5%8D%A10092/</id>
    <published>2021-09-22T02:08:34.000Z</published>
    <updated>2021-09-27T05:22:30.102Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#6a6da9&gt;你所厌烦的普通，也许是他生命中最珍贵的平凡。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;22-Class-的基本语法&quot;&gt;&lt;a href=&quot;#22-Class-的基本语法&quot; class=&quot;headerlink&quot; title=&quot;22. Class 的基本语法&quot;&gt;&lt;/a&gt;22. Class 的基本语法&lt;/h3&gt;&lt;h4 id=&quot;22-1-简介&quot;&gt;&lt;a href=&quot;#22-1-简介&quot; class=&quot;headerlink&quot; title=&quot;22.1 简介&quot;&gt;&lt;/a&gt;22.1 简介&lt;/h4&gt;&lt;h5 id=&quot;22-1-1-类的由来&quot;&gt;&lt;a href=&quot;#22-1-1-类的由来&quot; class=&quot;headerlink&quot; title=&quot;22.1.1 类的由来&quot;&gt;&lt;/a&gt;22.1.1 类的由来&lt;/h5&gt;&lt;p&gt;JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Point.prototype.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&amp;#x27;, &amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&amp;#x27;)&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。&lt;/p&gt;
&lt;p&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过&lt;code&gt;class&lt;/code&gt;关键字，可以定义类。&lt;/p&gt;
&lt;p&gt;基本上，ES6 的&lt;code&gt;class&lt;/code&gt;可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的&lt;code&gt;class&lt;/code&gt;写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的&lt;code&gt;class&lt;/code&gt;改写，就是下面这样。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;toString&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&amp;#x27;, &amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&amp;#x27;)&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Class 的基本语法" scheme="https://codermae.github.io/tags/Class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>踩坑JavaScript</title>
    <link href="https://codermae.github.io/2021/09/16/%E8%B8%A9%E5%9D%91JavaScript/"/>
    <id>https://codermae.github.io/2021/09/16/%E8%B8%A9%E5%9D%91JavaScript/</id>
    <published>2021-09-16T12:33:23.000Z</published>
    <updated>2021-09-26T12:44:44.774Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffc20e&gt;人生当自勉，学习需坚持。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;踩坑记录&quot;&gt;&lt;a href=&quot;#踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;踩坑记录&quot;&gt;&lt;/a&gt;踩坑记录&lt;/h2&gt;</summary>
    
    
    
    <category term="踩坑" scheme="https://codermae.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑JavaScript" scheme="https://codermae.github.io/tags/%E8%B8%A9%E5%9D%91JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>踩坑Koa</title>
    <link href="https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91Koa/"/>
    <id>https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91Koa/</id>
    <published>2021-09-15T13:07:46.000Z</published>
    <updated>2021-09-26T12:44:47.993Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffc20e&gt;人生当自勉，学习需坚持。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;踩坑记录&quot;&gt;&lt;a href=&quot;#踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;踩坑记录&quot;&gt;&lt;/a&gt;踩坑记录&lt;/h2&gt;</summary>
    
    
    
    <category term="踩坑" scheme="https://codermae.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑Koa" scheme="https://codermae.github.io/tags/%E8%B8%A9%E5%9D%91Koa/"/>
    
  </entry>
  
  <entry>
    <title>踩坑MongoDB</title>
    <link href="https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91MongoDB/"/>
    <id>https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91MongoDB/</id>
    <published>2021-09-15T12:32:52.000Z</published>
    <updated>2021-09-26T12:44:38.747Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffc20e&gt;人生当自勉，学习需坚持。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;踩坑记录&quot;&gt;&lt;a href=&quot;#踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;踩坑记录&quot;&gt;&lt;/a&gt;踩坑记录&lt;/h2&gt;</summary>
    
    
    
    <category term="踩坑" scheme="https://codermae.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑MongoDB" scheme="https://codermae.github.io/tags/%E8%B8%A9%E5%9D%91MongoDB/"/>
    
  </entry>
  
</feed>
