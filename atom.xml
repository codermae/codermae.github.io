<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maeBlog</title>
  
  
  <link href="https://codermae.github.io/atom.xml" rel="self"/>
  
  <link href="https://codermae.github.io/"/>
  <updated>2021-10-01T05:53:05.231Z</updated>
  <id>https://codermae.github.io/</id>
  
  <author>
    <name>Ye Ma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>打卡0101</title>
    <link href="https://codermae.github.io/2021/10/01/%E6%89%93%E5%8D%A10101/"/>
    <id>https://codermae.github.io/2021/10/01/%E6%89%93%E5%8D%A10101/</id>
    <published>2021-10-01T03:12:19.000Z</published>
    <updated>2021-10-01T05:53:05.231Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a  style=&quot;link:text-decoration: underline; color: red;&quot; href=&quot;https://mp.weixin.qq.com/s/Z4KBqEgmBS9LQL3-hmjqbg&quot;&gt;他们做到的，我们应该知道。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Http&quot;&gt;&lt;a href=&quot;#Http&quot; class=&quot;headerlink&quot; title=&quot;Http&quot;&gt;&lt;/a&gt;Http&lt;/h2&gt;&lt;h3 id=&quot;1-引入&quot;&gt;&lt;a href=&quot;#1-引入&quot; class=&quot;headerlink&quot; title=&quot;1. 引入&quot;&gt;&lt;/a&gt;1. 引入&lt;/h3&gt;&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。&lt;/p&gt;
&lt;h3 id=&quot;2-http协议的作用及特点&quot;&gt;&lt;a href=&quot;#2-http协议的作用及特点&quot; class=&quot;headerlink&quot; title=&quot;2. http协议的作用及特点&quot;&gt;&lt;/a&gt;2. http协议的作用及特点&lt;/h3&gt;&lt;p&gt;HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。&lt;/p&gt;
&lt;p&gt;通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。&lt;/p&gt;
&lt;p&gt;通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。&lt;/p&gt;</summary>
    
    
    
    <category term="Http" scheme="https://codermae.github.io/categories/Http/"/>
    
    
    <category term="Http" scheme="https://codermae.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://codermae.github.io/2021/09/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://codermae.github.io/2021/09/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-09-30T01:36:19.000Z</published>
    <updated>2021-10-01T06:00:37.784Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=122e29&gt;不要低估别人的贪婪。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-使用测试方法&quot;&gt;&lt;a href=&quot;#1-使用测试方法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用测试方法&quot;&gt;&lt;/a&gt;1. 使用测试方法&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;.test()&lt;/code&gt; 方法，检测字符串 myString 是否符合正则表达式 myRegex 定义的规则。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; myString = &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; myRegex = &lt;span class=&quot;regexp&quot;&gt;/Hello/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = myRegex.test(myString); &lt;span class=&quot;comment&quot;&gt;// 修改这一行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-匹配文字字符串&quot;&gt;&lt;a href=&quot;#2-匹配文字字符串&quot; class=&quot;headerlink&quot; title=&quot;2. 匹配文字字符串&quot;&gt;&lt;/a&gt;2. 匹配文字字符串&lt;/h3&gt;&lt;p&gt;完成正则表达式 waldoRegex，在字符串 waldoIsHiding 中匹配到文本 “Waldo”。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; waldoIsHiding = &lt;span class=&quot;string&quot;&gt;&amp;quot;Somewhere Waldo is hiding in this text.&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; waldoRegex = &lt;span class=&quot;regexp&quot;&gt;/Waldo/&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 修改这一行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = waldoRegex.test(waldoIsHiding);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3-同时用多种模式匹配文字字符串&quot;&gt;&lt;a href=&quot;#3-同时用多种模式匹配文字字符串&quot; class=&quot;headerlink&quot; title=&quot;3. 同时用多种模式匹配文字字符串&quot;&gt;&lt;/a&gt;3. 同时用多种模式匹配文字字符串&lt;/h3&gt;&lt;p&gt;完成正则表达式 petRegex 以匹配 dog、cat、bird 或者 fish。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; petString = &lt;span class=&quot;string&quot;&gt;&amp;quot;James has a pet cat.&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; petRegex = &lt;span class=&quot;regexp&quot;&gt;/cat|dog|bird|fish/&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 修改这一行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = petRegex.test(petString);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="积累" scheme="https://codermae.github.io/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="JavaScript" scheme="https://codermae.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>打卡0100</title>
    <link href="https://codermae.github.io/2021/09/30/%E6%89%93%E5%8D%A10100/"/>
    <id>https://codermae.github.io/2021/09/30/%E6%89%93%E5%8D%A10100/</id>
    <published>2021-09-30T00:14:51.000Z</published>
    <updated>2021-09-29T01:25:13.532Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#426ab3&gt;世界上总有一半人不理解另一半人的快乐。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;30-最新提案&quot;&gt;&lt;a href=&quot;#30-最新提案&quot; class=&quot;headerlink&quot; title=&quot;30. 最新提案&quot;&gt;&lt;/a&gt;30. 最新提案&lt;/h3&gt;&lt;p&gt;本章介绍一些尚未进入标准、但很有希望的最新提案。&lt;/p&gt;
&lt;h4 id=&quot;30-1-do-表达式&quot;&gt;&lt;a href=&quot;#30-1-do-表达式&quot; class=&quot;headerlink&quot; title=&quot;30.1 do 表达式&quot;&gt;&lt;/a&gt;30.1 do 表达式&lt;/h4&gt;&lt;p&gt;本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; t = f();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t = t * t + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到&lt;code&gt;t&lt;/code&gt;的值，因为块级作用域不返回值，除非&lt;code&gt;t&lt;/code&gt;是全局变量。&lt;/p&gt;
&lt;p&gt;现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上&lt;code&gt;do&lt;/code&gt;，使它变为&lt;code&gt;do&lt;/code&gt;表达式，然后就会返回内部最后执行的表达式的值。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; t = f();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  t * t + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，变量&lt;code&gt;x&lt;/code&gt;会得到整个块级作用域的返回值（&lt;code&gt;t * t + 1&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;do&lt;/code&gt;表达式的逻辑非常简单：封装的是什么，就会返回什么。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="最新提案" scheme="https://codermae.github.io/tags/%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>打卡0099</title>
    <link href="https://codermae.github.io/2021/09/29/%E6%89%93%E5%8D%A10099/"/>
    <id>https://codermae.github.io/2021/09/29/%E6%89%93%E5%8D%A10099/</id>
    <published>2021-09-29T02:01:00.000Z</published>
    <updated>2021-09-28T07:20:32.516Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#d64f44&gt;暖风十里丽人天，花压鬓云偏。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;29-ArrayBuffer&quot;&gt;&lt;a href=&quot;#29-ArrayBuffer&quot; class=&quot;headerlink&quot; title=&quot;29. ArrayBuffer&quot;&gt;&lt;/a&gt;29. ArrayBuffer&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;对象、&lt;code&gt;TypedArray&lt;/code&gt;视图和&lt;code&gt;DataView&lt;/code&gt;视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。&lt;/p&gt;
&lt;p&gt;这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 C 语言那样，直接操作字节，将 4 个字节的 32 位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。&lt;/p&gt;
&lt;p&gt;二进制数组就是在这种背景下诞生的。它很像 C 语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了 JavaScript 处理二进制数据的能力，使得开发者有可能通过 JavaScript 与操作系统的原生接口进行二进制通信。&lt;/p&gt;
&lt;p&gt;二进制数组由三类对象组成。&lt;/p&gt;
&lt;p&gt;（1）&lt;code&gt;ArrayBuffer&lt;/code&gt;对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。&lt;/p&gt;
&lt;p&gt;（2）&lt;code&gt;TypedArray&lt;/code&gt;视图：共包括 9 种类型的视图，比如&lt;code&gt;Uint8Array&lt;/code&gt;（无符号 8 位整数）数组视图, &lt;code&gt;Int16Array&lt;/code&gt;（16 位整数）数组视图,&lt;code&gt;Float32Array&lt;/code&gt;（32 位浮点数）数组视图等等。&lt;/p&gt;
&lt;p&gt;（3）&lt;code&gt;DataView&lt;/code&gt;视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。&lt;/p&gt;
&lt;p&gt;简单说，&lt;code&gt;ArrayBuffer&lt;/code&gt;对象代表原始的二进制数据，&lt;code&gt;TypedArray&lt;/code&gt;视图用来读写简单类型的二进制数据，&lt;code&gt;DataView&lt;/code&gt;视图用来读写复杂类型的二进制数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TypedArray&lt;/code&gt;视图支持的数据类型一共有 9 种（&lt;code&gt;DataView&lt;/code&gt;视图支持除&lt;code&gt;Uint8C&lt;/code&gt;以外的其他 8 种）。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="ArrayBuffer" scheme="https://codermae.github.io/tags/ArrayBuffer/"/>
    
  </entry>
  
  <entry>
    <title>打卡0098</title>
    <link href="https://codermae.github.io/2021/09/28/%E6%89%93%E5%8D%A10098/"/>
    <id>https://codermae.github.io/2021/09/28/%E6%89%93%E5%8D%A10098/</id>
    <published>2021-09-28T01:17:34.000Z</published>
    <updated>2021-09-28T01:59:03.791Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#616130&gt;无论将来会遇到谁，生活都是先从遇到自己开始的。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;28-异步遍历器&quot;&gt;&lt;a href=&quot;#28-异步遍历器&quot; class=&quot;headerlink&quot; title=&quot;28. 异步遍历器&quot;&gt;&lt;/a&gt;28. 异步遍历器&lt;/h3&gt;&lt;h4 id=&quot;28-1-同步遍历器的问题&quot;&gt;&lt;a href=&quot;#28-1-同步遍历器的问题&quot; class=&quot;headerlink&quot; title=&quot;28.1 同步遍历器的问题&quot;&gt;&lt;/a&gt;28.1 同步遍历器的问题&lt;/h4&gt;&lt;p&gt;《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的&lt;code&gt;next&lt;/code&gt;方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。&lt;code&gt;next&lt;/code&gt;方法返回的对象的结构是&lt;code&gt;&amp;#123;value, done&amp;#125;&lt;/code&gt;，其中&lt;code&gt;value&lt;/code&gt;表示当前的数据的值，&lt;code&gt;done&lt;/code&gt;是一个布尔值，表示遍历是否结束。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;idMaker&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: index++, done: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; it = idMaker();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.next().value &lt;span class=&quot;comment&quot;&gt;// 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.next().value &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.next().value &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，变量&lt;code&gt;it&lt;/code&gt;是一个遍历器（iterator）。每次调用&lt;code&gt;it.next()&lt;/code&gt;方法，就返回一个对象，表示当前遍历位置的信息。&lt;/p&gt;
&lt;p&gt;这里隐含着一个规定，&lt;code&gt;it.next()&lt;/code&gt;方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行&lt;code&gt;it.next()&lt;/code&gt;方法，就必须同步地得到&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="异步遍历器" scheme="https://codermae.github.io/tags/%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>打卡0097</title>
    <link href="https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10097/"/>
    <id>https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10097/</id>
    <published>2021-09-27T02:04:36.000Z</published>
    <updated>2021-09-27T05:22:58.024Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#84bf96&gt;每个优秀的人，都有一段沉默的时光。 那段时光，是付出了很多努力，却得不到结果的日子，我们把它叫作扎根。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;27-读懂-ECMAScript-规格&quot;&gt;&lt;a href=&quot;#27-读懂-ECMAScript-规格&quot; class=&quot;headerlink&quot; title=&quot;27. 读懂 ECMAScript 规格&quot;&gt;&lt;/a&gt;27. 读懂 ECMAScript 规格&lt;/h3&gt;&lt;h4 id=&quot;27-1-概述&quot;&gt;&lt;a href=&quot;#27-1-概述&quot; class=&quot;headerlink&quot; title=&quot;27.1 概述&quot;&gt;&lt;/a&gt;27.1 概述&lt;/h4&gt;&lt;p&gt;规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。&lt;/p&gt;
&lt;p&gt;一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。&lt;/p&gt;
&lt;p&gt;这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。&lt;/p&gt;
&lt;p&gt;本章介绍如何读懂 ECMAScript 6 的规格文件。&lt;/p&gt;
&lt;p&gt;ECMAScript 6 的规格，可以在 ECMA 国际标准组织的官方网站（&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/%EF%BC%89%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%9C%A8%E7%BA%BF%E9%98%85%E8%AF%BB%E3%80%82&quot;&gt;www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个规格文件相当庞大，一共有 26 章，A4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 ES6 实现都有一致的行为。&lt;/p&gt;
&lt;p&gt;ECMAScript 6 规格的 26 章之中，第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，第 6 章介绍数据类型，第 7 章介绍语言内部用到的抽象操作，第 8 章介绍代码如何运行。第 9 章到第 26 章介绍具体的语法。&lt;/p&gt;
&lt;p&gt;对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。&lt;/p&gt;
&lt;h4 id=&quot;27-2-术语&quot;&gt;&lt;a href=&quot;#27-2-术语&quot; class=&quot;headerlink&quot; title=&quot;27.2 术语&quot;&gt;&lt;/a&gt;27.2 术语&lt;/h4&gt;&lt;p&gt;ES6 规格使用了一些专门的术语，了解这些术语，可以帮助你读懂规格。本节介绍其中的几个。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="读懂 ECMAScript 规格" scheme="https://codermae.github.io/tags/%E8%AF%BB%E6%87%82-ECMAScript-%E8%A7%84%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>打卡0096</title>
    <link href="https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10096/"/>
    <id>https://codermae.github.io/2021/09/27/%E6%89%93%E5%8D%A10096/</id>
    <published>2021-09-27T01:11:31.000Z</published>
    <updated>2021-09-27T05:22:48.992Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#df9464&gt;没有什么比时间更有说服力了，因为时间无需通知我们就可以改变一切。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;26-编程风格&quot;&gt;&lt;a href=&quot;#26-编程风格&quot; class=&quot;headerlink&quot; title=&quot;26. 编程风格&quot;&gt;&lt;/a&gt;26. 编程风格&lt;/h3&gt;&lt;h4 id=&quot;26-1-块级作用域&quot;&gt;&lt;a href=&quot;#26-1-块级作用域&quot; class=&quot;headerlink&quot; title=&quot;26.1 块级作用域&quot;&gt;&lt;/a&gt;26.1 块级作用域&lt;/h4&gt;&lt;p&gt;（1）let 取代 var&lt;/p&gt;
&lt;p&gt;ES6 提出了两个新的声明变量的命令：&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;。其中，&lt;code&gt;let&lt;/code&gt;完全可以取代&lt;code&gt;var&lt;/code&gt;，因为两者语义相同，而且&lt;code&gt;let&lt;/code&gt;没有副作用。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;#x27;use strict&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码如果用&lt;code&gt;var&lt;/code&gt;替代&lt;code&gt;let&lt;/code&gt;，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，&lt;code&gt;var&lt;/code&gt;命令做不到这一点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt;命令存在变量提升效用，&lt;code&gt;let&lt;/code&gt;命令没有这个问题。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;#x27;use strict&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x); &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码如果使用&lt;code&gt;var&lt;/code&gt;替代&lt;code&gt;let&lt;/code&gt;，&lt;code&gt;console.log&lt;/code&gt;那一行就不会报错，而是会输出&lt;code&gt;undefined&lt;/code&gt;，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。&lt;/p&gt;
&lt;p&gt;所以，建议不再使用&lt;code&gt;var&lt;/code&gt;命令，而是使用&lt;code&gt;let&lt;/code&gt;命令取代。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="编程风格" scheme="https://codermae.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>打卡0095</title>
    <link href="https://codermae.github.io/2021/09/26/%E6%89%93%E5%8D%A10095/"/>
    <id>https://codermae.github.io/2021/09/26/%E6%89%93%E5%8D%A10095/</id>
    <published>2021-09-26T06:35:40.000Z</published>
    <updated>2021-09-27T05:22:44.546Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#90d7ec&gt;愿你我既可以朝九晚五、又可以浪迹天涯&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;25-Module-的加载实现&quot;&gt;&lt;a href=&quot;#25-Module-的加载实现&quot; class=&quot;headerlink&quot; title=&quot;25. Module 的加载实现&quot;&gt;&lt;/a&gt;25. Module 的加载实现&lt;/h3&gt;&lt;h4 id=&quot;25-1-浏览器加载&quot;&gt;&lt;a href=&quot;#25-1-浏览器加载&quot; class=&quot;headerlink&quot; title=&quot;25.1 浏览器加载&quot;&gt;&lt;/a&gt;25.1 浏览器加载&lt;/h4&gt;&lt;h5 id=&quot;25-1-1-传统方法&quot;&gt;&lt;a href=&quot;#25-1-1-传统方法&quot; class=&quot;headerlink&quot; title=&quot;25.1.1 传统方法&quot;&gt;&lt;/a&gt;25.1.1 传统方法&lt;/h5&gt;&lt;p&gt;HTML 网页中，浏览器通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签加载 JavaScript 脚本。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 页面内嵌的脚本 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&amp;quot;application/javascript&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// module code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 外部脚本 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&amp;quot;application/javascript&amp;quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&amp;quot;path/to/myModule.js&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此&lt;code&gt;type=&amp;quot;application/javascript&amp;quot;&lt;/code&gt;可以省略。&lt;/p&gt;
&lt;p&gt;默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。&lt;/p&gt;
&lt;p&gt;如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&amp;quot;path/to/myModule.js&amp;quot;&lt;/span&gt; defer&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&amp;quot;path/to/myModule.js&amp;quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签打开&lt;code&gt;defer&lt;/code&gt;或&lt;code&gt;async&lt;/code&gt;属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;与&lt;code&gt;async&lt;/code&gt;的区别是：&lt;code&gt;defer&lt;/code&gt;要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；&lt;code&gt;async&lt;/code&gt;一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，&lt;code&gt;defer&lt;/code&gt;是“渲染完再执行”，&lt;code&gt;async&lt;/code&gt;是“下载完就执行”。另外，如果有多个&lt;code&gt;defer&lt;/code&gt;脚本，会按照它们在页面出现的顺序加载，而多个&lt;code&gt;async&lt;/code&gt;脚本是不能保证加载顺序的。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Module 的加载实现" scheme="https://codermae.github.io/tags/Module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>打卡0094</title>
    <link href="https://codermae.github.io/2021/09/25/%E6%89%93%E5%8D%A10094/"/>
    <id>https://codermae.github.io/2021/09/25/%E6%89%93%E5%8D%A10094/</id>
    <published>2021-09-25T00:50:34.000Z</published>
    <updated>2021-09-27T05:22:40.820Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#121a2a&gt;勤奋的人总是按时起床，乐观的人总是那么阳光，努力的人总能超越梦想，正能量的人总是自带光芒。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;24-Module-的语法&quot;&gt;&lt;a href=&quot;#24-Module-的语法&quot; class=&quot;headerlink&quot; title=&quot;24. Module 的语法&quot;&gt;&lt;/a&gt;24. Module 的语法&lt;/h3&gt;&lt;h4 id=&quot;24-1-概述&quot;&gt;&lt;a href=&quot;#24-1-概述&quot; class=&quot;headerlink&quot; title=&quot;24.1 概述&quot;&gt;&lt;/a&gt;24.1 概述&lt;/h4&gt;&lt;p&gt;历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p&gt;
&lt;p&gt;在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。&lt;/p&gt;
&lt;p&gt;ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// CommonJS模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &amp;#123; stat, exists, readfile &amp;#125; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;fs&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; _fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;fs&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; stat = _fs.stat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; exists = _fs.exists;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; readfile = _fs.readfile;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码的实质是整体加载&lt;code&gt;fs&lt;/code&gt;模块（即加载&lt;code&gt;fs&lt;/code&gt;的所有方法），生成一个对象（&lt;code&gt;_fs&lt;/code&gt;），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。&lt;/p&gt;
&lt;p&gt;ES6 模块不是对象，而是通过&lt;code&gt;export&lt;/code&gt;命令显式指定输出的代码，再通过&lt;code&gt;import&lt;/code&gt;命令输入。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Module 的语法" scheme="https://codermae.github.io/tags/Module-%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>打卡0093</title>
    <link href="https://codermae.github.io/2021/09/24/%E6%89%93%E5%8D%A10093/"/>
    <id>https://codermae.github.io/2021/09/24/%E6%89%93%E5%8D%A10093/</id>
    <published>2021-09-24T01:02:43.000Z</published>
    <updated>2021-09-27T05:22:36.450Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#f15a22&gt;岁月因青春慨然以赴而更加美好，世间因少年挺身向前而更加瑰丽。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;23-Class-的继承&quot;&gt;&lt;a href=&quot;#23-Class-的继承&quot; class=&quot;headerlink&quot; title=&quot;23. Class 的继承&quot;&gt;&lt;/a&gt;23. Class 的继承&lt;/h3&gt;&lt;h4 id=&quot;23-1-简介&quot;&gt;&lt;a href=&quot;#23-1-简介&quot; class=&quot;headerlink&quot; title=&quot;23.1 简介&quot;&gt;&lt;/a&gt;23.1 简介&lt;/h4&gt;&lt;p&gt;Class 可以通过&lt;code&gt;extends&lt;/code&gt;关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ColorPoint&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码定义了一个&lt;code&gt;ColorPoint&lt;/code&gt;类，该类通过&lt;code&gt;extends&lt;/code&gt;关键字，继承了&lt;code&gt;Point&lt;/code&gt;类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个&lt;code&gt;Point&lt;/code&gt;类。下面，我们在&lt;code&gt;ColorPoint&lt;/code&gt;内部加上代码。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ColorPoint&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y, color&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;super&lt;/span&gt;(x, y); &lt;span class=&quot;comment&quot;&gt;// 调用父类的constructor(x, y)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.color = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;toString&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.color + &lt;span class=&quot;string&quot;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;super&lt;/span&gt;.toString(); &lt;span class=&quot;comment&quot;&gt;// 调用父类的toString()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，&lt;code&gt;constructor&lt;/code&gt;方法和&lt;code&gt;toString&lt;/code&gt;方法之中，都出现了&lt;code&gt;super&lt;/code&gt;关键字，它在这里表示父类的构造函数，用来新建父类的&lt;code&gt;this&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;子类必须在&lt;code&gt;constructor&lt;/code&gt;方法中调用&lt;code&gt;super&lt;/code&gt;方法，否则新建实例时会报错。这是因为子类自己的&lt;code&gt;this&lt;/code&gt;对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用&lt;code&gt;super&lt;/code&gt;方法，子类就得不到&lt;code&gt;this&lt;/code&gt;对象。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Class 的继承" scheme="https://codermae.github.io/tags/Class-%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>打卡0092</title>
    <link href="https://codermae.github.io/2021/09/22/%E6%89%93%E5%8D%A10092/"/>
    <id>https://codermae.github.io/2021/09/22/%E6%89%93%E5%8D%A10092/</id>
    <published>2021-09-22T02:08:34.000Z</published>
    <updated>2021-09-27T05:22:30.102Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#6a6da9&gt;你所厌烦的普通，也许是他生命中最珍贵的平凡。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;22-Class-的基本语法&quot;&gt;&lt;a href=&quot;#22-Class-的基本语法&quot; class=&quot;headerlink&quot; title=&quot;22. Class 的基本语法&quot;&gt;&lt;/a&gt;22. Class 的基本语法&lt;/h3&gt;&lt;h4 id=&quot;22-1-简介&quot;&gt;&lt;a href=&quot;#22-1-简介&quot; class=&quot;headerlink&quot; title=&quot;22.1 简介&quot;&gt;&lt;/a&gt;22.1 简介&lt;/h4&gt;&lt;h5 id=&quot;22-1-1-类的由来&quot;&gt;&lt;a href=&quot;#22-1-1-类的由来&quot; class=&quot;headerlink&quot; title=&quot;22.1.1 类的由来&quot;&gt;&lt;/a&gt;22.1.1 类的由来&lt;/h5&gt;&lt;p&gt;JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Point.prototype.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&amp;#x27;, &amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&amp;#x27;)&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。&lt;/p&gt;
&lt;p&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过&lt;code&gt;class&lt;/code&gt;关键字，可以定义类。&lt;/p&gt;
&lt;p&gt;基本上，ES6 的&lt;code&gt;class&lt;/code&gt;可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的&lt;code&gt;class&lt;/code&gt;写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的&lt;code&gt;class&lt;/code&gt;改写，就是下面这样。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;toString&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&amp;#x27;, &amp;#x27;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&amp;#x27;)&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="Class 的基本语法" scheme="https://codermae.github.io/tags/Class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>踩坑JavaScript</title>
    <link href="https://codermae.github.io/2021/09/16/%E8%B8%A9%E5%9D%91JavaScript/"/>
    <id>https://codermae.github.io/2021/09/16/%E8%B8%A9%E5%9D%91JavaScript/</id>
    <published>2021-09-16T12:33:23.000Z</published>
    <updated>2021-09-26T12:44:44.774Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffc20e&gt;人生当自勉，学习需坚持。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;踩坑记录&quot;&gt;&lt;a href=&quot;#踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;踩坑记录&quot;&gt;&lt;/a&gt;踩坑记录&lt;/h2&gt;</summary>
    
    
    
    <category term="踩坑" scheme="https://codermae.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑JavaScript" scheme="https://codermae.github.io/tags/%E8%B8%A9%E5%9D%91JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>踩坑Koa</title>
    <link href="https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91Koa/"/>
    <id>https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91Koa/</id>
    <published>2021-09-15T13:07:46.000Z</published>
    <updated>2021-09-26T12:44:47.993Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffc20e&gt;人生当自勉，学习需坚持。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;踩坑记录&quot;&gt;&lt;a href=&quot;#踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;踩坑记录&quot;&gt;&lt;/a&gt;踩坑记录&lt;/h2&gt;</summary>
    
    
    
    <category term="踩坑" scheme="https://codermae.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑Koa" scheme="https://codermae.github.io/tags/%E8%B8%A9%E5%9D%91Koa/"/>
    
  </entry>
  
  <entry>
    <title>踩坑MongoDB</title>
    <link href="https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91MongoDB/"/>
    <id>https://codermae.github.io/2021/09/15/%E8%B8%A9%E5%9D%91MongoDB/</id>
    <published>2021-09-15T12:32:52.000Z</published>
    <updated>2021-09-26T12:44:38.747Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#ffc20e&gt;人生当自勉，学习需坚持。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;踩坑记录&quot;&gt;&lt;a href=&quot;#踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;踩坑记录&quot;&gt;&lt;/a&gt;踩坑记录&lt;/h2&gt;</summary>
    
    
    
    <category term="踩坑" scheme="https://codermae.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="踩坑MongoDB" scheme="https://codermae.github.io/tags/%E8%B8%A9%E5%9D%91MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Chart文件说明</title>
    <link href="https://codermae.github.io/2021/09/10/Chart%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"/>
    <id>https://codermae.github.io/2021/09/10/Chart%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/</id>
    <published>2021-09-10T10:41:21.000Z</published>
    <updated>2021-09-13T07:13:43.234Z</updated>
    
    
    <summary type="html">&lt;p&gt;all&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>打卡0091</title>
    <link href="https://codermae.github.io/2021/08/29/%E6%89%93%E5%8D%A10091/"/>
    <id>https://codermae.github.io/2021/08/29/%E6%89%93%E5%8D%A10091/</id>
    <published>2021-08-29T04:43:41.000Z</published>
    <updated>2021-09-27T05:22:26.343Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#dea32c&gt;不害怕改变，才是给自己最好的安全感。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;21-async-函数&quot;&gt;&lt;a href=&quot;#21-async-函数&quot; class=&quot;headerlink&quot; title=&quot;21. async 函数&quot;&gt;&lt;/a&gt;21. async 函数&lt;/h3&gt;&lt;h4 id=&quot;21-1-含义&quot;&gt;&lt;a href=&quot;#21-1-含义&quot; class=&quot;headerlink&quot; title=&quot;21.1 含义&quot;&gt;&lt;/a&gt;21.1 含义&lt;/h4&gt;&lt;p&gt;ES2017 标准引入了 async 函数，使得异步操作变得更加方便。&lt;/p&gt;
&lt;p&gt;async 函数是什么？一句话，它就是 Generator 函数的语法糖。&lt;/p&gt;
&lt;p&gt;前文有一个 Generator 函数，依次读取两个文件。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;fs&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; readFile = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;fileName&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fs.readFile(fileName, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;error, data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reject(error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; gen = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; f1 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&amp;#x27;/etc/fstab&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; f2 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&amp;#x27;/etc/shells&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f1.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f2.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码的函数&lt;code&gt;gen&lt;/code&gt;可以写成&lt;code&gt;async&lt;/code&gt;函数，就是下面这样。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; asyncReadFile = &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; f1 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&amp;#x27;/etc/fstab&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; f2 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&amp;#x27;/etc/shells&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f1.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f2.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一比较就会发现，&lt;code&gt;async&lt;/code&gt;函数就是将 Generator 函数的星号（&lt;code&gt;*&lt;/code&gt;）替换成&lt;code&gt;async&lt;/code&gt;，将&lt;code&gt;yield&lt;/code&gt;替换成&lt;code&gt;await&lt;/code&gt;，仅此而已。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="JS-ES6 async 函数" scheme="https://codermae.github.io/tags/JS-ES6-async-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>打卡0090</title>
    <link href="https://codermae.github.io/2021/08/27/%E6%89%93%E5%8D%A10090/"/>
    <id>https://codermae.github.io/2021/08/27/%E6%89%93%E5%8D%A10090/</id>
    <published>2021-08-27T07:24:18.000Z</published>
    <updated>2021-09-27T05:22:21.590Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#2468a2&gt;生命，就是一场不留余地的盛放。心安，便是活着的最美好状态。平淡是生活的主线，精彩是人生的点缀。且安静，且放低，且自在，不张扬，也不颓废，这就是生活。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;20-Generator-函数的异步应用&quot;&gt;&lt;a href=&quot;#20-Generator-函数的异步应用&quot; class=&quot;headerlink&quot; title=&quot;20. Generator 函数的异步应用&quot;&gt;&lt;/a&gt;20. Generator 函数的异步应用&lt;/h3&gt;&lt;p&gt;异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。&lt;/p&gt;
&lt;h4 id=&quot;20-1-传统方法&quot;&gt;&lt;a href=&quot;#20-1-传统方法&quot; class=&quot;headerlink&quot; title=&quot;20.1 传统方法&quot;&gt;&lt;/a&gt;20.1 传统方法&lt;/h4&gt;&lt;p&gt;ES6 诞生以前，异步编程的方法，大概有下面四种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调函数&lt;/li&gt;
&lt;li&gt;事件监听&lt;/li&gt;
&lt;li&gt;发布/订阅&lt;/li&gt;
&lt;li&gt;Promise 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。&lt;/p&gt;
&lt;h4 id=&quot;20-2-基本概念&quot;&gt;&lt;a href=&quot;#20-2-基本概念&quot; class=&quot;headerlink&quot; title=&quot;20.2 基本概念&quot;&gt;&lt;/a&gt;20.2 基本概念&lt;/h4&gt;&lt;h5 id=&quot;20-2-1-异步&quot;&gt;&lt;a href=&quot;#20-2-1-异步&quot; class=&quot;headerlink&quot; title=&quot;20.2.1 异步&quot;&gt;&lt;/a&gt;20.2.1 异步&lt;/h5&gt;&lt;p&gt;所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。&lt;/p&gt;
&lt;p&gt;比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。&lt;/p&gt;
&lt;p&gt;相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="JS-ES6 Generator 函数的异步应用" scheme="https://codermae.github.io/tags/JS-ES6-Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>打卡0089</title>
    <link href="https://codermae.github.io/2021/08/24/%E6%89%93%E5%8D%A10089/"/>
    <id>https://codermae.github.io/2021/08/24/%E6%89%93%E5%8D%A10089/</id>
    <published>2021-08-24T08:59:18.000Z</published>
    <updated>2021-09-27T05:22:18.165Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#d5c59f&gt;收拾起心情，继续走吧，错过花，你将收获雨，错过这一个，你才会遇到下一个。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;18-Iterator-和-for…of-循环&quot;&gt;&lt;a href=&quot;#18-Iterator-和-for…of-循环&quot; class=&quot;headerlink&quot; title=&quot;18. Iterator 和 for…of 循环&quot;&gt;&lt;/a&gt;18. Iterator 和 for…of 循环&lt;/h3&gt;&lt;h4 id=&quot;18-1-Iterator（遍历器）的概念&quot;&gt;&lt;a href=&quot;#18-1-Iterator（遍历器）的概念&quot; class=&quot;headerlink&quot; title=&quot;18.1 Iterator（遍历器）的概念&quot;&gt;&lt;/a&gt;18.1 Iterator（遍历器）的概念&lt;/h4&gt;&lt;p&gt;JavaScript 原有的表示“集合”的数据结构，主要是数组（&lt;code&gt;Array&lt;/code&gt;）和对象（&lt;code&gt;Object&lt;/code&gt;），ES6 又添加了&lt;code&gt;Map&lt;/code&gt;和&lt;code&gt;Set&lt;/code&gt;。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。&lt;/p&gt;
&lt;p&gt;遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。&lt;/p&gt;
&lt;p&gt;Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令&lt;code&gt;for...of&lt;/code&gt;循环，Iterator 接口主要供&lt;code&gt;for...of&lt;/code&gt;消费。&lt;/p&gt;
&lt;p&gt;Iterator 的遍历过程是这样的。&lt;/p&gt;
&lt;p&gt;（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。&lt;/p&gt;
&lt;p&gt;（2）第一次调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，可以将指针指向数据结构的第一个成员。&lt;/p&gt;
&lt;p&gt;（3）第二次调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，指针就指向数据结构的第二个成员。&lt;/p&gt;
&lt;p&gt;（4）不断调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，直到它指向数据结构的结束位置。&lt;/p&gt;
&lt;p&gt;每一次调用&lt;code&gt;next&lt;/code&gt;方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;两个属性的对象。其中，&lt;code&gt;value&lt;/code&gt;属性是当前成员的值，&lt;code&gt;done&lt;/code&gt;属性是一个布尔值，表示遍历是否结束。&lt;/p&gt;
&lt;p&gt;下面是一个模拟&lt;code&gt;next&lt;/code&gt;方法返回值的例子。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="JS-ES6 Iterator 和 for...of 循环" scheme="https://codermae.github.io/tags/JS-ES6-Iterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>打卡0088</title>
    <link href="https://codermae.github.io/2021/08/21/%E6%89%93%E5%8D%A10088/"/>
    <id>https://codermae.github.io/2021/08/21/%E6%89%93%E5%8D%A10088/</id>
    <published>2021-08-21T06:50:43.000Z</published>
    <updated>2021-09-27T05:22:14.032Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#50b7c1&gt;世界可以无聊，但你要有趣，生活可能不如意，但你要过得有诗意。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;17-Promise-对象&quot;&gt;&lt;a href=&quot;#17-Promise-对象&quot; class=&quot;headerlink&quot; title=&quot;17. Promise 对象&quot;&gt;&lt;/a&gt;17. Promise 对象&lt;/h3&gt;&lt;h4 id=&quot;17-1-Promise-的含义&quot;&gt;&lt;a href=&quot;#17-1-Promise-的含义&quot; class=&quot;headerlink&quot; title=&quot;17.1 Promise 的含义&quot;&gt;&lt;/a&gt;17.1 Promise 的含义&lt;/h4&gt;&lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了&lt;code&gt;Promise&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;所谓&lt;code&gt;Promise&lt;/code&gt;，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象有以下两个特点。&lt;/p&gt;
&lt;p&gt;（1）对象的状态不受外界影响。&lt;code&gt;Promise&lt;/code&gt;对象代表一个异步操作，有三种状态：&lt;code&gt;pending&lt;/code&gt;（进行中）、&lt;code&gt;fulfilled&lt;/code&gt;（已成功）和&lt;code&gt;rejected&lt;/code&gt;（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是&lt;code&gt;Promise&lt;/code&gt;这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。&lt;/p&gt;
&lt;p&gt;（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。&lt;code&gt;Promise&lt;/code&gt;对象的状态改变，只有两种可能：从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;和从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对&lt;code&gt;Promise&lt;/code&gt;对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。&lt;/p&gt;
&lt;p&gt;注意，为了行文方便，本章后面的&lt;code&gt;resolved&lt;/code&gt;统一只指&lt;code&gt;fulfilled&lt;/code&gt;状态，不包含&lt;code&gt;rejected&lt;/code&gt;状态。&lt;/p&gt;
&lt;p&gt;有了&lt;code&gt;Promise&lt;/code&gt;对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，&lt;code&gt;Promise&lt;/code&gt;对象提供统一的接口，使得控制异步操作更加容易。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;也有一些缺点。首先，无法取消&lt;code&gt;Promise&lt;/code&gt;，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，&lt;code&gt;Promise&lt;/code&gt;内部抛出的错误，不会反应到外部。第三，当处于&lt;code&gt;pending&lt;/code&gt;状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。&lt;/p&gt;
&lt;p&gt;如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署&lt;code&gt;Promise&lt;/code&gt;更好的选择。&lt;/p&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="JS-ES6 Promise" scheme="https://codermae.github.io/tags/JS-ES6-Promise/"/>
    
  </entry>
  
  <entry>
    <title>打卡0087</title>
    <link href="https://codermae.github.io/2021/08/19/%E6%89%93%E5%8D%A10087/"/>
    <id>https://codermae.github.io/2021/08/19/%E6%89%93%E5%8D%A10087/</id>
    <published>2021-08-19T09:54:36.000Z</published>
    <updated>2021-09-27T05:22:08.906Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#f05b72&gt;不开心时，做个深呼吸，不过是糟糕的一天而已，又不是糟糕一辈子。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;16-Reflect&quot;&gt;&lt;a href=&quot;#16-Reflect&quot; class=&quot;headerlink&quot; title=&quot;16. Reflect&quot;&gt;&lt;/a&gt;16. Reflect&lt;/h3&gt;&lt;h4 id=&quot;16-1-概述&quot;&gt;&lt;a href=&quot;#16-1-概述&quot; class=&quot;headerlink&quot; title=&quot;16.1 概述&quot;&gt;&lt;/a&gt;16.1 概述&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;对象与&lt;code&gt;Proxy&lt;/code&gt;对象一样，也是 ES6 为了操作对象而提供的新 API。&lt;code&gt;Reflect&lt;/code&gt;对象的设计目的有这样几个。&lt;/p&gt;
&lt;p&gt;（1） 将&lt;code&gt;Object&lt;/code&gt;对象的一些明显属于语言内部的方法（比如&lt;code&gt;Object.defineProperty&lt;/code&gt;），放到&lt;code&gt;Reflect&lt;/code&gt;对象上。现阶段，某些方法同时在&lt;code&gt;Object&lt;/code&gt;和&lt;code&gt;Reflect&lt;/code&gt;对象上部署，未来的新方法将只部署在&lt;code&gt;Reflect&lt;/code&gt;对象上。也就是说，从&lt;code&gt;Reflect&lt;/code&gt;对象上可以拿到语言内部的方法。&lt;/p&gt;
&lt;p&gt;（2） 修改某些&lt;code&gt;Object&lt;/code&gt;方法的返回结果，让其变得更合理。比如，&lt;code&gt;Object.defineProperty(obj, name, desc)&lt;/code&gt;在无法定义属性时，会抛出一个错误，而&lt;code&gt;Reflect.defineProperty(obj, name, desc)&lt;/code&gt;则会返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 老写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(target, property, attributes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// success&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// failure&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 新写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Reflect&lt;/span&gt;.defineProperty(target, property, attributes)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// success&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// failure&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JS-ES6" scheme="https://codermae.github.io/categories/JS-ES6/"/>
    
    
    <category term="JS-ES6 Reflect" scheme="https://codermae.github.io/tags/JS-ES6-Reflect/"/>
    
  </entry>
  
</feed>
