<!DOCTYPE html>


<html lang="zh-Hans">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="blog" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>正则表达式 |  maeBlog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="maeBlog" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-正则表达式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  正则表达式
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2021-09-30T01:36:19.000Z" itemprop="datePublished">2021-09-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A7%AF%E7%B4%AF/">积累</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">25 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><font color=#122e29>不要低估别人的贪婪。</font></p>
<h3 id="1-使用测试方法"><a href="#1-使用测试方法" class="headerlink" title="1. 使用测试方法"></a>1. 使用测试方法</h3><p>使用<code>.test()</code> 方法，检测字符串 myString 是否符合正则表达式 myRegex 定义的规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myString = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/Hello/</span>;</span><br><span class="line"><span class="keyword">let</span> result = myRegex.test(myString); <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="2-匹配文字字符串"><a href="#2-匹配文字字符串" class="headerlink" title="2. 匹配文字字符串"></a>2. 匹配文字字符串</h3><p>完成正则表达式 waldoRegex，在字符串 waldoIsHiding 中匹配到文本 “Waldo”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> waldoIsHiding = <span class="string">&quot;Somewhere Waldo is hiding in this text.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> waldoRegex = <span class="regexp">/Waldo/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = waldoRegex.test(waldoIsHiding);</span><br></pre></td></tr></table></figure>
<h3 id="3-同时用多种模式匹配文字字符串"><a href="#3-同时用多种模式匹配文字字符串" class="headerlink" title="3. 同时用多种模式匹配文字字符串"></a>3. 同时用多种模式匹配文字字符串</h3><p>完成正则表达式 petRegex 以匹配 dog、cat、bird 或者 fish。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> petString = <span class="string">&quot;James has a pet cat.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> petRegex = <span class="regexp">/cat|dog|bird|fish/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = petRegex.test(petString);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="4-匹配时忽略大小写"><a href="#4-匹配时忽略大小写" class="headerlink" title="4. 匹配时忽略大小写"></a>4. 匹配时忽略大小写</h3><p>编写正则表达式 fccRegex 以匹配 freeCodeCamp，忽略大小写。 正则表达式不应与任何缩写或带有空格的变体匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myString = <span class="string">&quot;freeCodeCamp&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> fccRegex = <span class="regexp">/freeCodeCamp/i</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = fccRegex.test(myString);</span><br></pre></td></tr></table></figure>
<h3 id="5-提取匹配项"><a href="#5-提取匹配项" class="headerlink" title="5. 提取匹配项"></a>5. 提取匹配项</h3><p>利用 <code>.match()</code> 方法提取单词 coding。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> extractStr = <span class="string">&quot;Extract the word &#x27;coding&#x27; from this string.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> codingRegex = <span class="regexp">/coding/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = extractStr.match(codingRegex); <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="6-全局匹配"><a href="#6-全局匹配" class="headerlink" title="6. 全局匹配"></a>6. 全局匹配</h3><p>使用正则表达式 starRegex，从字符串 twinkleStar 中匹配所有的 Twinkle 单词并提取出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twinkleStar = <span class="string">&quot;Twinkle, twinkle, little star&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> starRegex = <span class="regexp">/Twinkle/gi</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = twinkleStar.match(starRegex); <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="7-用通配符匹配任何内容"><a href="#7-用通配符匹配任何内容" class="headerlink" title="7. 用通配符匹配任何内容"></a>7. 用通配符匹配任何内容</h3><p>通配符 <code>.</code> 将匹配任何一个字符。 通配符也叫 dot 或 period。 可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 hug、huh、hut 和 hum，可以使用正则表达式 /hu./ 匹配以上四个单词。完成正则表达式 unRegex 以匹配字符串 run、sun、fun、pun、nun 和 bun。 正则表达式中应该使用通配符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exampleStr = <span class="string">&quot;Let&#x27;s have fun with regular expressions!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> unRegex = <span class="regexp">/.un/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = unRegex.test(exampleStr);</span><br></pre></td></tr></table></figure>
<h3 id="8-将单个字符与多种可能性匹配"><a href="#8-将单个字符与多种可能性匹配" class="headerlink" title="8. 将单个字符与多种可能性匹配"></a>8. 将单个字符与多种可能性匹配</h3><p>已经了解了文字匹配模式（<code>/literal/</code>）和通配符（<code>/./</code>）。 这是正则表达式的两种极端情况，一种是精确匹配，而另一种则是匹配所有。 在这两种极端情况之间有一个平衡选项。</p>
<p>可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（<code>[ 和 ]</code>）之间来定义一组需要匹配的字符串。</p>
<p>例如，如果想要匹配 bag、big 和 bug，但是不想匹配 bog。 可以创建正则表达式 <code>/b[aiu]g/</code> 来执行此操作。<code>[aiu]</code> 是只匹配字符 a、i 或者 u 的字符集。</p>
<p>使用元音字符集（a、e、i、o、u）在正则表达式 vowelRegex 中匹配到字符串 quoteSample 中的所有元音。</p>
<p>**注意:**一定要同时匹配大小写元音。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;Beware of bugs in the above code; I have only proved it correct, not tried it.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> vowelRegex = <span class="regexp">/[aeiou]/gi</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(vowelRegex); <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="9-匹配字母表中的字母"><a href="#9-匹配字母表中的字母" class="headerlink" title="9. 匹配字母表中的字母"></a>9. 匹配字母表中的字母</h3><p>了解了如何使用字符集（character sets）来指定要匹配的一组字符串，但是有时需要匹配大量字符（例如，字母表中的每个字母）。 有一种写法可以让实现这个功能变得简短。</p>
<p>在字符集中，可以使用连字符（<code>-</code>）来定义要匹配的字符范围。</p>
<p>例如，要匹配小写字母 a 到 e，你可以使用 <code>[a-e]</code>。<br>匹配字符串 quoteSample 中的所有字母。<br>注意：一定要同时匹配大小写字母。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> alphabetRegex = <span class="regexp">/[a-z]/gi</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(alphabetRegex); <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="10-匹配字母表中的数字和字母"><a href="#10-匹配字母表中的数字和字母" class="headerlink" title="10. 匹配字母表中的数字和字母"></a>10. 匹配字母表中的数字和字母</h3><p>使用连字符（<code>-</code>）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。</p>
<p>例如，<code>/[0-5]/</code>匹配 0 和 5 之间的任意数字，包含 0 和 5。</p>
<p>此外，还可以在单个字符集中组合一系列字母和数字。<br>创建一个正则表达式，使其可以匹配 h 和 s 之间的一系列字母，以及 2 和 6 之间的一系列数字。 请记得在正则表达式中包含恰当的标志。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;Blueberry 3.141592653s are delicious.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/[h-s2-6]/gi</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(myRegex); <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="11-匹配单个未指定的字符"><a href="#11-匹配单个未指定的字符" class="headerlink" title="11.  匹配单个未指定的字符"></a>11.  匹配单个未指定的字符</h3><p>到目前为止，已经创建了一个想要匹配的字符集合，但也可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。</p>
<p>要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即<code>^</code>）。</p>
<p>例如，<code>/[^aeiou]/gi</code> 匹配所有非元音字符。 注意，字符 <code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code> 和<code>空白字符</code>等也会被匹配，该否定字符集仅排除元音字符。</p>
<p>创建一个匹配所有非数字或元音字符的正则表达式。 请记得在正则表达式中包含恰当的标志。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;3 blind mice.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/[^aeiou0-9]/gi</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(myRegex); <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="12-匹配出现一次或多次的字符"><a href="#12-匹配出现一次或多次的字符" class="headerlink" title="12. 匹配出现一次或多次的字符"></a>12. 匹配出现一次或多次的字符</h3><p>有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。</p>
<p>可以使用 <code>+</code> 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。</p>
<p>例如，<code>/a+/g</code> 会在 abc 中匹配到一个匹配项，并且返回 <code>[&quot;a&quot;]</code>。 因为 <code>+</code> 的存在，它也会在 aabc 中匹配到一个匹配项，然后返回 <code>[&quot;aa&quot;]</code>。</p>
<p>如果它是检查字符串 abab，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。 最后，因为在字符串 bcd 中没有 a，因此找不到匹配项。</p>
<p>想要在字符串 Mississippi 中匹配到出现一次或多次的字母 s 的匹配项。 编写一个使用 <code>+</code> 符号的正则表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> difficultSpelling = <span class="string">&quot;Mississippi&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/s+/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = difficultSpelling.match(myRegex);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h3 id="13-匹配出现零次或多次的字符"><a href="#13-匹配出现零次或多次的字符" class="headerlink" title="13. 匹配出现零次或多次的字符"></a>13. 匹配出现零次或多次的字符</h3><p>上一次的挑战中使用了加号 <code>+</code> 来查找出现一次或多次的字符。 还有一个选项可以匹配出现零次或多次的字符。</p>
<p>执行该操作的字符叫做星号，即<code>*</code>。<br>在这个挑战里，chewieQuote 已经被初始化为 Aaaaaaaaaaaaaaaarrrgh!。 创建一个变量为 chewieRegex 的正则表达式，使用 <code>*</code> 在 chewieQuote 中匹配 A 及其之后出现的零个或多个a。 你的正则表达式不需要使用修饰符，也不需要匹配引号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只修改这一行下面的代码</span></span><br><span class="line"><span class="keyword">let</span> chewieRegex = <span class="regexp">/Aa*/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="comment">// 只修改这一行上面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = chewieQuote.match(chewieRegex);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h3 id="14-用惰性匹配来查找字符"><a href="#14-用惰性匹配来查找字符" class="headerlink" title="14. 用惰性匹配来查找字符"></a>14. 用惰性匹配来查找字符</h3><p>在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p>
<p>可以将正则表达式 <code>/t[a-z]*i/</code> 应用于字符串 “titanic”。 这个正则表达式是一个以 t 开始，以 i 结束，并且中间有一些字母的匹配模式。</p>
<p>正则表达式默认是贪婪匹配，因此匹配返回为 <code>[&quot;titani&quot;]</code>。 它会匹配到适合该匹配模式的最大子字符串。</p>
<p>但是，你可以使用 <code>?</code> 字符来将其变成懒惰匹配。 调整后的正则表达式 <code>/t[a-z]*?i/</code> 匹配字符串 “titanic” 返回 <code>[&quot;ti&quot;]</code>。</p>
<p><strong>注意：</strong>应该避免使用正则表达式解析 HTML，但是可以用正则表达式匹配 HTML 字符串。</p>
<p>修复正则表达式 <code>/&lt;.*&gt;/</code>，让它返回 HTML 标签 <code>&lt;h1&gt;</code>，而不是文本 “<code>&lt;h1&gt;Winter is coming&lt;/h1&gt;</code>“。 请记得在正则表达式中使用通配符 <code>.</code> 来匹配任意字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;&lt;h1&gt;Winter is coming&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/&lt;.*?&gt;/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = text.match(myRegex);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h3 id="15-在狩猎中找到一个或多个罪犯"><a href="#15-在狩猎中找到一个或多个罪犯" class="headerlink" title="15. 在狩猎中找到一个或多个罪犯"></a>15. 在狩猎中找到一个或多个罪犯</h3><p>是时候停一停来测试你的正则表达式使用能力了。 一群罪犯越狱逃跑了，但你不知道有多少人。 然而，你知道他们不在一起时会保持紧密联系。 你有责任立刻找到所有的罪犯。</p>
<p>这里有一个示例来提示如何做到这一点：</p>
<p>当字母<code>z</code>在一行中出现一次或连续多次时，正则表达式<code>/z+/</code>会匹配到它。 它会在以下所有字符串中找到匹配项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;z&quot;</span><br><span class="line">&quot;zzzzzz&quot;</span><br><span class="line">&quot;ABCzzzz&quot;</span><br><span class="line">&quot;zzzzABC&quot;</span><br><span class="line">&quot;abczzzzzzzzzzzzzzzzzzzzzabc&quot;</span><br></pre></td></tr></table></figure>
<p>但是它不会在以下字符串中找到匹配项，因为它们中没有字母<code>z</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;</span><br><span class="line">&quot;ABC&quot;</span><br><span class="line">&quot;abcabc&quot;</span><br></pre></td></tr></table></figure>
<p>编写一个贪婪正则表达式，在一组其他人中匹配到一个或多个罪犯。 罪犯由大写字母<code>C</code>表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reCriminals = <span class="regexp">/C+/</span>; <span class="comment">// 修改这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="16-匹配字符串的开头"><a href="#16-匹配字符串的开头" class="headerlink" title="16. 匹配字符串的开头"></a>16. 匹配字符串的开头</h3><p>回顾一下之前的挑战，正则表达式可以用于查找多项匹配。 还可以查询字符串中符合指定匹配模式的字符。</p>
<p>在之前的挑战中，使用字符集中前插入符号（<code>^</code>）来创建一个否定字符集，形如 <code>[^thingsThatWillNotBeMatched]</code>。 除了在字符集中使用之外，脱字符还用于匹配字符串的开始位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let firstString &#x3D; &quot;Ricky is first and can be found.&quot;;</span><br><span class="line">let firstRegex &#x3D; &#x2F;^Ricky&#x2F;;</span><br><span class="line">firstRegex.test(firstString);</span><br><span class="line">let notFirst &#x3D; &quot;You can&#39;t find Ricky now.&quot;;</span><br><span class="line">firstRegex.test(notFirst);</span><br></pre></td></tr></table></figure>
<p>第一次 test 调用将返回 true，而第二次调用将返回 false。</p>
<p>在正则表达式中使用脱字符来找到 Cal 在字符串 rickyAndCal 中的开始位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rickyAndCal = <span class="string">&quot;Cal and Ricky both like racing.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> calRegex = <span class="regexp">/^Cal/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = calRegex.test(rickyAndCal);</span><br></pre></td></tr></table></figure>
<h3 id="17-匹配字符串的末尾"><a href="#17-匹配字符串的末尾" class="headerlink" title="17. 匹配字符串的末尾"></a>17. 匹配字符串的末尾</h3><p>在上一个挑战中，学习了使用脱字符号来搜寻字符串的开始位置。 还有一种方法可以搜寻字符串末尾的匹配模式。</p>
<p>可以使用正则表达式的美元符号 <code>$</code> 来搜寻字符串的结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let theEnding &#x3D; &quot;This is a never ending story&quot;;</span><br><span class="line">let storyRegex &#x3D; &#x2F;story$&#x2F;;</span><br><span class="line">storyRegex.test(theEnding);</span><br><span class="line">let noEnding &#x3D; &quot;Sometimes a story will have to end&quot;;</span><br><span class="line">storyRegex.test(noEnding);</span><br></pre></td></tr></table></figure>
<p>第一次 test 调用将返回 true, 而第二次调用将返回 false。</p>
<p>使用锚点字符 <code>$</code> 来匹配字符串 caboose 在字符串末尾 caboose。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> caboose = <span class="string">&quot;The last car on a train is the caboose&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastRegex = <span class="regexp">/caboose$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = lastRegex.test(caboose);</span><br></pre></td></tr></table></figure>
<h3 id="18-匹配所有的字母和数字"><a href="#18-匹配所有的字母和数字" class="headerlink" title="18. 匹配所有的字母和数字"></a>18. 匹配所有的字母和数字</h3><p>使用元字符，可以使用 <code>[a-z]</code> 搜寻字母表中的所有字母。 这种元字符是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p>
<p>JavaScript 中与字母表匹配的最接近的元字符是<code>\w</code>。 这个缩写等同于<code>[A-Za-z0-9_]</code>。 此字符类匹配大写字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (<code>_</code>)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let longHand &#x3D; &#x2F;[A-Za-z0-9_]+&#x2F;;</span><br><span class="line">let shortHand &#x3D; &#x2F;\w+&#x2F;;</span><br><span class="line">let numbers &#x3D; &quot;42&quot;;</span><br><span class="line">let varNames &#x3D; &quot;important_var&quot;;</span><br><span class="line">longHand.test(numbers);</span><br><span class="line">shortHand.test(numbers);</span><br><span class="line">longHand.test(varNames);</span><br><span class="line">shortHand.test(varNames);</span><br></pre></td></tr></table></figure>
<p>上面的 test 都会返回 true。</p>
<p>这些元字符缩写也被称为短语元字符 shorthand character classes。</p>
<p>使用元字符 <code>\w</code> 来计算所有引号中字母和数字字符的数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> alphabetRegexV2 = <span class="regexp">/\w/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(alphabetRegexV2).length;</span><br></pre></td></tr></table></figure>
<h3 id="19-匹配除了字母和数字的所有符号"><a href="#19-匹配除了字母和数字的所有符号" class="headerlink" title="19. 匹配除了字母和数字的所有符号"></a>19. 匹配除了字母和数字的所有符号</h3><p>已经了解到可以使用缩写 <code>\w</code> 来匹配字母和数字 <code>[A-Za-z0-9_]</code>。 不过，有可能想要搜寻的匹配模式是非字母数字字符。</p>
<p>可以使用 <code>\W</code> 搜寻和 <code>\w</code> 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 <code>[^A-Za-z0-9_]</code> 是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let shortHand &#x3D; &#x2F;\W&#x2F;;</span><br><span class="line">let numbers &#x3D; &quot;42%&quot;;</span><br><span class="line">let sentence &#x3D; &quot;Coding!&quot;;</span><br><span class="line">numbers.match(shortHand);</span><br><span class="line">sentence.match(shortHand);</span><br></pre></td></tr></table></figure>
<p>第一次 match 调用将返回值 <code>[&quot;%&quot;]</code> 而第二次调用将返回 <code>[&quot;!&quot;]</code>。</p>
<p>使用缩写 <code>\W</code> 来计算引号中所有非字符字母和数字字符的数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> nonAlphabetRegex = <span class="regexp">/\W/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(nonAlphabetRegex).length;</span><br></pre></td></tr></table></figure>
<h3 id="20-匹配所有数字"><a href="#20-匹配所有数字" class="headerlink" title="20. 匹配所有数字"></a>20. 匹配所有数字</h3><p>已经了解了常见字符串匹配模式的元字符，如字母数字。 另一个常见的匹配模式是只寻找数字。</p>
<p>查找数字字符的缩写是 <code>\d</code>，注意是小写的 <code>d</code>。 这等同于元字符 <code>[0-9]</code>，它查找 0 到 9 之间任意数字的单个字符。</p>
<p>使用缩写 <code>\d</code> 来计算电影标题中有多少个数字。 书面数字（”six” 而不是 6）不计算在内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> movieName = <span class="string">&quot;2001: A Space Odyssey&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> numRegex = <span class="regexp">/\d/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = movieName.match(numRegex).length;</span><br></pre></td></tr></table></figure>
<h3 id="21-匹配所有非数字"><a href="#21-匹配所有非数字" class="headerlink" title="21. 匹配所有非数字"></a>21. 匹配所有非数字</h3><p>上一项挑战中展示了如何使用带有小写 <code>d</code> 的缩写 <code>\d</code> 来搜寻数字。 也可以使用类似的缩写来搜寻非数字，该缩写使用大写的 <code>D</code>。</p>
<p>查找非数字字符的缩写是 <code>\D</code>。 这等同于字符串 <code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p>
<p>使用非数字缩写 <code>\D</code> 来计算电影标题中有多少非数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> movieName = <span class="string">&quot;2001: A Space Odyssey&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> noNumRegex = <span class="regexp">/\D/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = movieName.match(noNumRegex).length;</span><br></pre></td></tr></table></figure>
<h3 id="22-限制可能的用户名"><a href="#22-限制可能的用户名" class="headerlink" title="22.限制可能的用户名"></a>22.限制可能的用户名</h3><p>用户名在互联网上随处可见。 它们是用户在自己喜欢的网站上的唯一身份。</p>
<p>需要检索数据库中的所有用户名。 以下是用户在创建用户名时必须遵守的一些简单规则。</p>
<ol>
<li><p>用户名只能是数字字母字符。</p>
</li>
<li><p>用户名中的数字必须在最后。 数字可以有零个或多个。 用户名不能以数字开头。</p>
</li>
<li><p>用户名字母可以是小写字母和大写字母。</p>
</li>
<li><p>用户名长度必须至少为两个字符。 两位用户名只能使用字母。</p>
</li>
</ol>
<p>修改正则表达式 userCheck 以满足上面列出的约束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;JackOfAllTrades&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> userCheck = <span class="regexp">/^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i</span>;</span><br><span class="line"><span class="keyword">let</span> result = userCheck.test(username);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h3 id="23-匹配空白字符"><a href="#23-匹配空白字符" class="headerlink" title="23. 匹配空白字符"></a>23. 匹配空白字符</h3><p>迄今为止的挑战包括匹配字母和数字。 还可以匹配字符之间的空格。</p>
<p>可以使用 <code>\s</code> 搜寻空格，其中 <code>s</code> 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[ \r\t\f\n\v]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let whiteSpace &#x3D; &quot;Whitespace. Whitespace everywhere!&quot;</span><br><span class="line">let spaceRegex &#x3D; &#x2F;\s&#x2F;g;</span><br><span class="line">whiteSpace.match(spaceRegex);</span><br></pre></td></tr></table></figure>
<p>这个 match 调用将返回 <code>[&quot; &quot;, &quot; &quot;]</code>。</p>
<p>修改正则表达式 countWhiteSpace 查找字符串中的多个空白字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sample = <span class="string">&quot;Whitespace is important in separating words&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> countWhiteSpace = <span class="regexp">/\s/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = sample.match(countWhiteSpace);</span><br></pre></td></tr></table></figure>
<h3 id="24-匹配非空白字符"><a href="#24-匹配非空白字符" class="headerlink" title="24. 匹配非空白字符"></a>24. 匹配非空白字符</h3><p>已经学会了如何使用带有小写 <code>s</code> 的缩写 <code>\s</code> 来搜寻空白字符。 还可以搜寻除了空格之外的所有内容。</p>
<p>使用 <code>\S</code> 搜寻非空白字符，其中 <code>s</code> 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[^ \r\t\f\n\v]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let whiteSpace &#x3D; &quot;Whitespace. Whitespace everywhere!&quot;</span><br><span class="line">let nonSpaceRegex &#x3D; &#x2F;\S&#x2F;g;</span><br><span class="line">whiteSpace.match(nonSpaceRegex).length;</span><br></pre></td></tr></table></figure>
<p>返回值的 <code>.length</code> 应该是 <code>32</code>。</p>
<p>修改正则表达式 <code>countNonWhiteSpace</code> 以查找字符串中的多个非空字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sample = <span class="string">&quot;Whitespace is important in separating words&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> countNonWhiteSpace = <span class="regexp">/\S/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = sample.match(countNonWhiteSpace);</span><br></pre></td></tr></table></figure>
<h3 id="25-指定匹配的上限和下限"><a href="#25-指定匹配的上限和下限" class="headerlink" title="25. 指定匹配的上限和下限"></a>25. 指定匹配的上限和下限</h3><p>回想一下，使用加号 <code>+</code> 查找一个或多个字符，使用星号 <code>*</code> 查找零个或多个字符。 这些都很方便，但有时需要匹配一定范围的匹配模式。</p>
<p>可以使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（<code>&#123; 和 &#125;</code>）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p>
<p>例如，要匹配出现 3 到 5 次字母 a 的在字符串 ah，正则表达式应为<code>/a&#123;3,5&#125;h/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let A4 &#x3D; &quot;aaaah&quot;;</span><br><span class="line">let A2 &#x3D; &quot;aah&quot;;</span><br><span class="line">let multipleA &#x3D; &#x2F;a&#123;3,5&#125;h&#x2F;;</span><br><span class="line">multipleA.test(A4);</span><br><span class="line">multipleA.test(A2);</span><br></pre></td></tr></table></figure>
<p>第一次 test 调用将返回 true，而第二次调用将返回 false。</p>
<p>修改正则表达式 ohRegex 以匹配出现 3 到 6 次字母 h 的字符串 Oh no。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ohStr = <span class="string">&quot;Ohhh no&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> ohRegex = <span class="regexp">/Oh&#123;3,6&#125;\sno/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = ohRegex.test(ohStr);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h3 id="26-只指定匹配的下限"><a href="#26-只指定匹配的下限" class="headerlink" title="26. 只指定匹配的下限"></a>26. 只指定匹配的下限</h3><p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时候只想指定匹配模式的下限而不需要指定上限。</p>
<p>为此，在第一个数字后面跟一个逗号即可。</p>
<p>例如，要匹配至少出现 3 次字母 a 的字符串 hah，正则表达式应该是 <code>/ha&#123;3,&#125;h/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let A4 &#x3D; &quot;haaaah&quot;;</span><br><span class="line">let A2 &#x3D; &quot;haah&quot;;</span><br><span class="line">let A100 &#x3D; &quot;h&quot; + &quot;a&quot;.repeat(100) + &quot;h&quot;;</span><br><span class="line">let multipleA &#x3D; &#x2F;ha&#123;3,&#125;h&#x2F;;</span><br><span class="line">multipleA.test(A4);</span><br><span class="line">multipleA.test(A2);</span><br><span class="line">multipleA.test(A100);</span><br></pre></td></tr></table></figure>
<p>按顺序排列，三次 test 调用将返回值 true，false 和 true。</p>
<p>修改正则表达式 haRegex，匹配包含四个或更多字母 z 的单词 Hazzah。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> haStr = <span class="string">&quot;Hazzzzah&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> haRegex = <span class="regexp">/Haz&#123;4,&#125;ah/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = haRegex.test(haStr);</span><br></pre></td></tr></table></figure>
<h3 id="27-指定匹配的确切数量"><a href="#27-指定匹配的确切数量" class="headerlink" title="27. 指定匹配的确切数量"></a>27. 指定匹配的确切数量</h3><p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时只需要特定数量的匹配。</p>
<p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p>
<p>例如，要只匹配字母 a 出现 3 次的单词hah，正则表达式应为<code>/ha&#123;3&#125;h/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let A4 &#x3D; &quot;haaaah&quot;;</span><br><span class="line">let A3 &#x3D; &quot;haaah&quot;;</span><br><span class="line">let A100 &#x3D; &quot;h&quot; + &quot;a&quot;.repeat(100) + &quot;h&quot;;</span><br><span class="line">let multipleHA &#x3D; &#x2F;ha&#123;3&#125;h&#x2F;;</span><br><span class="line">multipleHA.test(A4);</span><br><span class="line">multipleHA.test(A3);</span><br><span class="line">multipleHA.test(A100);</span><br></pre></td></tr></table></figure>
<p>按顺序排列，三次 test 调用将返回值 false，true 和 false。</p>
<p>修改正则表达式timRegex，以匹配仅有四个字母 m 的单词 Timber。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timStr = <span class="string">&quot;Timmmmber&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> timRegex = <span class="regexp">/im&#123;4&#125;b/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = timRegex.test(timStr);</span><br></pre></td></tr></table></figure>
<h3 id="28-检查全部或无"><a href="#28-检查全部或无" class="headerlink" title="28. 检查全部或无"></a>28. 检查全部或无</h3><p>有时，想要搜寻的匹配模式可能有不确定是否存在的部分。 尽管如此，还是想检查它们。</p>
<p>为此，可以使用问号 <code>?</code> 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。</p>
<p>例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let american &#x3D; &quot;color&quot;;</span><br><span class="line">let british &#x3D; &quot;colour&quot;;</span><br><span class="line">let rainbowRegex&#x3D; &#x2F;colou?r&#x2F;;</span><br><span class="line">rainbowRegex.test(american);</span><br><span class="line">rainbowRegex.test(british);</span><br></pre></td></tr></table></figure>
<p>上面的 test 都会返回 true。</p>
<p>修改正则表达式 favRegex 以匹配美式英语（favorite）和英式英语（favourite）的单词版本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favWord = <span class="string">&quot;favorite&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> favRegex = <span class="regexp">/ou?/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="comment">//let favRegex = /favou?rite/; // 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = favRegex.test(favWord);</span><br></pre></td></tr></table></figure>
<h3 id="29-正向先行断言和负向先行断言"><a href="#29-正向先行断言和负向先行断言" class="headerlink" title="29. 正向先行断言和负向先行断言"></a>29. 正向先行断言和负向先行断言</h3><p>先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。</p>
<p>有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。</p>
<p>正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 (<code>?=...</code>)，其中 <code>...</code> 就是需要存在但不会被匹配的部分。</p>
<p>另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 (<code>?!...</code>)，其中 <code>...</code> 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p>
<p>尽管先行断言有点儿令人困惑，但是这些示例会有所帮助。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let quit &#x3D; &quot;qu&quot;;</span><br><span class="line">let noquit &#x3D; &quot;qt&quot;;</span><br><span class="line">let quRegex&#x3D; &#x2F;q(?&#x3D;u)&#x2F;;</span><br><span class="line">let qRegex &#x3D; &#x2F;q(?!u)&#x2F;;</span><br><span class="line">quit.match(quRegex);</span><br><span class="line">noquit.match(qRegex);</span><br></pre></td></tr></table></figure>
<p>这两次 match 调用都将返回 <code>[&quot;q&quot;]</code>。</p>
<p>先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let password &#x3D; &quot;abc123&quot;;</span><br><span class="line">let checkPass &#x3D; &#x2F;(?&#x3D;\w&#123;3,6&#125;)(?&#x3D;\D*\d)&#x2F;;</span><br><span class="line">checkPass.test(password);</span><br></pre></td></tr></table></figure>
<p>在正则表达式 pwRegex 中使用先行断言以匹配大于 5 个字符且有两个连续数字的密码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleWord = <span class="string">&quot;astronaut&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pwRegex = <span class="regexp">/(?=\w&#123;6&#125;)(?=\w*\d&#123;2&#125;)/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = pwRegex.test(sampleWord);</span><br></pre></td></tr></table></figure>
<h3 id="30-检查混合字符组"><a href="#30-检查混合字符组" class="headerlink" title="30. 检查混合字符组"></a>30. 检查混合字符组</h3><p>有时候我们想使用正则表达式里的括号 <code>()</code> 来检查字符组。</p>
<p>如果想在字符串找到 Penguin 或 Pumpkin，可以用这个正则表达式：<code>/P(engu|umpk)in/g</code>。</p>
<p>然后使用 test() 方法检查 test 字符串里面是否包含字符组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let testStr &#x3D; &quot;Pumpkin&quot;;</span><br><span class="line">let testRegex &#x3D; &#x2F;P(engu|umpk)in&#x2F;;</span><br><span class="line">testRegex.test(testStr);</span><br></pre></td></tr></table></figure>
<p>test 方法会返回 true。</p>
<p>完善正则表达式，使其以区分大小写的方式检查 Franklin Roosevelt 或 Eleanor Roosevelt 的名字，并且应该忽略 middle names。</p>
<p>然后完善代码，使创建的正则检查 myString，根据正则是否匹配返回 true 或 false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myString = <span class="string">&quot;Eleanor Roosevelt&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/(Franklin|Eleanor).*Roosevelt/</span>;</span><br><span class="line"><span class="keyword">let</span> result = myRegex.test(myString);</span><br></pre></td></tr></table></figure>
<h3 id="31-使用捕获组重用模式"><a href="#31-使用捕获组重用模式" class="headerlink" title="31. 使用捕获组重用模式"></a>31. 使用捕获组重用模式</h3><p>当你想要匹配一个像下面这样多次出现的单词，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let repeatStr &#x3D; &quot;row row row your boat&quot;;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>/row row row/</code>。但如果你不知道重复的特定单词，怎么办？ 捕获组 可以用于找到重复的子字符串。</p>
<p>捕获组是通过把要捕获的正则表达式放在括号中来构建的。 在这个例子里， 目标是捕获一个包含字母数字字符的词，所以捕获组是将 <code>\w+</code> 放在括号中：<code>/(\w+)/</code>。</p>
<p>分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：<code>\1</code>）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。</p>
<p>下面的示例是匹配被空格隔开的两个相同单词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let repeatRegex &#x3D; &#x2F;(\w+) \1 \1&#x2F;;</span><br><span class="line">repeatRegex.test(repeatStr); &#x2F;&#x2F; Returns true</span><br><span class="line">repeatStr.match(repeatRegex); &#x2F;&#x2F; Returns [&quot;row row row&quot;, &quot;row&quot;]</span><br></pre></td></tr></table></figure>
<p>在字符串上调用 <code>.match()</code> 方法将返回一个数组，其中包含它最终匹配到的子字符串及其捕获组。</p>
<p>在 reRegex 中使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatNum = <span class="string">&quot;42 42 42&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reRegex = <span class="regexp">/^(\d+)\s\1\s\1$/</span>;</span><br><span class="line"><span class="keyword">let</span> result = reRegex.test(repeatNum);</span><br></pre></td></tr></table></figure>
<h3 id="32-使用捕获组搜索和替换"><a href="#32-使用捕获组搜索和替换" class="headerlink" title="32. 使用捕获组搜索和替换"></a>32. 使用捕获组搜索和替换</h3><p>搜索功能是很有用的。 但是，当搜索同时也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p>
<p>可以在字符串上使用 <code>.replace()</code> 方法来搜索并替换字符串中的文本。 <code>.replace()</code> 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let wrongText &#x3D; &quot;The sky is silver.&quot;;</span><br><span class="line">let silverRegex &#x3D; &#x2F;silver&#x2F;;</span><br><span class="line">wrongText.replace(silverRegex, &quot;blue&quot;);</span><br></pre></td></tr></table></figure>
<p>replace 调用将返回字符串 The sky is blue.。</p>
<p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Code Camp&quot;.replace(&#x2F;(\w+)\s(\w+)&#x2F;, &#39;$2 $1&#39;);</span><br></pre></td></tr></table></figure>
<p>调用 replace 将返回字符串 Camp Code。</p>
<p>使用三个捕获组编写一个正则表达式 fixRegex，这三个捕获组将搜索字符串 one two three 中的每个单词。 然后更新 replaceText 变量，以字符串 three two one 替换 one two three，并将结果分配给 result 变量。 确保使用美元符号（<code>$</code>）语法在替换字符串中使用捕获组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;one two three&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> fixRegex = <span class="regexp">/(\w+)\s(\w+)\s(\w+)/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> replaceText = <span class="string">&quot;$3 $2 $1&quot;</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = str.replace(fixRegex, replaceText);</span><br></pre></td></tr></table></figure>
<h3 id="33-删除开头和结尾的空白"><a href="#33-删除开头和结尾的空白" class="headerlink" title="33. 删除开头和结尾的空白"></a>33. 删除开头和结尾的空白</h3><p>有时字符串周围存在的空白字符并不是必需的。 字符串的典型处理是删除字符串开头和结尾处的空格。</p>
<p>编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。</p>
<p>注意： <code>String.prototype.trim()</code> 方法在这里也可以实现同样的效果，但是你需要使用正则表达式来完成此项挑战。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;   Hello, World!  &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wsRegex = <span class="regexp">/^\s+|\s+$/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = hello.replace(wsRegex, <span class="string">&quot;&quot;</span>); <span class="comment">//  修改这一行</span></span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://codermae.github.io/2021/09/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/10/01/%E6%89%93%E5%8D%A10101/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            打卡0101
          
        </div>
      </a>
    
    
      <a href="/2021/09/30/%E6%89%93%E5%8D%A10100/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">打卡0100</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "avTd9ACxjrzISKe7xjXxusIG-gzGzoHsz",
    app_key: "MLTA9Ebb5SAXUVwSg065nTfD",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> Ye Ma
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="maeBlog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/travel">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about/2021">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2021/05/01/gHZjdQRcOL1WxSP.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2021/05/01/pZNYuI4QFnfwb7l.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=574919767&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>